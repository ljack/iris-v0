(program
  (module (name "type_check_expr") (version 1))
  (imports
    (import "ast" (as "ast"))
    (import "list" (as "list"))
    (import "str" (as "str"))
    (import "type_env" (as "env"))
    (import "type_eq" (as "teq"))
  )
  (defs
    (deffn (name type_check) (args (e ast.Expr) (context env.TypeEnv)) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match e
                (case (tag "Literal" (val)) (tag "Ok" (call get_value_type val)))
                (case (tag "Var" (v))
                    (match (call env.env_get context v.name)
                        (case (tag "Some" (ty)) (tag "Ok" ty))
                        (case (tag "None") (tag "Err" (str.concat "Undefined variable: " v.name)))
                    )
                )
                (case (tag "Let" (l))
                    (let (val_res (call type_check l.value context))
                        (match val_res
                            (case (tag "Ok" (ty))
                                (call type_check l.body (call env.env_put context l.name ty))
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
                (case (tag "If" (i))
                    (let (cond_res (call type_check i.cond context))
                        (match cond_res
                            (case (tag "Ok" (cond_ty))
                                (if (call teq.type_eq cond_ty (tag "Bool" (record)))
                                    (let (then_res (call type_check i.then context))
                                        (match then_res
                                            (case (tag "Ok" (then_ty))
                                                (let (else_res (call type_check i.else context))
                                                    (match else_res
                                                        (case (tag "Ok" (else_ty))
                                                            (if (call teq.type_eq then_ty else_ty)
                                                                (tag "Ok" then_ty)
                                                                (tag "Err" "If branches have inconsistent types")
                                                            )
                                                        )
                                                        (case (tag "Err" (err)) (tag "Err" err))
                                                    )
                                                )
                                            )
                                            (case (tag "Err" (err)) (tag "Err" err))
                                        )
                                    )
                                    (tag "Err" "If condition must be Bool")
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Match" (m))
                    (let (target_res (call type_check m.target context))
                        (match target_res
                            (case (tag "Ok" (target_ty))
                                (call type_check_match m.cases target_ty context (tag "None"))
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Intrinsic" (i))
                    (let (res_args (call type_check_list i.args context))
                        (match res_args
                            (case (tag "Ok" (arg_tys)) (call check_intrinsic i.op arg_tys))
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Call" (c))
                    (let (res_fn (call env.env_get_fn context c.name))
                        (match res_fn
                            (case (tag "Some" (fn_ty))
                                (let (res_args (call type_check_list c.args context))
                                    (match res_args
                                        (case (tag "Ok" (arg_tys)) (call check_call c.name fn_ty arg_tys))
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "None") (tag "Err" (str.concat "Undefined function: " c.name)))
                        )
                    )
                )
                (case (tag "List" (l))
                    (let (res_items (call type_check_list l.items context))
                        (match res_items
                            (case (tag "Ok" (tys))
                                (let (item_ty (if (= (list.length tys) 0) 
                                                (tag "I64" (record))
                                                (list.get tys 0))) ;; Simplified item ty check
                                    (tag "Ok" (tag "List" (record (inner item_ty))))
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Tuple" (t))
                    (let (res_items (call type_check_list t.items context))
                        (match res_items
                            (case (tag "Ok" (tys)) (tag "Ok" (tag "Tuple" (record (items tys)))))
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Record" (r))
                    (let (res_fields (call type_check_fields r.fields context))
                        (match res_fields
                            (case (tag "Ok" (fields)) (tag "Ok" (tag "Record" (record (fields fields)))))
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
                (case (tag "Lambda" (l))
                    (let (res (tag "Ok" (tag "Fn" (record (args (call arg_list_to_type_list l.args)) (ret l.ret) (eff l.eff)))))
                        res
                    )
                )
            )
        )
    )

    (deffn (name get_value_type) (args (v ast.Value)) (ret ast.IrisType) (eff !Pure)
        (body
            (match v
                (case (tag "I64" (_)) (tag "I64" (record)))
                (case (tag "Bool" (_)) (tag "Bool" (record)))
                (case (tag "Str" (_)) (tag "Str" (record)))
                (case (tag "Some" (inner)) (tag "Option" (record (inner (call get_value_type inner)))))
                (case (tag "None" (_)) (tag "Option" (record (inner (tag "I64" (record)))))) ;; default
                (case (tag "Ok" (inner)) (tag "Result" (record (ok (call get_value_type inner)) (err (tag "Str" (record))))))
                (case (tag "Err" (inner)) (tag "Result" (record (ok (tag "I64" (record))) (err (call get_value_type inner)))))
                (case (tag "_") (tag "I64" (record)))
            )
        )
    )

    (deffn (name type_check_list) (args (l (List ast.Expr)) (ctx env.TypeEnv)) (ret (Result (List ast.IrisType) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (res_h (call type_check h ctx))
                        (match res_h
                            (case (tag "Ok" (ty))
                                (let (res_t (call type_check_list t ctx))
                                    (match res_t
                                        (case (tag "Ok" (tys)) (tag "Ok" (cons ty tys)))
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name type_check_fields) (args (l (List (Tuple Str ast.Expr))) (ctx env.TypeEnv)) (ret (Result (List (Tuple Str ast.IrisType)) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (name (tuple.get h 0))
                    (let (expr (tuple.get h 1))
                        (let (res_h (call type_check expr ctx))
                            (match res_h
                                (case (tag "Ok" (ty))
                                    (let (res_t (call type_check_fields t ctx))
                                        (match res_t
                                            (case (tag "Ok" (fields)) (tag "Ok" (cons (tuple name ty) fields)))
                                            (case (tag "Err" (err)) (tag "Err" err))
                                        )
                                    )
                                )
                                (case (tag "Err" (err)) (tag "Err" err))
                            )
                        )
                    ))
                )
            )
        )
    )

    (deffn (name check_intrinsic) (args (op Str) (args (List ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (if (|| (= op "+") (|| (= op "-") (|| (= op "*") (|| (= op "/") (= op "%")))))
                (tag "Ok" (tag "I64" (record)))
                (if (|| (= op ">") (|| (= op "<") (|| (= op ">=") (= op "="))))
                    (tag "Ok" (tag "Bool" (record)))
                    (tag "Err" (str.concat "Unknown intrinsic: " op))
                )
            )
        )
    )

    (deffn (name check_call) (args (name Str) (fn_ty ast.IrisType) (args (List ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match fn_ty
                (case (tag "Fn" (f))
                    ;; TODO: Check arg types equality
                    (tag "Ok" f.ret)
                )
                (case (tag "_") (tag "Err" (str.concat "Not a function: " name)))
            )
        )
    )

    (deffn (name type_check_match) (args (cases (List ast.MatchCase)) (target_ty ast.IrisType) (ctx env.TypeEnv) (first_ty (Option ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match cases
                (case (tag "nil") 
                    (match first_ty
                        (case (tag "Some" (ty)) (tag "Ok" ty))
                        (case (tag "None") (tag "Err" "Empty match"))
                    )
                )
                (case (tag "cons" (c t))
                    (let (res (call type_check c.body ctx))
                        (match res
                            (case (tag "Ok" (body_ty))
                                (match first_ty
                                    (case (tag "Some" (f))
                                        (if (call teq.type_eq body_ty f)
                                            (call type_check_match t target_ty ctx first_ty)
                                            (tag "Err" "Match cases have inconsistent types")
                                        )
                                    )
                                    (case (tag "None") (call type_check_match t target_ty ctx (tag "Some" body_ty)))
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name arg_list_to_type_list) (args (l (List ast.Arg))) (ret (List ast.IrisType)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (list))
                (case (tag "cons" (h t)) (cons h.type (call arg_list_to_type_list t)))
            )
        )
    )
  )
)
