(program
  (module (name "parser") (version 1))
  (imports
    (import "io" (as "io"))
    (import "str" (as "str"))
    (import "list" (as "list"))
  )
  (defs
    ;; --- Token Definitions (from Lexer) ---
    (type Token (Record (kind Str) (value Str)))

    ;; --- AST Type Definitions ---

    ;; Represents a runtime value (for Literal Expr)
    ;; Note: Recursive types verified in t129!
    (type Value
      (union
        (tag "I64" (I64))
        (tag "Bool" (Bool))
        (tag "Str" (Str))
        (tag "Option" ((Record (value Value)))) 
        (tag "None" ((Record))) 
        (tag "Some" (Value)) 
        (tag "Result" ((Record (isOk Bool) (value Value))))
        (tag "List" ((Record (items (List Value)))))
        (tag "Tuple" ((Record (items (List Value)))))
        (tag "Record" ((Record (fields (List (Tuple Str Value))))))
        (tag "Map" ((Record (entries (List (Tuple Str Value)))))) 
      )
    )

    (type IrisType
        (union
            (tag "I64" ((Record)))
            (tag "Bool" ((Record)))
            (tag "Str" ((Record)))
            (tag "Option" ((Record (inner IrisType))))
            (tag "Result" ((Record (ok IrisType) (err IrisType))))
            (tag "List" ((Record (inner IrisType))))
            (tag "Tuple" ((Record (items (List IrisType)))))
            (tag "Record" ((Record (fields (List (Tuple Str IrisType))))))
            (tag "Map" ((Record (key IrisType) (value IrisType))))
            (tag "Fn" ((Record (args (List IrisType)) (ret IrisType) (eff Str))))
            (tag "Named" ((Record (name Str))))
            (tag "Union" ((Record (variants (List (Tuple Str IrisType))))))
        )
    )

    (type Arg (Record (name Str) (type IrisType)))

    (type MatchCase 
        (Record 
            (tag Str) 
            (vars (List Str)) 
        )
    )

    (type Expr
      (union
        (tag "Literal" (Value))
        (tag "Var" ((Record (name Str))))
        (tag "Let" ((Record (name Str) (value Expr) (body Expr))))
        (tag "If" ((Record (cond Expr) (then Expr) (else Expr))))
        (tag "Match" ((Record (target Expr) 
                             (cases (List (Record (tag Str) (vars (List Str)) (body Expr)))))))
        (tag "Call" (Str (List Expr)))
        (tag "Intrinsic" (Str (List Expr)))
        (tag "List" ((Record (items (List Expr)) (typeArg (Option IrisType)))))
        (tag "Tuple" ((Record (items (List Expr)))))
        (tag "Lambda" ((Record (args (List Arg)) (ret IrisType) (eff Str) (body Expr))))
        (tag "Record" ((Record (fields (List (Tuple Str Expr))))))
      )
    )

    ;; --- Parser State ---
    (type Parser (Record (tokens (List Token))))

    (deffn (name parser_new) (args (tokens (List Token))) (ret Parser) (eff !Pure)
        (body (record (tokens tokens)))
    )

    (deffn (name parser_peek) (args (p Parser)) (ret Token) (eff !Pure)
        (body 
            (match p.tokens
                (case (tag "cons" (h t)) h)
                (case (tag "nil") (record (kind "EOF") (value "")))
            )
        )
    )

    (deffn (name parser_consume) (args (p Parser)) (ret Parser) (eff !Pure)
        (body 
            (match p.tokens
                (case (tag "cons" (h t)) (record (tokens t)))
                (case (tag "nil") p)
            )
        )
    )

    (deffn (name parse) (args (tokens (List Token))) (ret Expr) (eff !Pure)
      (body 
        (let (p (call parser_new tokens))
            (let (res (call parse_expr p))
                (tuple.get res 1)
            )
        )
      )
    )
    
    (deffn (name parse_expr) (args (p Parser)) (ret (Tuple Parser Expr)) (eff !Pure)
         (body 
            (let (t (call parser_peek p))
                (let (p2 (call parser_consume p))
                    (if (= t.kind "INT")
                        (tuple p2 (tag "Literal" (tag "I64" (i64.from_string t.value))))
                        (if (= t.kind "STR")
                            (tuple p2 (tag "Literal" (tag "Str" t.value)))
                            (if (= t.kind "IDENT")
                                (tuple p2 (tag "Var" (record (name t.value))))
                                (if (= t.kind "LPAREN")
                                    (call parse_compound p2)
                                    ;; Fallback
                                    (tuple p2 (tag "Literal" ((tag "I64" (999))))) 
                                )
                            )
                        )
                    )
                )
            )
         )
    )

    (deffn (name parse_compound) (args (p Parser)) (ret (Tuple Parser Expr)) (eff !Pure)
        (body
            (let (t (call parser_peek p))
                (if (|| (= t.kind "IDENT") (= t.kind "KEYWORD"))
                    (let (p2 (call parser_consume p))
                        (if (= t.value "let") (call parse_let p2)
                        (if (= t.value "if") (call parse_if p2)
                        (if (|| (= t.value "+") (|| (= t.value "-") (|| (= t.value "*") (|| (= t.value "/") (= t.value "%")))))
                            (let (res (call parse_args p2))
                                (let (p3 (tuple.get res 0))
                                (let (args (tuple.get res 1))
                                    (tuple p3 (tag "Intrinsic" (tuple t.value args)))
                                ))
                            )
                            (call parse_call p2 t.value)
                        )))
                    )
                    ;; Parsing error: Expected function name or special form after '('
                    (tuple p (tag "Literal" (tag "I64" 999)))
                )
            )
        )
    )

    (deffn (name parse_call) (args (p Parser) (name Str)) (ret (Tuple Parser Expr)) (eff !Pure)
        (body
            (let (res (call parse_args p))
                 (let (p2 (tuple.get res 0))
                 (let (args (tuple.get res 1))
                      (tuple p2 (tag "Call" (tuple name args)))
                 ))
            )
        )
    )

    (deffn (name parse_args) (args (p Parser)) (ret (Tuple Parser (List Expr))) (eff !Pure)
        (body
            (let (t (call parser_peek p))
                (if (= t.kind "RPAREN")
                    (let (p2 (call parser_consume p))
                         (tuple p2 (list))  
                    )
                    (let (res (call parse_expr p))
                         (let (p2 (tuple.get res 0))
                         (let (e (tuple.get res 1))
                         (let (res2 (call parse_args p2))
                              (let (p3 (tuple.get res2 0))
                              (let (tail (tuple.get res2 1))
                                   (tuple p3 (cons e tail)) ;; cons or list.cons? SExp intrinsics has 'cons'
                              ))
                         )))
                    )
                )
            )
        )
    )
    (deffn (name parse_let) (args (p Parser)) (ret (Tuple Parser Expr)) (eff !Pure)
        (body
            ;; (let (x VAL) BODY)
            (let (t1 (call parser_peek p))
                (if (= t1.kind "LPAREN")
                    (let (p2 (call parser_consume p))
                        (let (t_name (call parser_peek p2))
                            (if (= t_name.kind "IDENT")
                                (let (p3 (call parser_consume p2))
                                    (let (res_val (call parse_expr p3))
                                        (let (p4 (tuple.get res_val 0))
                                        (let (val (tuple.get res_val 1))
                                            (let (t2 (call parser_peek p4))
                                                (if (= t2.kind "RPAREN")
                                                    (let (p5 (call parser_consume p4))
                                                        (let (res_body (call parse_expr p5))
                                                            (let (p6 (tuple.get res_body 0))
                                                            (let (body (tuple.get res_body 1))
                                                                (let (t3 (call parser_peek p6))
                                                                    (if (= t3.kind "RPAREN")
                                                                        (tuple (call parser_consume p6) (tag "Let" (record (name t_name.value) (value val) (body body))))
                                                                        (tuple p6 (tag "Literal" (tag "I64" 999)))
                                                                    )
                                                                )
                                                            ))
                                                        )
                                                    )
                                                    (tuple p4 (tag "Literal" (tag "I64" 998)))
                                                )
                                            )
                                        ))
                                    )
                                )
                                (tuple p2 (tag "Literal" (tag "I64" 997)))
                            )
                        )
                    )
                    (tuple p (tag "Literal" (tag "I64" 996)))
                )
            )
        )
    )

    (deffn (name parse_if) (args (p Parser)) (ret (Tuple Parser Expr)) (eff !Pure)
        (body
            ;; (if COND THEN ELSE)
            (let (res_cond (call parse_expr p))
                (let (p2 (tuple.get res_cond 0))
                (let (cond (tuple.get res_cond 1))
                    (let (res_then (call parse_expr p2))
                        (let (p3 (tuple.get res_then 0))
                        (let (then_br (tuple.get res_then 1))
                            (let (res_else (call parse_expr p3))
                                (let (p4 (tuple.get res_else 0))
                                (let (else_br (tuple.get res_else 1))
                                    (let (t (call parser_peek p4))
                                        (if (= t.kind "RPAREN")
                                            (tuple (call parser_consume p4) (tag "If" (record (cond cond) (then then_br) (else else_br))))
                                            (tuple p4 (tag "Literal" (tag "I64" 995)))
                                        )
                                    )
                                ))
                            )
                        ))
                    )
                ))
            )
        )
    )
  )
)
