;; Example app: multiple Fibonacci algorithms with a simple CLI entrypoint.
;; Demonstrates recursion, iteration, memoization, and matrix exponentiation.
(program
  (module (name "fib") (version 4))
  (defs
    (type CacheEntry (Record (n I64) (val I64)))

    (deffn (name fib_recursive) (args (n I64)) (ret I64) (eff !Pure)
      (doc "Recursive Fibonacci for small values. Not optimized.")
      (body
        (if (< n 2)
            n
            (+ (fib_recursive (- n 1)) (fib_recursive (- n 2))))
      )
    )

    (deffn (name fib_iter_helper) (args (n I64) (a I64) (b I64)) (ret I64) (eff !Pure)
      (body
        (if (= n 0)
            a
            (fib_iter_helper (- n 1) b (+ a b)))
      )
    )

    (deffn (name fib_iterative) (args (n I64)) (ret I64) (eff !Pure)
      (body (fib_iter_helper n 0 1))
    )

    (deffn (name fib_fast_doubling_pair) (args (n I64)) (ret (Record (f I64) (g I64))) (eff !Pure)
      (body
        (if (= n 0)
            (record (f 0) (g 1))
            (let* ((half (/ n 2))
                   (pair (fib_fast_doubling_pair half))
                   (a (record.get pair "f"))
                   (b (record.get pair "g"))
                   (two_b_minus_a (- (* 2 b) a))
                   (c (* a two_b_minus_a))
                   (d (+ (* a a) (* b b))))
              (if (= (% n 2) 0)
                  (record (f c) (g d))
                  (record (f d) (g (+ c d)))))
        )
      )
    )

    (deffn (name fib_fast_doubling) (args (n I64)) (ret I64) (eff !Pure)
      (body (record.get (fib_fast_doubling_pair n) "f"))
    )

    (deffn (name mat_make) (args (a I64) (b I64) (c I64) (d I64)) (ret (Record (a I64) (b I64) (c I64) (d I64))) (eff !Pure)
      (body (record (a a) (b b) (c c) (d d)))
    )

    (deffn (name mat_mul)
      (args (m1 (Record (a I64) (b I64) (c I64) (d I64))) (m2 (Record (a I64) (b I64) (c I64) (d I64))))
      (ret (Record (a I64) (b I64) (c I64) (d I64)))
      (eff !Pure)
      (body
        (let* ((a (record.get m1 "a"))
               (b (record.get m1 "b"))
               (c (record.get m1 "c"))
               (d (record.get m1 "d"))
               (e (record.get m2 "a"))
               (f (record.get m2 "b"))
               (g (record.get m2 "c"))
               (h (record.get m2 "d"))
               (r00 (+ (* a e) (* b g)))
               (r01 (+ (* a f) (* b h)))
               (r10 (+ (* c e) (* d g)))
               (r11 (+ (* c f) (* d h))))
          (mat_make r00 r01 r10 r11))
      )
    )

    (deffn (name mat_pow)
      (args (m (Record (a I64) (b I64) (c I64) (d I64))) (n I64))
      (ret (Record (a I64) (b I64) (c I64) (d I64)))
      (eff !Pure)
      (body
        (if (= n 0)
            (mat_make 1 0 0 1)
            (if (= n 1)
                (mat_make (record.get m "a") (record.get m "b") (record.get m "c") (record.get m "d"))
                (if (= (% n 2) 0)
                    (let (half (mat_pow m (/ n 2)))
                      (mat_mul half half))
                    (mat_mul m (mat_pow m (- n 1))))))
      )
    )

    (deffn (name fib_matrix) (args (n I64)) (ret I64) (eff !Pure)
      (body
        (if (= n 0)
            0
            (let* ((base (mat_make 1 1 1 0))
                   (m (mat_pow base n)))
              (record.get m "b")))
      )
    )

    (deffn (name cache_get) (args (n I64) (cache (List CacheEntry))) (ret (Record (has Bool) (val I64))) (eff !Pure)
      (body (cache_get_idx n cache 0))
    )

    (deffn (name cache_get_idx)
      (args (n I64) (cache (List CacheEntry)) (idx I64))
      (ret (Record (has Bool) (val I64)))
      (eff !Pure)
      (body
        (if (>= idx (list.length cache))
            (record (has false) (val 0))
            (match (list.get cache idx)
              (case (tag "None") (record (has false) (val 0)))
              (case (tag "Some" (h))
                (let (k (record.get h "n"))
                  (if (= k n)
                      (record (has true) (val (record.get h "val")))
                      (cache_get_idx n cache (+ idx 1))))
              )
            )
        )
      )
    )

    (deffn (name cache_entry) (args (n I64) (val I64)) (ret CacheEntry) (eff !Pure)
      (body (record (n n) (val val)))
    )

    (deffn (name memo_fib)
      (args (n I64) (cache (List CacheEntry)))
      (ret (Record (value I64) (cache (List CacheEntry))))
      (eff !Pure)
      (body
        (let (hit (cache_get n cache))
          (if hit.has
              (record (value hit.val) (cache cache))
              (if (< n 2)
                    (let (entry (cache_entry n n))
                      (let (new_cache (cons entry cache))
                      (record (value n) (cache new_cache))
                    )
                  )
                  (let (res1 (memo_fib (- n 1) cache))
                    (let (a (record.get res1 "value"))
                      (let (cache1 (record.get res1 "cache"))
                        (let (res2 (memo_fib (- n 2) cache1))
                          (let (b (record.get res2 "value"))
                            (let (cache2 (record.get res2 "cache"))
                              (let (sum (+ a b))
                                (let (entry (cache_entry n sum))
                                  (let (new_cache (cons entry cache2))
                                    (record (value sum) (cache new_cache))
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
              )
          )
        )
      )
    )

    (deffn (name fib_memoized) (args (n I64)) (ret I64) (eff !Pure)
      (body
        (record.get (memo_fib n (list-of CacheEntry)) "value")
      )
    )

    (deffn (name fib_by_alg) (args (alg Str) (n I64)) (ret I64) (eff !Pure)
      (body
        (cond
          (case (str.eq alg "recursive") (fib_recursive n))
          (case (str.eq alg "iterative") (fib_iterative n))
          (case (str.eq alg "fast-doubling") (fib_fast_doubling n))
          (case (str.eq alg "matrix") (fib_matrix n))
          (case (str.eq alg "memoized") (fib_memoized n))
          (else (fib_recursive n))
        )
      )
    )

    (deffn (name pick_random_alg) (args) (ret Str) (eff !IO)
      (body
        (let* ((algs (list "recursive" "iterative" "fast-doubling" "matrix" "memoized"))
               (idx (% (rand.u64) 5))
               (choice (list.get algs idx)))
          (match choice
            (case (tag "Some" (v)) v)
            (case (tag "None") "recursive")
          )
        )
      )
    )

    (deffn (name parse_args)
      (args (args (List Str)))
      (ret (Record (n I64) (has_n Bool) (alg Str) (has_alg Bool)))
      (eff !Pure)
      (body (parse_args_rec args 0 0 false "" false))
    )

    (deffn (name parse_args_rec)
      (args (args (List Str)) (idx I64) (n I64) (has_n Bool) (alg Str) (has_alg Bool))
      (ret (Record (n I64) (has_n Bool) (alg Str) (has_alg Bool)))
      (eff !Pure)
      (body
        (match (list.get args idx)
          (case (tag "Some" (arg))
            (if (str.eq arg "--alg")
                (match (list.get args (+ idx 1))
                  (case (tag "Some" (a)) (parse_args_rec args (+ idx 2) n has_n a true))
                  (case (tag "None") (parse_args_rec args (+ idx 1) n has_n alg has_alg))
                )
                (if (str.eq arg "--help")
                    (parse_args_rec args (+ idx 1) n has_n alg has_alg)
                    (if has_n
                        (parse_args_rec args (+ idx 1) n has_n alg has_alg)
                        (parse_args_rec args (+ idx 1) (i64.from_string arg) true alg has_alg))
                )
            )
          )
          (case (tag "None") (record (n n) (has_n has_n) (alg alg) (has_alg has_alg)))
        )
      )
    )

    (deffn (name main) (args) (ret I64) (eff !IO)
      (doc "Print fib(n). Supports --alg <name>. If no alg is provided, one is chosen at random.")
      (body
        (let (args (sys.args))
          (let (parsed (parse_args args))
            (let* ((n
                     (if parsed.has_n
                         (let (_ (io.print (str.concat "Using arg for fib(" (str.concat (i64.to_string parsed.n) ")"))))
                           parsed.n)
                         (let (rand_n (+ 1 (% (rand.u64) 100)))
                           (let (_ (io.print (str.concat "Using random for fib(" (str.concat (i64.to_string rand_n) ")"))))
                             rand_n
                           )
                         )
                     ))
                   (alg
                     (if parsed.has_alg
                         parsed.alg
                         (pick_random_alg))))
              (let (_ (io.print (str.concat "Using algorithm: " alg)))
                (let (_ (io.print (str.concat "Calculating fib(" (str.concat (i64.to_string n) ")"))))
                  (let (val (fib_by_alg alg n))
                    (let (_ (io.print (i64.to_string val)))
                      val
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
