;; Compiler module: top-level parser for modules, imports, and defs.
;; Part of the Iris compiler pipeline in examples/real/compiler.
(program
  (module (name "parser_top") (version 1))
  (imports
    (import "ast" (as "ast"))
    (import "list" (as "list"))
    (import "parser_base" (as "base"))
    (import "parser_type" (as "parser_type"))
    (import "parser_expr" (as "parser_expr"))
  )
  (defs
    (deffn (name make_empty_program) (args) (ret ast.Program) (eff !Pure)
        (body (record (progMod (record (name "") (version 0))) (progImports (list)) (progDefs (list))))
    )

    (deffn (name parse_program) (args (p base.Parser)) (ret (Tuple base.Parser ast.Program)) (eff !Pure)
        (body
            (let (t (call base.parser_peek p))
                (if (= t.value "(")
                    (let* ((p2 (call base.parser_consume p))
                           (t2 (call base.parser_peek p2)))
                        (if (= t2.value "program")
                            (let* ((p3 (call base.parser_consume p2))
                                   (res_mod (call parse_module p3))
                                   (p4 (tuple.get res_mod 0))
                                   (mod (tuple.get res_mod 1))
                                   (res_imp (call parse_imports p4))
                                   (p5 (tuple.get res_imp 0))
                                   (imps (tuple.get res_imp 1))
                                   (res_defs (call parse_defs p5))
                                   (p6 (tuple.get res_defs 0))
                                   (defs (tuple.get res_defs 1))
                                   (p7 (call base.parser_consume p6))) ;; skip rparen
                                (tuple p7 (record (progMod mod) (progImports imps) (progDefs defs)))
                            )
                            (tuple p (call make_empty_program))
                        )
                    )
                    (tuple p (call make_empty_program))
                )
            )
        )
    )

    (deffn (name parse_module) (args (p base.Parser)) (ret (Tuple base.Parser ast.ModuleDecl)) (eff !Pure)
        (body
            ;; (module (name "NAME") (version VERSION))
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (p3 (call base.parser_consume p2)) ;; skip module
                   (p4 (call base.parser_consume p3)) ;; skip lparen
                   (p5 (call base.parser_consume p4)) ;; skip name
                   (t_name (call base.parser_peek p5))
                   (p6 (call base.parser_consume p5))
                   (p7 (call base.parser_consume p6)) ;; skip rparen
                   (p8 (call base.parser_consume p7)) ;; skip lparen
                   (p9 (call base.parser_consume p8)) ;; skip version
                   (t_ver (call base.parser_peek p9))
                   (p10 (call base.parser_consume p9))
                   (p11 (call base.parser_consume p10)) ;; skip rparen
                   (p12 (call base.parser_consume p11))) ;; skip rparen
                (tuple p12 (record (name t_name.value) (version (i64.from_string t_ver.value))))
            )
        )
    )

    (deffn (name parse_imports) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Import))) (eff !Pure)
        (body
            ;; (imports (import "PATH" (as "ALIAS")) ...)
            (let (t (call base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((t2 (call base.parser_peek (call base.parser_consume p))))
                        (if (= t2.value "imports")
                            (let* ((p2 (call base.parser_consume (call base.parser_consume p))) ;; skip lparen and imports
                                   (res (call parse_import_list p2))
                                   (p3 (tuple.get res 0))
                                   (imps (tuple.get res 1)))
                                (tuple (call base.parser_consume p3) imps) ;; skip rparen
                            )
                            (tuple p (list))
                        )
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_import_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Import))) (eff !Pure)
        (body
            (let (t (call base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (call parse_import p))
                           (p2 (tuple.get res 0))
                           (imp (tuple.get res 1))
                           (res2 (call parse_import_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons imp tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_import) (args (p base.Parser)) (ret (Tuple base.Parser ast.Import)) (eff !Pure)
        (body
            ;; (import "PATH" (as "ALIAS"))
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (p3 (call base.parser_consume p2)) ;; skip import
                   (t_path (call base.parser_peek p3))
                   (p4 (call base.parser_consume p3))
                   (p5 (call base.parser_consume p4)) ;; skip lparen
                   (p6 (call base.parser_consume p5)) ;; skip as
                   (t_alias (call base.parser_peek p6))
                   (p7 (call base.parser_consume p6))
                   (p8 (call base.parser_consume p7)) ;; skip rparen
                   (p9 (call base.parser_consume p8))) ;; skip rparen
                (tuple p9 (record (path t_path.value) (alias t_alias.value)))
            )
        )
    )

    (deffn (name parse_defs) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Definition))) (eff !Pure)
        (body
            ;; (defs (deffn ...) ...)
            (let (t (call base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((t2 (call base.parser_peek (call base.parser_consume p))))
                        (if (= t2.value "defs")
                            (let* ((p2 (call base.parser_consume (call base.parser_consume p))) ;; skip lparen and defs
                                   (res (call parse_def_list p2))
                                   (p3 (tuple.get res 0))
                                   (defs (tuple.get res 1)))
                                (tuple (call base.parser_consume p3) defs) ;; skip rparen
                            )
                            (tuple p (list))
                        )
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_def_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Definition))) (eff !Pure)
        (body
            (let (t (call base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (call parse_def p))
                           (p2 (tuple.get res 0))
                           (d (tuple.get res 1))
                           (res2 (call parse_def_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons d tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_def) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            (let (t (call base.parser_peek (call base.parser_consume p)))
                (cond
                    (case (|| (= t.value "deffn") (= t.value "defconst"))
                        (call parse_deffn p)
                    )
                    (case (= t.value "type")
                        (call parse_type_def p)
                    )
                    (else
                        (tuple (call base.parser_consume p) (tag "TypeDef" (record (name "") (type (tag "I64" (record))))))
                    )
                )
            )
        )
    )

    (deffn (name skip_to_rparen) (args (p base.Parser)) (ret base.Parser) (eff !Pure)
        (body
            (let (t (call base.parser_peek p))
                (if (= t.kind "RPAREN")
                    p
                    (call skip_to_rparen (call base.parser_consume p))
                )
            )
        )
    )

    (deffn (name skip_meta_form) (args (p base.Parser)) (ret base.Parser) (eff !Pure)
        (body
            ;; Assumes current token is the metadata keyword, and we're inside "(<kw> ...)".
            (let (p2 (call base.parser_consume p))
                (let (p3 (call skip_to_rparen p2))
                    (call base.parser_consume p3)
                )
            )
        )
    )

    (deffn (name parse_body_with_meta) (args (p base.Parser)) (ret (Tuple base.Parser ast.Expr)) (eff !Pure)
        (body
            ;; Handles optional (doc ...), (requires ...), (ensures ...), (caps ...) before (body ...).
            (let* ((p2 (call base.parser_consume p)) ;; consume lparen
                   (t_kw (call base.parser_peek p2)))
                (cond
                    (case (= t_kw.value "body")
                        (let* ((p3 (call base.parser_consume p2)) ;; consume body keyword
                               (res_body (call parser_expr.parse_expr p3))
                               (p4 (tuple.get res_body 0))
                               (body (tuple.get res_body 1))
                               (p5 (call base.parser_consume p4))) ;; consume rparen
                            (tuple p5 body)
                        )
                    )
                    (case (|| (= t_kw.value "doc") (|| (= t_kw.value "requires") (|| (= t_kw.value "ensures") (= t_kw.value "caps"))))
                        (call parse_body_with_meta (call skip_meta_form p2))
                    )
                    (else
                        (tuple p2 (tag "Literal" (tag "I64" 998)))
                    )
                )
            )
        )
    )

    (deffn (name parse_deffn) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            ;; (deffn (name NAME) (args ...) (ret TYPE) (eff EFF) (body EXPR))
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (p3 (call base.parser_consume p2)) ;; skip deffn
                   (p4 (call base.parser_consume p3)) ;; skip lparen
                   (p5 (call base.parser_consume p4)) ;; skip name
                   (t_name (call base.parser_peek p5))
                   (p6 (call base.parser_consume p5))
                   (p7 (call base.parser_consume p6)) ;; skip rparen
                   (res_args (call parse_args_decl p7))
                   (p8 (tuple.get res_args 0))
                   (args (tuple.get res_args 1))
                   (p9 (call base.parser_consume p8)) ;; skip lparen
                   (p10 (call base.parser_consume p9)) ;; skip ret
                   (res_ret (call parser_type.parse_type p10))
                   (p11 (tuple.get res_ret 0))
                   (ret_ty (tuple.get res_ret 1))
                   (p12 (call base.parser_consume p11)) ;; skip rparen
                   (p13 (call base.parser_consume p12)) ;; skip lparen
                   (p14 (call base.parser_consume p13)) ;; skip eff
                   (t_eff (call base.parser_peek p14))
                   (p15 (call base.parser_consume p14))
                   (p16 (call base.parser_consume p15)) ;; skip rparen
                   (res_body (call parse_body_with_meta p16))
                   (p17 (tuple.get res_body 0))
                   (body (tuple.get res_body 1))
                   (p18 (call base.parser_consume p17))) ;; skip rparen for deffn
                (tuple p18 (tag "DefFn" (record (name t_name.value) (args args) (ret ret_ty) (eff t_eff.value) (body body))))
            )
        )
    )

    (deffn (name parse_args_decl) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Arg))) (eff !Pure)
        (body
            ;; args: n t ...
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (p3 (call base.parser_consume p2)) ;; skip args
                   (res (call parse_arg_list p3))
                   (p4 (tuple.get res 0))
                   (args (tuple.get res 1)))
                (tuple (call base.parser_consume p4) args) ;; skip rparen
            )
        )
    )

    (deffn (name parse_arg_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Arg))) (eff !Pure)
        (body
            (let (t (call base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (call parse_arg_decl p))
                           (p2 (tuple.get res 0))
                           (a (tuple.get res 1))
                           (res2 (call parse_arg_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons a tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_arg_decl) (args (p base.Parser)) (ret (Tuple base.Parser ast.Arg)) (eff !Pure)
        (body
            ;; name TYPE
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (t_name (call base.parser_peek p2))
                   (p3 (call base.parser_consume p2))
                   (res_ty (call parser_type.parse_type p3))
                   (p4 (tuple.get res_ty 0))
                   (ty (tuple.get res_ty 1)))
                (tuple (call base.parser_consume p4) (record (name t_name.value) (type ty)))
            )
        )
    )

    (deffn (name parse_type_def) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            ;; type NAME TYPE
            (let* ((p2 (call base.parser_consume p)) ;; skip lparen
                   (p3 (call base.parser_consume p2)) ;; skip type
                   (t_name (call base.parser_peek p3))
                   (p4 (call base.parser_consume p3)) ;; skip NAME
                   (res_ty (call parser_type.parse_type p4))
                   (p5 (tuple.get res_ty 0))
                   (ty (tuple.get res_ty 1)))
                (tuple (call base.parser_consume p5) (tag "TypeDef" (record (name t_name.value) (type ty)))) ;; skip rparen
            )
        )
    )
  )
  )
