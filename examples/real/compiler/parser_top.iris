;; Compiler module: top-level parser for modules, imports, and defs.
;; Part of the Iris compiler pipeline in examples/real/compiler.
(program
  (module (name "parser_top") (version 1))
  (imports
    (import "ast" (as "ast"))
    (import "list" (as "list"))
    (import "parser_base" (as "base"))
    (import "parser_type" (as "parser_type"))
    (import "parser_expr" (as "parser_expr"))
  )
  (defs
    (deffn (name make_empty_program) (args) (ret ast.Program) (eff !Pure)
        (body (record (progMod (record (name "") (version 0))) (progImports (list)) (progDefs (list))))
    )

    (deffn (name parse_program) (args (p base.Parser)) (ret (Tuple base.Parser ast.Program)) (eff !Pure)
        (body
            (let* ((t (base.parser_peek p))
                   (has_lparen (= t.value "("))
                   (p2 (if has_lparen (base.parser_consume p) p))
                   (t2 (base.parser_peek p2)))
                (cond
                    (case (|| (= has_lparen false) (! (= t2.value "program")))
                        (tuple p (make_empty_program))
                    )
                    (else
                        (let* ((p3 (base.parser_consume p2))
                               (res_mod (parse_module p3))
                               (p4 (tuple.get res_mod 0))
                               (mod (tuple.get res_mod 1))
                               (res_imp (parse_imports p4))
                               (p5 (tuple.get res_imp 0))
                               (imps (tuple.get res_imp 1))
                               (res_defs (parse_defs p5))
                               (p6 (tuple.get res_defs 0))
                               (defs (tuple.get res_defs 1))
                               (p7 (base.parser_consume p6))) ;; skip rparen
                            (tuple p7 (record (progMod mod) (progImports imps) (progDefs defs)))
                        )
                    )
                )
            )
        )
    )

    (deffn (name parse_module) (args (p base.Parser)) (ret (Tuple base.Parser ast.ModuleDecl)) (eff !Pure)
        (body
            ;; (module (name "NAME") (version VERSION))
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (p3 (base.parser_consume p2)) ;; skip module
                   (p4 (base.parser_consume p3)) ;; skip lparen
                   (p5 (base.parser_consume p4)) ;; skip name
                   (t_name (base.parser_peek p5))
                   (p6 (base.parser_consume p5))
                   (p7 (base.parser_consume p6)) ;; skip rparen
                   (p8 (base.parser_consume p7)) ;; skip lparen
                   (p9 (base.parser_consume p8)) ;; skip version
                   (t_ver (base.parser_peek p9))
                   (p10 (base.parser_consume p9))
                   (p11 (base.parser_consume p10)) ;; skip rparen
                   (p12 (base.parser_consume p11))) ;; skip rparen
                (tuple p12 (record (name t_name.value) (version (i64.from_string t_ver.value))))
            )
        )
    )

    (deffn (name parse_imports) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Import))) (eff !Pure)
        (body
            ;; (imports (import "PATH" (as "ALIAS")) ...)
            (let* ((t (base.parser_peek p))
                   (is_lparen (= t.kind "LPAREN"))
                   (p2 (if is_lparen (base.parser_consume p) p))
                   (t2 (base.parser_peek p2)))
                (cond
                    (case (|| (= is_lparen false) (! (= t2.value "imports")))
                        (tuple p (list))
                    )
                    (else
                        (let* ((p3 (base.parser_consume p2)) ;; skip imports
                               (res (parse_import_list p3))
                               (p4 (tuple.get res 0))
                               (imps (tuple.get res 1)))
                            (tuple (base.parser_consume p4) imps) ;; skip rparen
                        )
                    )
                )
            )
        )
    )

    (deffn (name parse_import_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Import))) (eff !Pure)
        (body
            (let (t (base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (parse_import p))
                           (p2 (tuple.get res 0))
                           (imp (tuple.get res 1))
                           (res2 (parse_import_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons imp tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_import) (args (p base.Parser)) (ret (Tuple base.Parser ast.Import)) (eff !Pure)
        (body
            ;; (import "PATH" (as "ALIAS"))
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (p3 (base.parser_consume p2)) ;; skip import
                   (t_path (base.parser_peek p3))
                   (p4 (base.parser_consume p3))
                   (p5 (base.parser_consume p4)) ;; skip lparen
                   (p6 (base.parser_consume p5)) ;; skip as
                   (t_alias (base.parser_peek p6))
                   (p7 (base.parser_consume p6))
                   (p8 (base.parser_consume p7)) ;; skip rparen
                   (p9 (base.parser_consume p8))) ;; skip rparen
                (tuple p9 (record (path t_path.value) (alias t_alias.value)))
            )
        )
    )

    (deffn (name parse_defs) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Definition))) (eff !Pure)
        (body
            ;; (defs (deffn ...) ...)
            (let* ((t (base.parser_peek p))
                   (is_lparen (= t.kind "LPAREN"))
                   (p2 (if is_lparen (base.parser_consume p) p))
                   (t2 (base.parser_peek p2)))
                (cond
                    (case (|| (= is_lparen false) (! (= t2.value "defs")))
                        (tuple p (list))
                    )
                    (else
                        (let* ((p3 (base.parser_consume p2)) ;; skip defs
                               (res (parse_def_list p3))
                               (p4 (tuple.get res 0))
                               (defs (tuple.get res 1)))
                            (tuple (base.parser_consume p4) defs) ;; skip rparen
                        )
                    )
                )
            )
        )
    )

    (deffn (name parse_def_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Definition))) (eff !Pure)
        (body
            (let (t (base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (parse_def p))
                           (p2 (tuple.get res 0))
                           (d (tuple.get res 1))
                           (res2 (parse_def_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons d tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_def) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            (let (t (base.parser_peek (base.parser_consume p)))
                (cond
                    (case (|| (= t.value "deffn") (= t.value "defconst"))
                        (parse_deffn p)
                    )
                    (case (= t.value "type")
                        (parse_type_def p)
                    )
                    (else
                        (tuple (base.parser_consume p) (tag "TypeDef" (record (name "") (type (tag "I64" (record))))))
                    )
                )
            )
        )
    )

    (deffn (name skip_to_rparen) (args (p base.Parser)) (ret base.Parser) (eff !Pure)
        (body
            (let (t (base.parser_peek p))
                (if (= t.kind "RPAREN")
                    p
                    (skip_to_rparen (base.parser_consume p))
                )
            )
        )
    )

    (deffn (name skip_meta_form) (args (p base.Parser)) (ret base.Parser) (eff !Pure)
        (body
            ;; Assumes current token is the metadata keyword, and we're inside "(<kw> ...)".
            (let (p2 (base.parser_consume p))
                (let (p3 (skip_to_rparen p2))
                    (base.parser_consume p3)
                )
            )
        )
    )

    (deffn (name parse_body_with_meta) (args (p base.Parser)) (ret (Tuple base.Parser ast.Expr)) (eff !Pure)
        (body
            ;; Handles optional (doc ...), (requires ...), (ensures ...), (caps ...) before (body ...).
            (let* ((p2 (base.parser_consume p)) ;; consume lparen
                   (t_kw (base.parser_peek p2)))
                (cond
                    (case (= t_kw.value "body")
                        (let* ((p3 (base.parser_consume p2)) ;; consume body keyword
                               (res_body (parser_expr.parse_expr p3))
                               (p4 (tuple.get res_body 0))
                               (body (tuple.get res_body 1))
                               (p5 (base.parser_consume p4))) ;; consume rparen
                            (tuple p5 body)
                        )
                    )
                    (case (|| (= t_kw.value "doc") (|| (= t_kw.value "requires") (|| (= t_kw.value "ensures") (= t_kw.value "caps"))))
                        (parse_body_with_meta (skip_meta_form p2))
                    )
                    (else
                        (tuple p2 (tag "Literal" (tag "I64" 998)))
                    )
                )
            )
        )
    )

    (deffn (name parse_deffn) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            ;; (deffn (name NAME) (args ...) (ret TYPE) (eff EFF) (body EXPR))
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (p3 (base.parser_consume p2)) ;; skip deffn
                   (p4 (base.parser_consume p3)) ;; skip lparen
                   (p5 (base.parser_consume p4)) ;; skip name
                   (t_name (base.parser_peek p5))
                   (p6 (base.parser_consume p5))
                   (p7 (base.parser_consume p6)) ;; skip rparen
                   (res_args (parse_args_decl p7))
                   (p8 (tuple.get res_args 0))
                   (args (tuple.get res_args 1))
                   (p9 (base.parser_consume p8)) ;; skip lparen
                   (p10 (base.parser_consume p9)) ;; skip ret
                   (res_ret (parser_type.parse_type p10))
                   (p11 (tuple.get res_ret 0))
                   (ret_ty (tuple.get res_ret 1))
                   (p12 (base.parser_consume p11)) ;; skip rparen
                   (p13 (base.parser_consume p12)) ;; skip lparen
                   (p14 (base.parser_consume p13)) ;; skip eff
                   (t_eff (base.parser_peek p14))
                   (p15 (base.parser_consume p14))
                   (p16 (base.parser_consume p15)) ;; skip rparen
                   (res_body (parse_body_with_meta p16))
                   (p17 (tuple.get res_body 0))
                   (body (tuple.get res_body 1))
                   (p18 (base.parser_consume p17))) ;; skip rparen for deffn
                (tuple p18 (tag "DefFn" (record (name t_name.value) (args args) (ret ret_ty) (eff t_eff.value) (body body))))
            )
        )
    )

    (deffn (name parse_args_decl) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Arg))) (eff !Pure)
        (body
            ;; args: n t ...
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (p3 (base.parser_consume p2)) ;; skip args
                   (res (parse_arg_list p3))
                   (p4 (tuple.get res 0))
                   (args (tuple.get res 1)))
                (tuple (base.parser_consume p4) args) ;; skip rparen
            )
        )
    )

    (deffn (name parse_arg_list) (args (p base.Parser)) (ret (Tuple base.Parser (List ast.Arg))) (eff !Pure)
        (body
            (let (t (base.parser_peek p))
                (if (= t.kind "LPAREN")
                    (let* ((res (parse_arg_decl p))
                           (p2 (tuple.get res 0))
                           (a (tuple.get res 1))
                           (res2 (parse_arg_list p2))
                           (p3 (tuple.get res2 0))
                           (tail (tuple.get res2 1)))
                        (tuple p3 (cons a tail))
                    )
                    (tuple p (list))
                )
            )
        )
    )

    (deffn (name parse_arg_decl) (args (p base.Parser)) (ret (Tuple base.Parser ast.Arg)) (eff !Pure)
        (body
            ;; name TYPE
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (t_name (base.parser_peek p2))
                   (p3 (base.parser_consume p2))
                   (res_ty (parser_type.parse_type p3))
                   (p4 (tuple.get res_ty 0))
                   (ty (tuple.get res_ty 1)))
                (tuple (base.parser_consume p4) (record (name t_name.value) (type ty)))
            )
        )
    )

    (deffn (name parse_type_def) (args (p base.Parser)) (ret (Tuple base.Parser ast.Definition)) (eff !Pure)
        (body
            ;; type NAME TYPE
            (let* ((p2 (base.parser_consume p)) ;; skip lparen
                   (p3 (base.parser_consume p2)) ;; skip type
                   (t_name (base.parser_peek p3))
                   (p4 (base.parser_consume p3)) ;; skip NAME
                   (res_ty (parser_type.parse_type p4))
                   (p5 (tuple.get res_ty 0))
                   (ty (tuple.get res_ty 1)))
                (tuple (base.parser_consume p5) (tag "TypeDef" (record (name t_name.value) (type ty)))) ;; skip rparen
            )
        )
    )
  )
  )
