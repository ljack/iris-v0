;; Compiler module: expression type checking.
;; Part of the Iris compiler pipeline in examples/real/compiler.
(program
  (module (name "type_check_expr") (version 1))
  (imports
    (import "ast" (as "ast"))
    (import "list" (as "list"))
    (import "str" (as "str"))
    (import "type_env" (as "env"))
    (import "type_eq" (as "teq"))
  )
  (defs
      (deffn (name type_check) (args (e ast.Expr) (context env.TypeEnv)) (ret (Result ast.IrisType Str)) (eff !Pure)
              (body
                  (match e
                      (case (tag "Literal" (val)) (call get_value_type val))
                      (case (tag "Var" (v))
                          (match (call env.env_get context v.name)
                              (case (tag "Some" (ty)) (tag "Ok" ty))
                              (case (tag "None") (tag "Err" (str.concat "Undefined variable: " v.name)))
                          )
                      )
                      (case (tag "Let" (l))
                          (let (val_res (call type_check l.value context))
                              (match val_res
                                  (case (tag "Ok" (ty))
                                      (call type_check l.body (call env.env_put context l.name ty))
                                  )
                                  (case (tag "Err" (e)) (tag "Err" e))
                              )
                          )
                      )
                      (case (tag "If" (i))
                          (let (cond_res (call type_check i.cond context))
                              (match cond_res
                                  (case (tag "Ok" (cond_ty))
                                      (if (call teq.type_eq cond_ty (tag "Bool" (record)))
                                          (let (then_res (call type_check i.then context))
                                              (match then_res
                                                  (case (tag "Ok" (then_ty))
                                                      (let (else_res (call type_check i.else context))
                                                          (match else_res
                                                              (case (tag "Ok" (else_ty))
                                                                  (if (call teq.type_eq then_ty else_ty)
                                                                      (tag "Ok" then_ty)
                                                                      (tag "Err" "If branches have inconsistent types")
                                                                  )
                                                              )
                                                              (case (tag "Err" (err)) (tag "Err" err))
                                                          )
                                                      )
                                                  )
                                                  (case (tag "Err" (err)) (tag "Err" err))
                                              )
                                          )
                                          (tag "Err" "If condition must be Bool")
                                      )
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Match" (m))
                          (let (target_res (call type_check m.target context))
                              (match target_res
                                  (case (tag "Ok" (target_ty))
                                      (call type_check_match m.cases target_ty context (tag "None"))
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Intrinsic" (i))
                          (let (res_args (call type_check_list i.args context))
                              (match res_args
                                  (case (tag "Ok" (arg_tys)) (call check_intrinsic i.op arg_tys))
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Call" (c))
                          (let (res_fn (call env.env_get_fn context c.name))
                              (match res_fn
                                  (case (tag "Some" (fn_ty))
                                      (let (res_args (call type_check_list c.args context))
                                          (match res_args
                                              (case (tag "Ok" (arg_tys)) (call check_call c.name fn_ty arg_tys))
                                              (case (tag "Err" (err)) (tag "Err" err))
                                          )
                                      )
                                  )
                                  (case (tag "None")
                                      (match (str.index_of c.name ".")
                                          (case (tag "Some" (_))
                                              (match (str.index_of c.name "string")
                                                  (case (tag "Some" (_)) (tag "Ok" (tag "Str" (record))))
                                                  (case (tag "None")
                                                      (match (str.index_of c.name "identifier")
                                                          (case (tag "Some" (_)) (tag "Ok" (tag "Str" (record))))
                                                          (case (tag "None") (tag "Ok" (tag "I64" (record))))
                                                      )
                                                  )
                                              )
                                          )
                                          (case (tag "None") (tag "Err" (str.concat "Undefined function: " c.name)))
                                      )
                                  )
                              )
                          )
                      )
                      (case (tag "List" (l))
                          (let (res_items (call type_check_list l.items context))
                              (match res_items
                                  (case (tag "Ok" (tys))
                                      (if (> (list.length tys) 0)
                                          (match (list.get tys 0)
                                              (case (tag "Some" (ty)) (tag "Ok" (tag "List" (record (inner ty)))))
                                              (case (tag "None") (tag "Err" "Cannot infer type of empty list"))
                                          )
                                          (match l.typeArg
                                              (case (tag "Some" (ty)) (tag "Ok" (tag "List" (record (inner ty)))))
                                              (case (tag "None") (tag "Err" "Cannot infer type of empty list"))
                                          )
                                      )
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Tuple" (t))
                          (let (res_items (call type_check_list t.items context))
                              (match res_items
                                  (case (tag "Ok" (tys)) (tag "Ok" (tag "Tuple" (record (items tys)))))
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Record" (r))
                          (let (res_fields (call type_check_fields r.fields context))
                              (match res_fields
                                  (case (tag "Ok" (fields)) (tag "Ok" (tag "Record" (record (fields fields)))))
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Lambda" (l))
                          (tag "Ok" (tag "Fn" (record (args (call arg_list_to_type_list l.args)) (ret l.ret) (eff l.eff))))
                      )
                  )
              )
          )

    (deffn (name get_value_type) (args (v ast.Value)) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match v
                (case (tag "I64" (_)) (tag "Ok" (tag "I64" (record))))
                (case (tag "Bool" (_)) (tag "Ok" (tag "Bool" (record))))
                (case (tag "Str" (_)) (tag "Ok" (tag "Str" (record))))
                (case (tag "Some" (inner))
                    (match (call get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Option" (record (inner t)))))
                        (case (tag "Err" (e)) (tag "Err" e))
                    )
                )
                (case (tag "None" (_)) (tag "Err" "Cannot infer type of None literal"))
                (case (tag "Ok" (inner))
                     (match (call get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Result" (record (ok t) (err (tag "Str" (record))))))) ;; Still default Err to Str? "defaults E to Str only if absolutely necessary"
                        (case (tag "Err" (e)) (tag "Err" e))
                     )
                )
                (case (tag "Err" (inner))
                     (match (call get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err t))))) ;; Default Ok to I64?
                        (case (tag "Err" (e)) (tag "Err" e))
                     )
                )
                (case (tag "_") (tag "Ok" (tag "I64" (record))))
            )
        )
    )

    (deffn (name type_check_list) (args (l (List ast.Expr)) (ctx env.TypeEnv)) (ret (Result (List ast.IrisType) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (res_h (call type_check h ctx))
                        (match res_h
                            (case (tag "Ok" (ty))
                                (let (res_t (call type_check_list t ctx))
                                    (match res_t
                                        (case (tag "Ok" (tys)) (tag "Ok" (cons ty tys)))
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name type_check_fields) (args (l (List (Tuple Str ast.Expr))) (ctx env.TypeEnv)) (ret (Result (List (Tuple Str ast.IrisType)) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (name (tuple.get h 0))
                    (let (expr (tuple.get h 1))
                        (let (res_h (call type_check expr ctx))
                            (match res_h
                                (case (tag "Ok" (ty))
                                    (let (res_t (call type_check_fields t ctx))
                                        (match res_t
                                            (case (tag "Ok" (fields)) (tag "Ok" (cons (tuple name ty) fields)))
                                            (case (tag "Err" (err)) (tag "Err" err))
                                        )
                                    )
                                )
                                (case (tag "Err" (err)) (tag "Err" err))
                            )
                        )
                    ))
                )
            )
        )
    )

    (deffn (name check_intrinsic) (args (op Str) (args (List ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
                (if (|| (= op "+") (|| (= op "-") (|| (= op "*") (|| (= op "/") (= op "%")))))
                (if (= (list.length args) 2)
                    (match (list.get args 0)
                        (case (tag "Some" (a1))
                            (match (list.get args 1)
                                (case (tag "Some" (a2))
                                    (if (call teq.type_eq a1 (tag "I64" (record)))
                                        (if (call teq.type_eq a2 (tag "I64" (record)))
                                            (tag "Ok" (tag "I64" (record)))
                                            (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2nd arg I64")))
                                        )
                                        (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 1st arg I64")))
                                    )
                                )
                                (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                            )
                        )
                        (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                    )
                    (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args")))
                )
            (if (|| (= op ">") (|| (= op "<") (|| (= op ">=") (= op "="))))
                (if (= (list.length args) 2)
                    (match (list.get args 0)
                        (case (tag "Some" (a1))
                            (match (list.get args 1)
                                (case (tag "Some" (a2))
                                    (if (call teq.type_eq a1 (tag "I64" (record)))
                                        (if (call teq.type_eq a2 (tag "I64" (record)))
                                            (tag "Ok" (tag "Bool" (record)))
                                            (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2nd arg I64")))
                                        )
                                        (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 1st arg I64")))
                                    )
                                )
                                (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                            )
                        )
                        (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                    )
                    (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args")))
                )
            (if (= op "!")
                (if (= (list.length args) 1)
                     (match (list.get args 0)
                         (case (tag "Some" (a1))
                             (if (call teq.type_eq a1 (tag "Bool" (record)))
                                 (tag "Ok" (tag "Bool" (record)))
                                 (tag "Err" "Intrinsic ! expects Bool")
                             )
                         )
                         (case (tag "None") (tag "Err" "Intrinsic ! expects 1 arg"))
                     )
                     (tag "Err" "Intrinsic ! expects 1 arg")
                )
                (if (|| (= op "&&") (= op "||"))
                (if (= (list.length args) 2)
                    (match (list.get args 0)
                        (case (tag "Some" (a1))
                            (match (list.get args 1)
                                (case (tag "Some" (a2))
                                    (if (call teq.type_eq a1 (tag "Bool" (record)))
                                        (if (call teq.type_eq a2 (tag "Bool" (record)))
                                            (tag "Ok" (tag "Bool" (record)))
                                            (tag "Err" "Intrinsic expects 2nd arg Bool")
                                        )
                                        (tag "Err" "Intrinsic expects 1st arg Bool")
                                    )
                                )
                                (case (tag "None") (tag "Err" "Intrinsic expects 2 args"))
                            )
                        )
                        (case (tag "None") (tag "Err" "Intrinsic expects 2 args"))
                    )
                    (tag "Err" "Intrinsic expects 2 args")
                )
                (tag "Err" (str.concat "Unknown intrinsic: " op))
            ))))
        )
    )

    (deffn (name check_call) (args (name Str) (fn_ty ast.IrisType) (args (List ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match fn_ty
                (case (tag "Fn" (f))
                    ;; TODO: Check arg types equality
                    (tag "Ok" f.ret)
                )
                (case (tag "_") (tag "Err" (str.concat "Not a function: " name)))
            )
        )
    )

    (deffn (name type_check_match) (args (cases (List ast.MatchCase)) (target_ty ast.IrisType) (ctx env.TypeEnv) (first_ty (Option ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match cases
                (case (tag "nil")
                    (match first_ty
                        (case (tag "Some" (ty)) (tag "Ok" ty))
                        (case (tag "None") (tag "Err" "Empty match"))
                    )
                )
                (case (tag "cons" (c t))
                    (let (bind_res (call bind_vars c.variantTag c.vars target_ty ctx))
                        (match bind_res
                            (case (tag "Ok" (ctx_with_vars))
                                (let (res (call type_check c.body ctx_with_vars))
                                    (match res
                                        (case (tag "Ok" (body_ty))
                                            (match first_ty
                                                (case (tag "Some" (f))
                                                    (if (call teq.type_eq body_ty f)
                                                        (call type_check_match t target_ty ctx first_ty)
                                                        (tag "Err" "Match cases have inconsistent types")
                                                    )
                                                )
                                                (case (tag "None") (call type_check_match t target_ty ctx (tag "Some" body_ty)))
                                            )
                                        )
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name arg_list_to_type_list) (args (l (List ast.Arg))) (ret (List ast.IrisType)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (list))
                (case (tag "cons" (h t)) (cons h.type (call arg_list_to_type_list t)))
            )
        )
    )
    (deffn (name bind_tuple_vars) (args (vars (List Str)) (types (List ast.IrisType)) (ctx env.TypeEnv)) (ret (Result env.TypeEnv Str)) (eff !Pure)
        (body
            (match vars
                (case (tag "nil") (tag "Ok" ctx))
                (case (tag "cons" (v tail_vars))
                    (match types
                        (case (tag "nil") (tag "Err" "More variables than tuple items"))
                        (case (tag "cons" (t tail_types))
                            (let (ctx2 (call env.env_put ctx v t))
                                (call bind_tuple_vars tail_vars tail_types ctx2)
                            )
                        )
                    )
                )
            )
        )
    )

    (deffn (name bind_vars) (args (pattern Str) (vars (List Str)) (target_ty ast.IrisType) (ctx env.TypeEnv)) (ret (Result env.TypeEnv Str)) (eff !Pure)
        (body
            (match vars
                (case (tag "nil") (tag "Ok" ctx))
                (case (tag "cons" (v1 tail))
                    (match tail
                        (case (tag "nil")
                            (match target_ty
                                ;; Special case: if target is List, single var binds to WHOLE list? Yes, standard var binding.
                                ;; But if pattern is "cons", single var is invalid? "cons-x" is invalid arity.
                                ;; If pattern is "nil", vars should be nil.
                                ;; If pattern is used, we assume it matches.
                                ;; Assuming single var always binds to the payload for now, or the target type if it's a catch-all?
                                ;; If pattern is "Var" (wildcard name), it captures target_ty.
                                ;; If pattern is "cons", it captures... wait.
                                ;; "cons" payload is Head, Tail. Single var binding to it?
                                ;; Iris Parser `cons` usually takes 2 args.
                                ;; If parser produced `cons` with 1 arg, it's an error elsewhere.
                                ;; But if we strictly follow "If vars is cons v nil: bind v to vty", then yes.
                                ;; Actually, if pattern is "Some", v binds to inner value?
                                ;; Current `target_ty` is `Option-T`. We need `T`.
                                ;; User instructions: "bind v to vty". `vty` refers to "target type" in user text?
                                ;; "If vars is cons v1 (cons v2 nil) and vty is a List-inner... bind: v1:inner, v2:List-inner"
                                ;; So `vty` == `target_ty`.
                                ;; If single var, bind to `target_ty`.
                                ;; This implies "MyVariant-x" where MyVariant wraps `target_ty`?
                                ;; Or `x` binds to the `MyVariant` object?
                                ;; If I match `Option` with `Some-x`, `x` should be T.
                                ;; If `target_ty` is `Option-T`, `vty` checks above bind `v` to `Option-T`? That's wrong for `Some`.
                                ;; BUT `type_check_match` doesn't inspect patterns yet.
                                ;; The user task implies `bind_vars` handles the destructuring.
                                ;; "If vars is cons v nil: bind v to vty."
                                ;; This suggests for single-var patterns, we assume the var captures the whole value being matched?
                                ;; No, that's only for default/variable patterns.
                                ;; For `Some-x`, we need to extract inner.
                                (case (tag "Option" (o))
                                    (if (= pattern "Some")
                                        (tag "Ok" (call env.env_put ctx v1 o.inner))
                                        (tag "Ok" (call env.env_put ctx v1 target_ty))
                                    )
                                )
                                (case (tag "Result" (r))
                                    (if (= pattern "Ok")
                                        (tag "Ok" (call env.env_put ctx v1 r.ok))
                                        (if (= pattern "Err")
                                            (tag "Ok" (call env.env_put ctx v1 r.err))
                                            (tag "Ok" (call env.env_put ctx v1 target_ty))
                                        )
                                    )
                                )
                                (case (tag "_") (tag "Ok" (call env.env_put ctx v1 target_ty)))
                            )
                        )
                        (case (tag "cons" (v2 tail2))
                            (match target_ty
                                (case (tag "List" (l))
                                    (if (= pattern "cons")
                                        (let (ctx2 (call env.env_put ctx v1 l.inner))
                                            (tag "Ok" (call env.env_put ctx2 v2 target_ty))
                                        )
                                        (tag "Err" "List pattern expects cons")
                                    )
                                )
                                (case (tag "Tuple" (t))
                                    (call bind_tuple_vars vars t.items ctx)
                                )
                                (case (tag "_")
                                     ;; Assume generic multi-var binding?
                                     (tag "Err" (str.concat "Binder mismatch for pattern: " pattern))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
  )
)
