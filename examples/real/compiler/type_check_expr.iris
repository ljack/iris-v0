;; Compiler module: expression type checking.
;; Part of the Iris compiler pipeline in examples/real/compiler.
(program
  (module (name "type_check_expr") (version 1))
  (imports
    (import "ast" (as "ast"))
    (import "list" (as "list"))
    (import "str" (as "str"))
    (import "type_env" (as "env"))
    (import "type_eq" (as "teq"))
  )
  (defs
      (deffn (name field_names) (args (fields (List (Tuple Str ast.IrisType)))) (ret Str) (eff !Pure)
          (body
              (match fields
                  (case (tag "nil") "")
                  (case (tag "cons" (h t))
                      (let (name (tuple.get h 0))
                          (let (rest (field_names t))
                              (if (= rest "") name (str.concat name (str.concat "," rest)))
                          )
                      )
                  )
              )
          )
      )

      (deffn (name type_label_simple) (args (t ast.IrisType)) (ret Str) (eff !Pure)
          (body
              (match t
                  (case (tag "I64" (_)) "I64")
                  (case (tag "Bool" (_)) "Bool")
                  (case (tag "Str" (_)) "Str")
                  (case (tag "Option" (_)) "Option")
                  (case (tag "Result" (_)) "Result")
                  (case (tag "List" (_)) "List")
                  (case (tag "Tuple" (_)) "Tuple")
                  (case (tag "Record" (r))
                      (str.concat "Record(" (str.concat (field_names r.fields) ")"))
                  )
                  (case (tag "Map" (_)) "Map")
                  (case (tag "Fn" (_)) "Fn")
                  (case (tag "Union" (_)) "Union")
                  (case (tag "Named" (n)) (str.concat "Named " n.name))
                  (case (tag "_") "Unknown")
              )
          )
      )

      (deffn (name type_check) (args (e ast.Expr) (context env.TypeEnv)) (ret (Result ast.IrisType Str)) (eff !Pure)
              (body
                  (match e
                      (case (tag "Literal" (val)) (get_value_type val))
                      (case (tag "Var" (v))
                          (match (env.env_get context v.name)
                              (case (tag "Some" (ty)) (tag "Ok" ty))
                              (case (tag "None") (tag "Err" (str.concat "Undefined variable: " v.name)))
                          )
                      )
                      (case (tag "Let" (l))
                          (let (val_res (type_check l.value context))
                              (match val_res
                                  (case (tag "Ok" (ty))
                                      (type_check l.body (env.env_put context l.name ty))
                                  )
                                  (case (tag "Err" (e)) (tag "Err" e))
                              )
                          )
                      )
                      (case (tag "If" (i))
                          (let (cond_res (type_check i.cond context))
                              (match cond_res
                                  (case (tag "Ok" (cond_ty))
                                      (if (teq.type_eq cond_ty (tag "Bool" (record)))
                                          (let (then_res (type_check i.then context))
                                              (match then_res
                                                  (case (tag "Ok" (then_ty))
                                                      (let (else_res (type_check i.else context))
                                                          (match else_res
                                                              (case (tag "Ok" (else_ty))
                                                                  (if (teq.type_eq then_ty else_ty)
                                                                      (tag "Ok" then_ty)
                                                                      (tag "Err"
                                                                        (str.concat
                                                                          "If branches have inconsistent types: "
                                                                          (str.concat (type_label_simple then_ty)
                                                                            (str.concat " vs " (type_label_simple else_ty)))))
                                                                  )
                                                              )
                                                              (case (tag "Err" (err)) (tag "Err" err))
                                                          )
                                                      )
                                                  )
                                                  (case (tag "Err" (err)) (tag "Err" err))
                                              )
                                          )
                                          (tag "Err" "If condition must be Bool")
                                      )
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Match" (m))
                          (let (target_res (type_check m.target context))
                              (match target_res
                                  (case (tag "Ok" (target_ty))
                                      (type_check_match m.cases (resolve_named_type target_ty context) context (tag "None"))
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Tagged" (t))
                          (let (val_res (type_check t.value context))
                              (match val_res
                                  (case (tag "Ok" (val_ty))
                                      (tag "Ok" (tag "Union" (record (variants (list (tuple t.tag val_ty))))))
                                  )
                                  (case (tag "Err" (e)) (tag "Err" e))
                              )
                          )
                      )
                      (case (tag "Intrinsic" (i))
                          (let (res_args (type_check_list i.args context))
                              (match res_args
                                  (case (tag "Ok" (arg_tys))
                                      (if (= i.op "record.get")
                                          (match (list.get i.args 1)
                                              (case (tag "Some" (field_expr))
                                                  (match (literal_str_value field_expr)
                                                      (case (tag "Some" (field_name))
                                                          (match (list.get arg_tys 0)
                                                              (case (tag "Some" (rec_ty))
                                                                  (let (resolved_rec (resolve_named_type rec_ty context))
                                                                 (match resolved_rec
                                                                     (case (tag "Record" (r))
                                                                         (match (lookup_field_type r.fields field_name)
                                                                             (case (tag "Some" (ty)) (tag "Ok" ty))
                                                                             (case (tag "None") (tag "Err" "record.get field not found"))
                                                                         )
                                                                     )
                                                                     (case (tag "Union" (u))
                                                                         (match (union_record_field_type u.variants field_name)
                                                                             (case (tag "Some" (ty)) (tag "Ok" ty))
                                                                             (case (tag "None") (tag "Ok" (tag "I64" (record))))
                                                                         )
                                                                     )
                                                                     (case (tag "_") (tag "Ok" (tag "I64" (record))))
                                                                 ))
                                                             )
                                                              (case (tag "None") (tag "Err" "record.get expects Record"))
                                                          )
                                                      )
                                                      (case (tag "None") (check_intrinsic i.op arg_tys context))
                                                  )
                                              )
                                              (case (tag "None") (check_intrinsic i.op arg_tys context))
                                          )
                                          (if (= i.op "tuple.get")
                                              (match (list.get i.args 1)
                                                  (case (tag "Some" (idx_expr))
                                                      (match (literal_i64_value idx_expr)
                                                          (case (tag "Some" (idx))
                                                              (match (list.get arg_tys 0)
                                                                  (case (tag "Some" (t0))
                                                                      (match t0
                                                                          (case (tag "Tuple" (t))
                                                                              (match (tuple_index_type t.items idx)
                                                                                  (case (tag "Some" (ty)) (tag "Ok" ty))
                                                                                  (case (tag "None") (tag "Err" "tuple.get index out of bounds"))
                                                                              )
                                                                          )
                                                                          (case (tag "_") (tag "Err" "tuple.get expects Tuple"))
                                                                      )
                                                                  )
                                                                  (case (tag "None") (tag "Err" "tuple.get expects Tuple"))
                                                              )
                                                          )
                                                          (case (tag "None") (check_intrinsic i.op arg_tys context))
                                                      )
                                                  )
                                                  (case (tag "None") (check_intrinsic i.op arg_tys context))
                                              )
                                              (check_intrinsic i.op arg_tys context)
                                          )
                                      )
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Call" (c))
                          (let (res_fn (env.env_get_fn context c.name))
                              (match res_fn
                                  (case (tag "Some" (fn_ty))
                                      (let (res_args (type_check_list c.args context))
                                          (match res_args
                                              (case (tag "Ok" (arg_tys)) (check_call c.name fn_ty arg_tys))
                                              (case (tag "Err" (err)) (tag "Err" err))
                                          )
                                      )
                                  )
                                  (case (tag "None")
                                      (if (= c.name "http.parse_request")
                                          (tag "Ok" (tag "Result" (record (ok (http_request_type)) (err (tag "Str" (record))))))
                                          (if (= c.name "http.parse_response")
                                              (tag "Ok" (tag "Result" (record (ok (http_response_type)) (err (tag "Str" (record))))))
                                              (match (str.index_of c.name ".")
                                                  (case (tag "Some" (_))
                                                      (match (str.index_of c.name "string")
                                                          (case (tag "Some" (_)) (tag "Ok" (tag "Str" (record))))
                                                          (case (tag "None")
                                                              (match (str.index_of c.name "identifier")
                                                                  (case (tag "Some" (_)) (tag "Ok" (tag "Str" (record))))
                                                                  (case (tag "None") (tag "Ok" (tag "I64" (record))))
                                                              )
                                                          )
                                                      )
                                                  )
                                                  (case (tag "None") (tag "Err" (str.concat "Undefined function: " c.name)))
                                              )
                                          )
                                      )
                                  )
                              )
                          )
                      )
                      (case (tag "List" (l))
                          (let (res_items (type_check_list l.items context))
                              (match res_items
                                  (case (tag "Ok" (tys))
                                      (if (> (list.length tys) 0)
                                          (match (list.get tys 0)
                                              (case (tag "Some" (ty)) (tag "Ok" (tag "List" (record (inner ty)))))
                                              (case (tag "None") (tag "Err" "Cannot infer type of empty list"))
                                          )
                                          (match l.typeArg
                                              (case (tag "Some" (ty)) (tag "Ok" (tag "List" (record (inner ty)))))
                                              (case (tag "None") (tag "Err" "Cannot infer type of empty list"))
                                          )
                                      )
                                  )
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Tuple" (t))
                          (let (res_items (type_check_list t.items context))
                              (match res_items
                                  (case (tag "Ok" (tys)) (tag "Ok" (tag "Tuple" (record (items tys)))))
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Record" (r))
                          (let (res_fields (type_check_fields r.fields context))
                              (match res_fields
                                  (case (tag "Ok" (fields)) (tag "Ok" (tag "Record" (record (fields fields)))))
                                  (case (tag "Err" (err)) (tag "Err" err))
                              )
                          )
                      )
                      (case (tag "Lambda" (l))
                          (tag "Ok" (tag "Fn" (record (args (arg_list_to_type_list l.args)) (ret l.ret) (eff l.eff))))
                      )
                  )
              )
          )

    (deffn (name get_value_type) (args (v ast.Value)) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match v
                (case (tag "I64" (_)) (tag "Ok" (tag "I64" (record))))
                (case (tag "Bool" (_)) (tag "Ok" (tag "Bool" (record))))
                (case (tag "Str" (_)) (tag "Ok" (tag "Str" (record))))
                (case (tag "Some" (inner))
                    (match (get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Option" (record (inner t)))))
                        (case (tag "Err" (e)) (tag "Err" e))
                    )
                )
                (case (tag "None" (_)) (tag "Err" "Cannot infer type of None literal"))
                (case (tag "Ok" (inner))
                     (match (get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Result" (record (ok t) (err (tag "Str" (record))))))) ;; Still default Err to Str? "defaults E to Str only if absolutely necessary"
                        (case (tag "Err" (e)) (tag "Err" e))
                     )
                )
                (case (tag "Err" (inner))
                     (match (get_value_type inner)
                        (case (tag "Ok" (t)) (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err t))))) ;; Default Ok to I64?
                        (case (tag "Err" (e)) (tag "Err" e))
                     )
                )
                (case (tag "_") (tag "Ok" (tag "I64" (record))))
            )
        )
    )

    (deffn (name type_check_list) (args (l (List ast.Expr)) (ctx env.TypeEnv)) (ret (Result (List ast.IrisType) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (res_h (type_check h ctx))
                        (match res_h
                            (case (tag "Ok" (ty))
                                (let (res_t (type_check_list t ctx))
                                    (match res_t
                                        (case (tag "Ok" (tys)) (tag "Ok" (cons ty tys)))
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name type_check_fields) (args (l (List (Tuple Str ast.Expr))) (ctx env.TypeEnv)) (ret (Result (List (Tuple Str ast.IrisType)) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (name (tuple.get h 0))
                    (let (expr (tuple.get h 1))
                        (let (res_h (type_check expr ctx))
                            (match res_h
                                (case (tag "Ok" (ty))
                                    (let (res_t (type_check_fields t ctx))
                                        (match res_t
                                            (case (tag "Ok" (fields)) (tag "Ok" (cons (tuple name ty) fields)))
                                            (case (tag "Err" (err)) (tag "Err" err))
                                        )
                                    )
                                )
                                (case (tag "Err" (err)) (tag "Err" err))
                            )
                        )
                    ))
                )
            )
        )
    )

    (deffn (name http_header_type) (args) (ret ast.IrisType) (eff !Pure)
        (body (tag "Record" (record (fields (list (tuple "key" (tag "Str" (record))) (tuple "val" (tag "Str" (record))))))))
    )

    (deffn (name http_request_type) (args) (ret ast.IrisType) (eff !Pure)
        (body
            (tag "Record"
                (record (fields (list
                    (tuple "method" (tag "Str" (record)))
                    (tuple "path" (tag "Str" (record)))
                    (tuple "headers" (tag "List" (record (inner (http_header_type)))))
                    (tuple "body" (tag "Str" (record)))
                )))
            )
        )
    )

    (deffn (name http_response_type) (args) (ret ast.IrisType) (eff !Pure)
        (body
            (tag "Record"
                (record (fields (list
                    (tuple "version" (tag "Str" (record)))
                    (tuple "status" (tag "I64" (record)))
                    (tuple "headers" (tag "List" (record (inner (http_header_type)))))
                    (tuple "body" (tag "Str" (record)))
                )))
            )
        )
    )

    (deffn (name literal_str_value) (args (e ast.Expr)) (ret (Option Str)) (eff !Pure)
        (body
            (match e
                (case (tag "Literal" (lit))
                    (match lit
                        (case (tag "Str" (s)) (tag "Some" s))
                        (case (tag "_") (tag "None"))
                    )
                )
                (case (tag "_") (tag "None"))
            )
        )
    )

    (deffn (name literal_i64_value) (args (e ast.Expr)) (ret (Option I64)) (eff !Pure)
        (body
            (match e
                (case (tag "Literal" (lit))
                    (match lit
                        (case (tag "I64" (v)) (tag "Some" v))
                        (case (tag "_") (tag "None"))
                    )
                )
                (case (tag "_") (tag "None"))
            )
        )
    )

    (deffn (name lookup_field_type) (args (fields (List (Tuple Str ast.IrisType))) (name Str)) (ret (Option ast.IrisType)) (eff !Pure)
        (body
            (match fields
                (case (tag "nil") (tag "None"))
                (case (tag "cons" (h t))
                    (if (= (tuple.get h 0) name)
                        (tag "Some" (tuple.get h 1))
                        (lookup_field_type t name)
                    )
                )
            )
        )
    )

    (deffn (name tuple_index_type) (args (items (List ast.IrisType)) (idx I64)) (ret (Option ast.IrisType)) (eff !Pure)
        (body
            (if (< idx 0)
                (tag "None")
                (match items
                    (case (tag "nil") (tag "None"))
                    (case (tag "cons" (h t))
                        (if (= idx 0)
                            (tag "Some" h)
                            (tuple_index_type t (- idx 1))
                        )
                    )
                )
            )
        )
    )

    (deffn (name union_record_field_type) (args (variants (List (Tuple Str ast.IrisType))) (field_name Str)) (ret (Option ast.IrisType)) (eff !Pure)
        (body
            (match variants
                (case (tag "nil") (tag "None"))
                (case (tag "cons" (h t))
                    (let (variant_ty (tuple.get h 1))
                        (match variant_ty
                            (case (tag "Record" (r))
                                (match (lookup_field_type r.fields field_name)
                                    (case (tag "Some" (ty)) (tag "Some" ty))
                                    (case (tag "None") (union_record_field_type t field_name))
                                )
                            )
                            (case (tag "_") (union_record_field_type t field_name))
                        )
                    )
                )
            )
        )
    )

    (deffn (name type_compatible) (args (a ast.IrisType) (b ast.IrisType)) (ret Bool) (eff !Pure)
        (body
            (if (teq.type_eq a b)
                true
                (match a
                    (case (tag "Union" (_))
                        (match b
                            (case (tag "Union" (_)) true)
                            (case (tag "_") false)
                        )
                    )
                    (case (tag "Option" (_))
                        (match b
                            (case (tag "Option" (_)) true)
                            (case (tag "_") false)
                        )
                    )
                    (case (tag "Result" (_))
                        (match b
                            (case (tag "Result" (_)) true)
                            (case (tag "_") false)
                        )
                    )
                    (case (tag "_") false)
                )
            )
        )
    )

    (deffn (name resolve_type_list) (args (items (List ast.IrisType)) (context env.TypeEnv) (seen (List Str))) (ret (List ast.IrisType)) (eff !Pure)
        (body
            (match items
                (case (tag "nil") (list))
                (case (tag "cons" (h t))
                    (cons (resolve_named_type_seen h context seen) (resolve_type_list t context seen))
                )
            )
        )
    )

    (deffn (name resolve_field_list) (args (fields (List (Tuple Str ast.IrisType))) (context env.TypeEnv) (seen (List Str))) (ret (List (Tuple Str ast.IrisType))) (eff !Pure)
        (body
            (match fields
                (case (tag "nil") (list))
                (case (tag "cons" (h t))
                    (let (name (tuple.get h 0))
                    (let (ty (tuple.get h 1))
                        (cons (tuple name (resolve_named_type_seen ty context seen)) (resolve_field_list t context seen))
                    ))
                )
            )
        )
    )

    (deffn (name list_contains) (args (items (List Str)) (name Str)) (ret Bool) (eff !Pure)
        (body
            (match items
                (case (tag "nil") false)
                (case (tag "cons" (h t)) (if (= h name) true (list_contains t name)))
            )
        )
    )

    (deffn (name resolve_named_type) (args (t ast.IrisType) (context env.TypeEnv)) (ret ast.IrisType) (eff !Pure)
        (body (resolve_named_type_seen t context (list)))
    )

    (deffn (name resolve_named_type_seen) (args (t ast.IrisType) (context env.TypeEnv) (seen (List Str))) (ret ast.IrisType) (eff !Pure)
        (body
            (match t
                (case (tag "Named" (n))
                    (if (list_contains seen n.name)
                        t
                        (match (env.env_get_type context n.name)
                            (case (tag "Some" (ty)) (resolve_named_type_seen ty context (cons n.name seen)))
                            (case (tag "None") t)
                        )
                    )
                )
                (case (tag "Option" (o)) (tag "Option" (record (inner (resolve_named_type_seen o.inner context seen)))))
                (case (tag "Result" (r)) (tag "Result" (record (ok (resolve_named_type_seen r.ok context seen)) (err (resolve_named_type_seen r.err context seen)))))
                (case (tag "List" (l)) (tag "List" (record (inner (resolve_named_type_seen l.inner context seen)))))
                (case (tag "Tuple" (tp)) (tag "Tuple" (record (items (resolve_type_list tp.items context seen)))))
                (case (tag "Record" (rec)) (tag "Record" (record (fields (resolve_field_list rec.fields context seen)))))
                (case (tag "Map" (m)) (tag "Map" (record (key (resolve_named_type_seen m.key context seen)) (value (resolve_named_type_seen m.value context seen)))))
                (case (tag "Fn" (f)) (tag "Fn" (record (args (resolve_type_list f.args context seen)) (ret (resolve_named_type_seen f.ret context seen)) (eff f.eff))))
                (case (tag "Union" (u)) (tag "Union" (record (variants (resolve_field_list u.variants context seen)))))
                (case (tag "_") t)
            )
        )
    )

    (deffn (name check_intrinsic) (args (op Str) (args (List ast.IrisType)) (context env.TypeEnv)) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (let (argc (list.length args))
                (cond
                    (case (|| (= op "+") (|| (= op "-") (|| (= op "*") (|| (= op "/") (= op "%")))))
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match (list.get args 1)
                                        (case (tag "Some" (a2))
                                            (if (teq.type_eq a1 (tag "I64" (record)))
                                                (if (teq.type_eq a2 (tag "I64" (record)))
                                                    (tag "Ok" (tag "I64" (record)))
                                                    (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2nd arg I64")))
                                                )
                                                (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 1st arg I64")))
                                            )
                                        )
                                        (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                                    )
                                )
                                (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                            )
                            (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args")))
                        )
                    )
                    (case (= op "=")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match (list.get args 1)
                                        (case (tag "Some" (a2))
                                            (if (teq.type_eq a1 a2)
                                                (tag "Ok" (tag "Bool" (record)))
                                                (tag "Err" "Intrinsic = expects matching arg types")
                                            )
                                        )
                                        (case (tag "None") (tag "Err" "Intrinsic = expects 2 args"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "Intrinsic = expects 2 args"))
                            )
                            (tag "Err" "Intrinsic = expects 2 args")
                        )
                    )
                    (case (|| (= op ">") (|| (= op "<") (= op ">=")))
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match (list.get args 1)
                                        (case (tag "Some" (a2))
                                            (if (teq.type_eq a1 (tag "I64" (record)))
                                                (if (teq.type_eq a2 (tag "I64" (record)))
                                                    (tag "Ok" (tag "Bool" (record)))
                                                    (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2nd arg I64")))
                                                )
                                                (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 1st arg I64")))
                                            )
                                        )
                                        (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                                    )
                                )
                                (case (tag "None") (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args"))))
                            )
                            (tag "Err" (str.concat "Intrinsic " (str.concat op " expects 2 args")))
                        )
                    )
                    (case (= op "io.print")
                        (if (= argc 1)
                            (tag "Ok" (tag "I64" (record)))
                            (tag "Err" "Intrinsic io.print expects 1 arg")
                        )
                    )
                    (case (= op "io.read_file")
                        (if (= argc 1)
                            (tag "Ok" (tag "Result" (record (ok (tag "Str" (record))) (err (tag "Str" (record))))))
                            (tag "Err" "Intrinsic io.read_file expects 1 arg")
                        )
                    )
                    (case (= op "io.write_file")
                        (if (= argc 2)
                            (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err (tag "Str" (record))))))
                            (tag "Err" "Intrinsic io.write_file expects 2 args")
                        )
                    )
                    (case (= op "io.file_exists")
                        (if (= argc 1)
                            (tag "Ok" (tag "Bool" (record)))
                            (tag "Err" "Intrinsic io.file_exists expects 1 arg")
                        )
                    )
                    (case (= op "io.read_dir")
                        (if (= argc 1)
                            (tag "Ok" (tag "Result" (record (ok (tag "List" (record (inner (tag "Str" (record)))))) (err (tag "Str" (record))))))
                            (tag "Err" "Intrinsic io.read_dir expects 1 arg")
                        )
                    )
                    (case (= op "!")
                        (if (= argc 1)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (if (teq.type_eq a1 (tag "Bool" (record)))
                                        (tag "Ok" (tag "Bool" (record)))
                                        (tag "Err" "Intrinsic ! expects Bool")
                                    )
                                )
                                (case (tag "None") (tag "Err" "Intrinsic ! expects 1 arg"))
                            )
                            (tag "Err" "Intrinsic ! expects 1 arg")
                        )
                    )
                    (case (|| (= op "&&") (= op "||"))
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match (list.get args 1)
                                        (case (tag "Some" (a2))
                                            (if (teq.type_eq a1 (tag "Bool" (record)))
                                                (if (teq.type_eq a2 (tag "Bool" (record)))
                                                    (tag "Ok" (tag "Bool" (record)))
                                                    (tag "Err" "Intrinsic expects 2nd arg Bool")
                                                )
                                                (tag "Err" "Intrinsic expects 1st arg Bool")
                                            )
                                        )
                                        (case (tag "None") (tag "Err" "Intrinsic expects 2 args"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "Intrinsic expects 2 args"))
                            )
                            (tag "Err" "Intrinsic expects 2 args")
                        )
                    )
                    (case (= op "Some")
                        (if (= argc 1)
                            (match (list.get args 0)
                                (case (tag "Some" (a1)) (tag "Ok" (tag "Option" (record (inner a1)))))
                                (case (tag "None") (tag "Err" "Some expects 1 arg"))
                            )
                            (tag "Err" "Some expects 1 arg")
                        )
                    )
                    (case (= op "Ok")
                        (if (= argc 1)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (tag "Ok" (tag "Result" (record (ok a1) (err (tag "Str" (record))))))
                                )
                                (case (tag "None") (tag "Err" "Ok expects 1 arg"))
                            )
                            (tag "Err" "Ok expects 1 arg")
                        )
                    )
                    (case (= op "Err")
                        (if (= argc 1)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (tag "Ok" (tag "Result" (record (ok (tag "Str" (record))) (err a1))))
                                )
                                (case (tag "None") (tag "Err" "Err expects 1 arg"))
                            )
                            (tag "Err" "Err expects 1 arg")
                        )
                    )
                    (case (= op "cons")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1)) (tag "Ok" (tag "List" (record (inner a1)))))
                                (case (tag "None") (tag "Err" "cons expects 2 args"))
                            )
                            (tag "Err" "cons expects 2 args")
                        )
                    )
                    (case (= op "list.length")
                        (tag "Ok" (tag "I64" (record)))
                    )
                    (case (= op "list.get")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match a1
                                        (case (tag "List" (l))
                                            (tag "Ok" (tag "Option" (record (inner l.inner))))
                                        )
                                        (case (tag "_") (tag "Err" "list.get expects List"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "list.get expects 2 args"))
                            )
                            (tag "Err" "list.get expects 2 args")
                        )
                    )
                    (case (= op "list.concat")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (a1))
                                    (match a1
                                        (case (tag "List" (l1))
                                            (match (list.get args 1)
                                                (case (tag "Some" (a2))
                                                    (match a2
                                                        (case (tag "List" (_)) (tag "Ok" (tag "List" (record (inner l1.inner)))))
                                                        (case (tag "_") (tag "Err" "list.concat expects List"))
                                                    )
                                                )
                                                (case (tag "None") (tag "Err" "list.concat expects 2 args"))
                                            )
                                        )
                                        (case (tag "_") (tag "Err" "list.concat expects List"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "list.concat expects 2 args"))
                            )
                            (tag "Err" "list.concat expects 2 args")
                        )
                    )
                    (case (= op "map.make")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (k))
                                    (match (list.get args 1)
                                        (case (tag "Some" (v))
                                            (tag "Ok" (tag "Map" (record (key k) (value v))))
                                        )
                                        (case (tag "None") (tag "Err" "map.make expects 2 args"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "map.make expects 2 args"))
                            )
                            (tag "Err" "map.make expects 2 args")
                        )
                    )
                    (case (= op "map.put")
                        (if (= argc 3)
                            (match (list.get args 0)
                                (case (tag "Some" (mty))
                                    (match mty
                                        (case (tag "Map" (m))
                                            (match (list.get args 1)
                                                (case (tag "Some" (_))
                                                    (match (list.get args 2)
                                                        (case (tag "Some" (_)) (tag "Ok" (tag "Map" (record (key m.key) (value m.value)))))
                                                        (case (tag "None") (tag "Err" "map.put expects 3 args"))
                                                    )
                                                )
                                                (case (tag "None") (tag "Err" "map.put expects 3 args"))
                                            )
                                        )
                                        (case (tag "_") (tag "Err" "map.put expects Map"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "map.put expects 3 args"))
                            )
                            (tag "Err" "map.put expects 3 args")
                        )
                    )
                    (case (= op "map.get")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (mty))
                                    (match mty
                                        (case (tag "Map" (m))
                                            (tag "Ok" (tag "Option" (record (inner (resolve_named_type m.value context)))))
                                        )
                                        (case (tag "_") (tag "Ok" (tag "Option" (record (inner (tag "I64" (record)))))))
                                    )
                                )
                                (case (tag "None") (tag "Err" "map.get expects 2 args"))
                            )
                            (tag "Err" "map.get expects 2 args")
                        )
                    )
                    (case (= op "tuple.get")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (t0))
                                    (match t0
                                        (case (tag "Tuple" (t))
                                            (match t.items
                                                (case (tag "cons" (h _)) (tag "Ok" h))
                                                (case (tag "nil") (tag "Err" "tuple.get expects non-empty tuple"))
                                            )
                                        )
                                        (case (tag "_") (tag "Err" "tuple.get expects Tuple"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "tuple.get expects 2 args"))
                            )
                            (tag "Err" "tuple.get expects 2 args")
                        )
                    )
                    (case (= op "record.get")
                        (if (= argc 2)
                            (match (list.get args 0)
                                (case (tag "Some" (rty))
                                    (match (list.get args 1)
                                        (case (tag "Some" (fty))
                                            (match rty
                                                (case (tag "Record" (r))
                                                    (match r.fields
                                                        (case (tag "cons" (h _)) (tag "Ok" (tuple.get h 1)))
                                                        (case (tag "nil") (tag "Err" "record.get expects non-empty record"))
                                                    )
                                                )
                                                (case (tag "_") (tag "Err" "record.get expects Record"))
                                            )
                                        )
                                        (case (tag "None") (tag "Err" "record.get expects 2 args"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "record.get expects 2 args"))
                            )
                            (tag "Err" "record.get expects 2 args")
                        )
                    )
                    (case (= op "record.update")
                        (if (>= argc 1)
                            (match (list.get args 0)
                                (case (tag "Some" (rty))
                                    (match rty
                                        (case (tag "Record" (_)) (tag "Ok" rty))
                                        (case (tag "_") (tag "Err" "record.update expects Record"))
                                    )
                                )
                                (case (tag "None") (tag "Err" "record.update expects Record"))
                            )
                            (tag "Err" "record.update expects Record")
                        )
                    )
                    (case (= op "str.concat")
                        (tag "Ok" (tag "Str" (record)))
                    )
                    (case (= op "str.concat_temp")
                        (tag "Ok" (tag "Str" (record)))
                    )
                    (case (= op "str.temp_reset")
                        (tag "Ok" (tag "I64" (record)))
                    )
                    (case (= op "str.eq")
                        (tag "Ok" (tag "Bool" (record)))
                    )
                    (case (= op "str.contains")
                        (tag "Ok" (tag "Bool" (record)))
                    )
                    (case (= op "str.ends_with")
                        (tag "Ok" (tag "Bool" (record)))
                    )
                    (case (= op "str.len")
                        (tag "Ok" (tag "I64" (record)))
                    )
                    (case (= op "str.index_of")
                        (tag "Ok" (tag "Option" (record (inner (tag "I64" (record))))))
                    )
                    (case (= op "str.substring")
                        (tag "Ok" (tag "Str" (record)))
                    )
                    (case (= op "i64.from_string")
                        (tag "Ok" (tag "I64" (record)))
                    )
                    (case (= op "i64.to_string")
                        (tag "Ok" (tag "Str" (record)))
                    )
                    (case (= op "rand.u64")
                        (tag "Ok" (tag "I64" (record)))
                    )
                    (case (= op "sys.args")
                        (tag "Ok" (tag "List" (record (inner (tag "Str" (record))))))
                    )
                    (case (= op "net.listen")
                        (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err (tag "Str" (record))))))
                    )
                    (case (= op "net.accept")
                        (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err (tag "Str" (record))))))
                    )
                    (case (= op "net.read")
                        (tag "Ok" (tag "Result" (record (ok (tag "Str" (record))) (err (tag "Str" (record))))))
                    )
                    (case (= op "net.write")
                        (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err (tag "Str" (record))))))
                    )
                    (case (= op "net.close")
                        (tag "Ok" (tag "Result" (record (ok (tag "Bool" (record))) (err (tag "Str" (record))))))
                    )
                    (case (= op "net.connect")
                        (tag "Ok" (tag "Result" (record (ok (tag "I64" (record))) (err (tag "Str" (record))))))
                    )
                    (else (tag "Err" (str.concat "Unknown intrinsic: " op)))
                )
            )
        )
    )

    (deffn (name check_call) (args (name Str) (fn_ty ast.IrisType) (args (List ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match fn_ty
                (case (tag "Fn" (f))
                    ;; TODO: Check arg types equality
                    (tag "Ok" f.ret)
                )
                (case (tag "_") (tag "Err" (str.concat "Not a function: " name)))
            )
        )
    )

    (deffn (name type_check_match) (args (cases (List ast.MatchCase)) (target_ty ast.IrisType) (ctx env.TypeEnv) (first_ty (Option ast.IrisType))) (ret (Result ast.IrisType Str)) (eff !Pure)
        (body
            (match cases
                (case (tag "nil")
                    (match first_ty
                        (case (tag "Some" (ty)) (tag "Ok" ty))
                        (case (tag "None") (tag "Err" "Empty match"))
                    )
                )
                (case (tag "cons" (c t))
                    (let (bind_res (bind_vars c.variantTag c.vars target_ty ctx))
                        (match bind_res
                            (case (tag "Ok" (ctx_with_vars))
                                (let (res (type_check c.body ctx_with_vars))
                                    (match res
                                        (case (tag "Ok" (body_ty))
                                            (match first_ty
                                                (case (tag "Some" (f))
                                                    (type_check_match t target_ty ctx first_ty)
                                                )
                                                (case (tag "None") (type_check_match t target_ty ctx (tag "Some" body_ty)))
                                            )
                                        )
                                        (case (tag "Err" (err)) (tag "Err" err))
                                    )
                                )
                            )
                            (case (tag "Err" (err)) (tag "Err" err))
                        )
                    )
                )
            )
        )
    )

    (deffn (name arg_list_to_type_list) (args (l (List ast.Arg))) (ret (List ast.IrisType)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (list))
                (case (tag "cons" (h t)) (cons h.type (arg_list_to_type_list t)))
            )
        )
    )
    (deffn (name bind_tuple_vars) (args (vars (List Str)) (types (List ast.IrisType)) (ctx env.TypeEnv)) (ret (Result env.TypeEnv Str)) (eff !Pure)
        (body
            (match vars
                (case (tag "nil") (tag "Ok" ctx))
                (case (tag "cons" (v tail_vars))
                    (match types
                        (case (tag "nil") (tag "Err" "More variables than tuple items"))
                        (case (tag "cons" (t tail_types))
                            (let (ctx2 (env.env_put ctx v t))
                                (bind_tuple_vars tail_vars tail_types ctx2)
                            )
                        )
                    )
                )
            )
        )
    )

    (deffn (name bind_vars) (args (pattern Str) (vars (List Str)) (target_ty ast.IrisType) (ctx env.TypeEnv)) (ret (Result env.TypeEnv Str)) (eff !Pure)
        (body
            (match vars
                (case (tag "nil") (tag "Ok" ctx))
                (case (tag "cons" (v1 tail))
                    (match tail
                        (case (tag "nil")
                            (match target_ty
                                ;; Special case: if target is List, single var binds to WHOLE list? Yes, standard var binding.
                                ;; But if pattern is "cons", single var is invalid? "cons-x" is invalid arity.
                                ;; If pattern is "nil", vars should be nil.
                                ;; If pattern is used, we assume it matches.
                                ;; Assuming single var always binds to the payload for now, or the target type if it's a catch-all?
                                ;; If pattern is "Var" (wildcard name), it captures target_ty.
                                ;; If pattern is "cons", it captures... wait.
                                ;; "cons" payload is Head, Tail. Single var binding to it?
                                ;; Iris Parser `cons` usually takes 2 args.
                                ;; If parser produced `cons` with 1 arg, it's an error elsewhere.
                                ;; But if we strictly follow "If vars is cons v nil: bind v to vty", then yes.
                                ;; Actually, if pattern is "Some", v binds to inner value?
                                ;; Current `target_ty` is `Option-T`. We need `T`.
                                ;; User instructions: "bind v to vty". `vty` refers to "target type" in user text?
                                ;; "If vars is cons v1 (cons v2 nil) and vty is a List-inner... bind: v1:inner, v2:List-inner"
                                ;; So `vty` == `target_ty`.
                                ;; If single var, bind to `target_ty`.
                                ;; This implies "MyVariant-x" where MyVariant wraps `target_ty`?
                                ;; Or `x` binds to the `MyVariant` object?
                                ;; If I match `Option` with `Some-x`, `x` should be T.
                                ;; If `target_ty` is `Option-T`, `vty` checks above bind `v` to `Option-T`? That's wrong for `Some`.
                                ;; BUT `type_check_match` doesn't inspect patterns yet.
                                ;; The user task implies `bind_vars` handles the destructuring.
                                ;; "If vars is cons v nil: bind v to vty."
                                ;; This suggests for single-var patterns, we assume the var captures the whole value being matched?
                                ;; No, that's only for default/variable patterns.
                                ;; For `Some-x`, we need to extract inner.
                                (case (tag "Option" (o))
                                    (if (= pattern "Some")
                                        (tag "Ok" (env.env_put ctx v1 o.inner))
                                        (tag "Ok" (env.env_put ctx v1 target_ty))
                                    )
                                )
                                (case (tag "Result" (r))
                                    (if (= pattern "Ok")
                                        (tag "Ok" (env.env_put ctx v1 r.ok))
                                        (if (= pattern "Err")
                                            (tag "Ok" (env.env_put ctx v1 r.err))
                                            (tag "Ok" (env.env_put ctx v1 target_ty))
                                        )
                                    )
                                )
                                (case (tag "Union" (u))
                                    (match (lookup_field_type u.variants pattern)
                                        (case (tag "Some" (vty)) (tag "Ok" (env.env_put ctx v1 vty)))
                                        (case (tag "None") (tag "Ok" (env.env_put ctx v1 target_ty)))
                                    )
                                )
                                (case (tag "_") (tag "Ok" (env.env_put ctx v1 target_ty)))
                            )
                        )
                        (case (tag "cons" (v2 tail2))
                            (match target_ty
                                (case (tag "List" (l))
                                    (if (= pattern "cons")
                                        (let (ctx2 (env.env_put ctx v1 l.inner))
                                            (tag "Ok" (env.env_put ctx2 v2 target_ty))
                                        )
                                        (tag "Err" "List pattern expects cons")
                                    )
                                )
                                (case (tag "Tuple" (t))
                                    (bind_tuple_vars vars t.items ctx)
                                )
                                (case (tag "_")
                                     ;; Assume generic multi-var binding?
                                     (tag "Err" (str.concat "Binder mismatch for pattern: " pattern))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
  )
)
