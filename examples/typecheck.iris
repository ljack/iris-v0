(program
  (module (name "typecheck") (version 1))
  (imports
    (import "list" (as "list"))
    (import "map" (as "map"))
    (import "str" (as "str"))
  )
  (defs
    ;; --- AST Definitions (Mirrors parser.iris) ---

    (type Value
      (union
        (tag "I64" (I64))
        (tag "Bool" (Bool))
        (tag "Str" (Str))
        (tag "Option" ((Record (value Value)))) 
        (tag "None" ((Record))) 
        (tag "Some" (Value)) 
        (tag "Result" ((Record (isOk Bool) (value Value))))
        (tag "List" ((Record (items (List Value)))))
        (tag "Tuple" ((Record (items (List Value)))))
        (tag "Record" ((Record (fields (List (Tuple Str Value))))))
        (tag "Map" ((Record (entries (List (Tuple Str Value)))))) 
      )
    )

    (type IrisType
        (union
            (tag "I64" ((Record)))
            (tag "Bool" ((Record)))
            (tag "Str" ((Record)))
            (tag "Option" ((Record (inner IrisType))))
            (tag "Result" ((Record (ok IrisType) (err IrisType))))
            (tag "List" ((Record (inner IrisType))))
            (tag "Tuple" ((Record (items (List IrisType)))))
            (tag "Record" ((Record (fields (List (Tuple Str IrisType))))))
            (tag "Map" ((Record (key IrisType) (value IrisType))))
            (tag "Fn" ((Record (args (List IrisType)) (ret IrisType) (eff Str))))
            (tag "Named" ((Record (name Str))))
            (tag "Union" ((Record (variants (List (Tuple Str IrisType))))))
            (tag "Unit" ((Record))) ;; For convenience if needed, though usually empty Tuple
            (tag "Error" ((Record (msg Str)))) ;; Internal use for errors? Or use Result?
        )
    )

    (type Arg (Record (name Str) (type IrisType)))

    (type Expr
      (union
        (tag "Literal" (Value))
        (tag "Var" ((Record (name Str))))
        (tag "Let" ((Record (name Str) (value Expr) (body Expr))))
        (tag "If" ((Record (cond Expr) (then Expr) (else Expr))))
        (tag "Match" ((Record (target Expr) 
                             (cases (List (Record (tag Str) (vars (List Str)) (body Expr)))))))
        (tag "Call" (Str (List Expr)))
        (tag "Intrinsic" (Str (List Expr)))
        (tag "List" ((Record (items (List Expr)) (typeArg (Option IrisType)))))
        (tag "Tuple" ((Record (items (List Expr)))))
        (tag "Lambda" ((Record (args (List Arg)) (ret IrisType) (eff Str) (body Expr))))
        (tag "Record" ((Record (fields (List (Tuple Str Expr))))))
      )
    )

    ;; --- Type Checker ---

    ;; Type Environment: Map from Name to IrisType
    (type TypeEnv (Record (bindings (Map Str IrisType)) (functions (Map Str IrisType))))

    (deffn (name env_new) (args) (ret TypeEnv) (eff !Pure)
        (body (record (bindings (map.make "k" (tag "I64" (record)))) (functions (map.make "k" (tag "I64" (record))))))
    )

    (deffn (name env_get) (args (env TypeEnv) (key Str)) (ret (Option IrisType)) (eff !Pure)
        (body (map.get env.bindings key))
    )

    (deffn (name env_get_fn) (args (env TypeEnv) (key Str)) (ret (Option IrisType)) (eff !Pure)
        (body (map.get env.functions key))
    )

    (deffn (name env_put) (args (env TypeEnv) (key Str) (t IrisType)) (ret TypeEnv) (eff !Pure)
        (body (record (bindings (map.put env.bindings key t)) (functions env.functions)))
    )

    (deffn (name env_put_fn) (args (env TypeEnv) (key Str) (t IrisType)) (ret TypeEnv) (eff !Pure)
        (body (record (bindings env.bindings) (functions (map.put env.functions key t))))
    )

    ;; Helper: Compare two types for equality
    (deffn (name type_eq) (args (t1 IrisType) (t2 IrisType)) (ret Bool) (eff !Pure)
        (body
            (match t1
                (case (tag "I64" (_)) (match t2 (case (tag "I64" (_)) true) (case (tag "Bool" (_)) false) (case (tag "Str" (_)) false) (case (tag "Unit" (_)) false) (case (tag "Error" (_)) false) (case (tag "Option" (_)) false) (case (tag "Result" (_)) false) (case (tag "List" (_)) false) (case (tag "Tuple" (_)) false) (case (tag "Record" (_)) false) (case (tag "Map" (_)) false) (case (tag "Fn" (_)) false) (case (tag "Named" (_)) false) (case (tag "Union" (_)) false)))
                (case (tag "Bool" (_)) (match t2 (case (tag "Bool" (_)) true) (case (tag "I64" (_)) false) (case (tag "Str" (_)) false) (case (tag "Unit" (_)) false) (case (tag "Error" (_)) false) (case (tag "Option" (_)) false) (case (tag "Result" (_)) false) (case (tag "List" (_)) false) (case (tag "Tuple" (_)) false) (case (tag "Record" (_)) false) (case (tag "Map" (_)) false) (case (tag "Fn" (_)) false) (case (tag "Named" (_)) false) (case (tag "Union" (_)) false)))
                (case (tag "Str" (_)) (match t2 (case (tag "Str" (_)) true) (case (tag "I64" (_)) false) (case (tag "Bool" (_)) false) (case (tag "Unit" (_)) false) (case (tag "Error" (_)) false) (case (tag "Option" (_)) false) (case (tag "Result" (_)) false) (case (tag "List" (_)) false) (case (tag "Tuple" (_)) false) (case (tag "Record" (_)) false) (case (tag "Map" (_)) false) (case (tag "Fn" (_)) false) (case (tag "Named" (_)) false) (case (tag "Union" (_)) false)))
                ;; Incomplete for complex types, but enough for basic primitives now
                (case (tag "Option" (_)) false) 
                (case (tag "Result" (_)) false)
                (case (tag "List" (_)) false)
                (case (tag "Tuple" (_)) false)
                (case (tag "Record" (_)) false)
                (case (tag "Map" (_)) false)
                (case (tag "Fn" (_)) false)
                (case (tag "Named" (_)) false)
                (case (tag "Union" (_)) false)
                (case (tag "Unit" (_)) false) ;; Actually should match Unit
                (case (tag "Error" (_)) false)
            )
        )
    )

    (deffn (name type_check) (args (e Expr) (env TypeEnv)) (ret (Result IrisType Str)) (eff !Pure)
        (body
            (match e
                (case (tag "Literal" (v))
                    (tag "Ok" (match v
                        (case (tag "I64" (_)) (tag "I64" (record)))
                        (case (tag "Bool" (_)) (tag "Bool" (record)))
                        (case (tag "Str" (_)) (tag "Str" (record)))
                        (case (tag "None" (_)) (tag "Option" (record (inner (tag "I64" (record)))))) ;; Ambiguous?
                         ;; ... other literals
                        (case (tag "Option" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                        (case (tag "Some" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                        (case (tag "Result" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                        (case (tag "List" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                        (case (tag "Tuple" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                        (case (tag "Record" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                                                (case (tag "Map" (_)) (tag "Error" (record (msg "Literal decoding incomplete"))))
                    ))
                )
                (case (tag "Var" (v))
                    (let (found (env_get env v.name))
                        (match found
                            (case (tag "Some" (t)) (tag "Ok" t))
                            (case (tag "None") (tag "Err" (str.concat "Undefined variable: " v.name)))
                        )
                    )
                )
                (case (tag "Let" (l))
                   (let (val_res (type_check l.value env))
                       (match val_res
                           (case (tag "Ok" (val_ty))
                               (let (new_env (env_put env l.name val_ty))
                                   (type_check l.body new_env)
                               )
                           )
                           (case (tag "Err" (msg)) (tag "Err" msg))
                       )
                   )
                )
                (case (tag "If" (i))
                    (let (cond_res (type_check i.cond env))
                        (match cond_res
                            (case (tag "Ok" (cond_ty))
                                (if (type_eq cond_ty (tag "Bool" (record)))
                                    (let (then_res (type_check i.then env))
                                        (match then_res
                                            (case (tag "Ok" (then_ty))
                                                (let (else_res (type_check i.else env))
                                                    (match else_res
                                                        (case (tag "Ok" (else_ty))
                                                            (if (type_eq then_ty else_ty)
                                                                (tag "Ok" then_ty)
                                                                (tag "Err" "If branches must have same type")
                                                            )
                                                        )
                                                        (case (tag "Err" (e)) (tag "Err" e))
                                                    )
                                                )
                                            )
                                            (case (tag "Err" (e)) (tag "Err" e))
                                        )
                                    )
                                    (tag "Err" "If condition must be Bool")
                                )
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
                (case (tag "Match" (m))
                    (let (target_res (call type_check m.target env))
                        (match target_res
                            (case (tag "Ok" (target_ty))
                                (call type_check_match m.cases target_ty env (tag "None" (record)))
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
                (case (tag "Lambda" (l))
                    (let (new_env (call env_put_args env l.args))
                        (let (body_res (call type_check l.body new_env))
                            (match body_res
                                (case (tag "Ok" (body_ty))
                                    (if (call type_eq body_ty l.ret)
                                        (tag "Ok" (tag "Fn" (record (args (call arg_list_to_type_list l.args)) (ret l.ret) (eff l.eff))))
                                        (tag "Err" "Lambda body type mismatch")
                                    )
                                )
                                (case (tag "Err" (e)) (tag "Err" e))
                            )
                        )
                    )
                )
                (case (tag "Intrinsic" (i))
                     (let (op i.0)
                        (let (args i.1)
                             (if (|| (= op "+") (|| (= op "-") (|| (= op "*") (|| (= op "/") (= op "%")))))
                                (if (= (list.length args) 2)
                                    (let (arg1 (list.get args 0))
                                    (let (arg2 (list.get args 1))
                                         (match arg1 
                                            (case (tag "Some" (a1))
                                                (match arg2
                                                    (case (tag "Some" (a2))
                                                        (let (t1_res (type_check a1 env))
                                                        (let (t2_res (type_check a2 env))
                                                            (match t1_res
                                                                (case (tag "Ok" (t1))
                                                                    (match t2_res
                                                                        (case (tag "Ok" (t2))
                                                                            (if (type_eq t1 (tag "I64" (record)))
                                                                                (if (type_eq t2 (tag "I64" (record)))
                                                                                    (tag "Ok" (tag "I64" (record)))
                                                                                    (tag "Err" "Right operand of + must be I64")
                                                                                )
                                                                                (tag "Err" "Left operand of + must be I64")
                                                                            )
                                                                        )
                                                                        (case (tag "Err" (e)) (tag "Err" e))
                                                                    )
                                                                )
                                                                (case (tag "Err" (e)) (tag "Err" e))
                                                            )
                                                        ))
                                                    )
                                                    (case (tag "None") (tag "Err" "Missing second argument for +"))
                                                )
                                            )
                                            (case (tag "None") (tag "Err" "Missing first argument for +"))
                                         )
                                    ))
                                    (tag "Err" "Operator + requires exactly 2 arguments")
                                )
                                (tag "Err" (str.concat "Unknown intrinsic: " op))
                             )
                        )
                     )
                )
                (case (tag "List" (l))
                    (let (items_res (call type_check_list_items l.items env (tag "None" (record))))
                        (match items_res
                            (case (tag "Ok" (item_ty)) (tag "Ok" (tag "List" (record (inner item_ty)))))
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
                (case (tag "Tuple" (t))
                    (let (items_res (call type_check_tuple_items t.items env))
                        (match items_res
                            (case (tag "Ok" (tys)) (tag "Ok" (tag "Tuple" (record (items tys)))))
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
                (case (tag "Call" (c))
                    (let (name c.0)
                    (let (args c.1)
                        (let (res (call env_get_fn env name))
                            (match res
                                (case (tag "Some" (fn_ty))
                                    (match fn_ty
                                        (case (tag "Fn" (f))
                                            ;; TODO: Check arg types
                                            (tag "Ok" f.ret)
                                        )
                                        (case (tag "Error" (e)) (tag "Err" e.msg))
                                        (case (tag "I64" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Bool" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Str" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Option" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Result" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "List" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Tuple" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Record" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Map" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Named" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Union" (_)) (tag "Err" "Calling non-function type"))
                                        (case (tag "Unit" (_)) (tag "Err" "Calling non-function type"))
                                    )
                                )
                                (case (tag "None") (tag "Err" (str.concat "Undefined function: " name)))
                            )
                        )
                    ))
                )
                (case (tag "Record" (r))
                    ;; TODO: Deduce record type from fields? Or hardcode for now.
                    (tag "Ok" (tag "Record" (record (fields (list)))))
                )
            )
        )
    )

    (deffn (name type_check_list_items) (args (l (List Expr)) (env TypeEnv) (first_ty (Option IrisType))) (ret (Result IrisType Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil")
                    (match first_ty
                        (case (tag "Some" (t)) (tag "Ok" t))
                        (case (tag "None") (tag "Ok" (tag "I64" (record)))) ;; Empty list defaults to I64 for now
                    )
                )
                (case (tag "cons" (h t))
                    (let (res (call type_check h env))
                        (match res
                            (case (tag "Ok" (ty))
                                (match first_ty
                                    (case (tag "Some" (f))
                                        (if (call type_eq ty f)
                                            (call type_check_list_items t env first_ty)
                                            (tag "Err" "List items have inconsistent types")
                                        )
                                    )
                                    (case (tag "None") (call type_check_list_items t env (tag "Some" ty)))
                                )
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
            )
        )
    )

    (deffn (name type_check_tuple_items) (args (l (List Expr)) (env TypeEnv)) (ret (Result (List IrisType) Str)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (tag "Ok" (list)))
                (case (tag "cons" (h t))
                    (let (res (call type_check h env))
                        (match res
                            (case (tag "Ok" (ty))
                                (let (rest_res (call type_check_tuple_items t env))
                                    (match rest_res
                                        (case (tag "Ok" (tys)) (tag "Ok" (cons ty tys)))
                                        (case (tag "Err" (e)) (tag "Err" e))
                                    )
                                )
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
            )
        )
    )
    (deffn (name env_put_args) (args (env TypeEnv) (l (List Arg))) (ret TypeEnv) (eff !Pure)
        (body
            (match l
                (case (tag "nil") env)
                (case (tag "cons" (h t))
                    (call env_put_args (call env_put env h.name h.type) t)
                )
            )
        )
    )

    (deffn (name arg_list_to_type_list) (args (l (List Arg))) (ret (List IrisType)) (eff !Pure)
        (body
            (match l
                (case (tag "nil") (list))
                (case (tag "cons" (h t)) (cons h.type (call arg_list_to_type_list t)))
            )
        )
    )

    (deffn (name type_check_match) (args (cases (List (Record (tag Str) (vars (List Str)) (body Expr)))) (target_ty IrisType) (env TypeEnv) (first_ty (Option IrisType))) (ret (Result IrisType Str)) (eff !Pure)
        (body
            (match cases
                (case (tag "nil")
                    (match first_ty
                        (case (tag "Some" (t)) (tag "Ok" t))
                        (case (tag "None") (tag "Err" "Empty match expression"))
                    )
                )
                (case (tag "cons" (h t))
                    ;; TODO: Properly lookup Union variants. For now, assume a few hardcoded ones or pass thru.
                    ;; We need the target_ty to be a Union or at least have variant info.
                    (let (res (call type_check h.body env)) ;; Simplification: Not binding vars yet because we lack variant types info
                        (match res
                            (case (tag "Ok" (ty))
                                (match first_ty
                                    (case (tag "Some" (f))
                                        (if (call type_eq ty f)
                                            (call type_check_match t target_ty env first_ty)
                                            (tag "Err" "Match arms have inconsistent types")
                                        )
                                    )
                                    (case (tag "None")
                                        (call type_check_match t target_ty env (tag "Some" ty))
                                    )
                                )
                            )
                            (case (tag "Err" (e)) (tag "Err" e))
                        )
                    )
                )
            )
        )
    )
  )
)
