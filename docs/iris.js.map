{
  "version": 3,
  "sources": ["../src/web-entry.ts", "../src/sexp/lexer.ts", "../src/sexp/parse-type.ts", "../src/sexp/parse-expr.ts", "../src/sexp/parser.ts", "../src/sexp/printer.ts", "../src/typecheck/utils.ts", "../src/typecheck/checks/literal.ts", "../src/typecheck/checks/control.ts", "../src/typecheck/checks/data.ts", "../src/typecheck/checks/call.ts", "../src/typecheck/checks/intrinsic.ts", "../src/typecheck/check-expr.ts", "../src/typecheck/checker.ts", "../src/eval/mocks.ts", "../src/eval/ops/math.ts", "../src/runtime/process.ts", "../src/eval/ops/sys.ts", "../src/eval/ops/io.ts", "../src/eval/ops/net.ts", "../src/eval/ops/http.ts", "../src/eval/ops/constructors.ts", "../src/eval/utils.ts", "../src/eval/ops/data.ts", "../src/eval/ops/index.ts", "../src/eval/expr.ts", "../src/eval/sync.ts", "../src/eval/interpreter.ts", "../src/main.ts", "../src/runtime/tool-host.ts", "../src/platform/browser.ts"],
  "sourcesContent": ["\nimport { run } from './main';\nimport { BrowserFileSystem, BrowserNetwork, BrowserToolHost } from './platform/browser';\nimport { IFileSystem, IToolHost } from './eval';\nimport { ToolRegistry } from './runtime/tool-host';\n\ndeclare var window: any;\n\nfunction resolveToolHost(tools?: ToolRegistry | IToolHost): IToolHost | undefined {\n    if (tools) {\n        if (typeof (tools as IToolHost).callTool === 'function') return tools as IToolHost;\n        return new BrowserToolHost(tools as ToolRegistry);\n    }\n\n    if (typeof window === 'undefined') return undefined;\n\n    const globalHost = (window as any).irisToolHost as IToolHost | undefined;\n    if (globalHost && typeof globalHost.callTool === 'function') return globalHost;\n\n    const registry = (window as any).irisTools as ToolRegistry | undefined;\n    if (registry && typeof registry === 'object') return new BrowserToolHost(registry);\n\n    return undefined;\n}\n\nexport async function runIris(source: string, tools?: ToolRegistry | IToolHost): Promise<string> {\n    const outputBuffer: string[] = [];\n    const originalLog = console.log;\n\n    // Capture console.log\n    console.log = (...args: any[]) => {\n        outputBuffer.push(args.map(a => String(a)).join(' '));\n        originalLog(...args);\n    };\n\n    try {\n        const fs = new BrowserFileSystem();\n        const net = new BrowserNetwork();\n\n        // We can pass empty modules for now, or pre-load them if needed\n        // Explicitly cast fs to IFileSystem to avoid TS confusion with Record type\n        const toolHost = resolveToolHost(tools);\n        const resultVal = await run(source, fs as IFileSystem, {}, net, [], false, toolHost);\n\n        // Final output is combination of side-effect prints + return value\n        if (resultVal.startsWith(\"RuntimeError:\") || resultVal.startsWith(\"TypeError:\") || resultVal.startsWith(\"ParseError:\")) {\n            outputBuffer.push(resultVal); // Error is usually the return string\n        } else {\n            outputBuffer.push(`=> ${resultVal}`);\n        }\n\n        return outputBuffer.join('\\n');\n    } catch (e: any) {\n        return `Unexpected Error: ${e.message}`;\n    } finally {\n        console.log = originalLog;\n    }\n}\n\n// Expose to window if available\nif (typeof window !== 'undefined') {\n    (window as any).runIris = runIris;\n}\n", "\nimport { Token } from './types';\n\nexport function tokenize(input: string): Token[] {\n    const tokens: Token[] = [];\n    let pos = 0;\n    let line = 1;\n    let col = 1;\n\n    while (pos < input.length) {\n        const char = input[pos];\n\n        if (/\\s/.test(char)) {\n            if (char === '\\n') {\n                line++;\n                col = 1;\n            } else {\n                col++;\n            }\n            pos++;\n            continue;\n        }\n\n        if (char === ';') {\n            while (pos < input.length && input[pos] !== '\\n') {\n                pos++;\n            }\n            continue;\n        }\n\n        if (char === '(') {\n            tokens.push({ kind: 'LParen', line, col });\n            pos++; col++;\n            continue;\n        }\n\n        if (char === ')') {\n            tokens.push({ kind: 'RParen', line, col });\n            pos++; col++;\n            continue;\n        }\n\n        // String\n        if (char === '\"') {\n            const startLine = line;\n            const startCol = col;\n            pos++; col++;\n            let strVal = '';\n            while (pos < input.length && input[pos] !== '\"') {\n                const c = input[pos];\n                if (c === '\\\\') {\n                    if (pos + 1 < input.length) {\n                        const next = input[pos + 1];\n                        if (next === '\"') strVal += '\"';\n                        else if (next === 'n') strVal += '\\n';\n                        else if (next === 't') strVal += '\\t';\n                        else if (next === 'r') strVal += '\\r';\n                        else if (next === '\\\\') strVal += '\\\\';\n                        else strVal += next;\n                        pos += 2; col += 2;\n                        continue;\n                    }\n                }\n\n                if (c === '\\n') {\n                    line++;\n                    col = 1;\n                } else {\n                    col++;\n                }\n                strVal += c;\n                pos++;\n            }\n            if (pos >= input.length) {\n                throw new Error(`Unterminated string starting at ${startLine}:${startCol}`);\n            }\n            pos++; col++; // Consume closing quote\n            tokens.push({ kind: 'Str', value: strVal, line: startLine, col: startCol });\n            continue;\n        }\n\n        // Integer (start with digit or -digit)\n        if (char === '-' && pos + 1 < input.length && /\\d/.test(input[pos + 1])) {\n            // Negative integer\n            let buf = '-';\n            pos++; col++;\n            while (pos < input.length && /\\d/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n            tokens.push({ kind: 'Int', value: BigInt(buf), line: line, col: col - buf.length });\n            continue;\n        }\n\n        if (/\\d/.test(char)) {\n            let buf = '';\n            const startCol = col;\n            while (pos < input.length && /\\d/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n            tokens.push({ kind: 'Int', value: BigInt(buf), line, col: startCol });\n            continue;\n        }\n\n        // Symbol (or Bool)\n        // Allowed symbol chars: non-whitespace, not ( ) \"\n        if (/[^()\\s\"]/.test(char)) {\n            let buf = '';\n            const startCol = col;\n            while (pos < input.length && /[^()\\s\"]/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n\n            if (buf === 'true') {\n                tokens.push({ kind: 'Bool', value: true, line, col: startCol });\n            } else if (buf === 'false') {\n                tokens.push({ kind: 'Bool', value: false, line, col: startCol });\n            } else {\n                tokens.push({ kind: 'Symbol', value: buf, line, col: startCol });\n            }\n            continue;\n        }\n\n        throw new Error(`Unexpected character '${char}' at ${line}:${col}`);\n    }\n\n    tokens.push({ kind: 'EOF', line, col });\n    return tokens;\n}\n", "\nimport { IrisType, IrisEffect } from '../types';\nimport { ParserContext } from './context';\nimport { Token } from './types';\n\nexport function parseType(ctx: ParserContext): IrisType {\n    const token = ctx.peek();\n    if (token.kind === 'Symbol') {\n        const w = token.value;\n        ctx.consume();\n        if (w === 'I64') return { type: 'I64' };\n        if (w === 'Bool') return { type: 'Bool' };\n        if (w === 'Str') return { type: 'Str' };\n        // Allow user-defined named types\n\n        if (w === 'Union') {\n            const variants: Record<string, IrisType> = {};\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                ctx.expectSymbol('tag');\n                const tagName = ctx.expectString();\n                const content = parseType(ctx);\n                ctx.expect('RParen');\n                variants[tagName] = content;\n            }\n            ctx.expect('RParen');\n            return { type: 'Union', variants };\n        }\n        if (w === 'Record' || w === 'record') {\n            const fields: Record<string, IrisType> = {};\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                const key = ctx.expectSymbol();\n                const val = parseType(ctx);\n                ctx.expect('RParen');\n                fields[key] = val;\n            }\n            ctx.expect('RParen');\n            return { type: 'Record', fields };\n        }\n        return { type: 'Named', name: w };\n    }\n\n    if (token.kind === 'LParen') {\n        ctx.consume();\n        const head = ctx.peek();\n        if (head.kind !== 'Symbol') throw new Error(\"Expected type constructor\");\n        const tMap = head.value;\n        ctx.consume();\n\n        if (tMap === 'Option') {\n            const inner = parseType(ctx);\n            ctx.expect('RParen');\n            return { type: 'Option', inner };\n        }\n        if (tMap === 'Result') {\n            const ok = parseType(ctx);\n            const err = parseType(ctx);\n            ctx.expect('RParen');\n            return { type: 'Result', ok, err };\n        }\n        if (tMap === 'List') {\n            const inner = parseType(ctx);\n            ctx.expect('RParen');\n            return { type: 'List', inner };\n        }\n        if (tMap === 'Record' || tMap === 'record') {\n            // (Record (f1 T1) (f2 T2))\n            const fields: Record<string, IrisType> = {};\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                const name = ctx.expectSymbol();\n                const type = parseType(ctx);\n                ctx.expect('RParen');\n                fields[name] = type;\n            }\n            ctx.expect('RParen');\n            return { type: 'Record', fields };\n        }\n        if (tMap === 'Map') {\n            const key = parseType(ctx);\n            const value = parseType(ctx);\n            ctx.expect('RParen');\n            return { type: 'Map', key, value };\n        }\n        if (tMap === 'Tuple') {\n            const items: IrisType[] = [];\n            while (!ctx.check('RParen')) {\n                items.push(parseType(ctx));\n            }\n            ctx.expect('RParen');\n            return { type: 'Tuple', items };\n        }\n\n        if (tMap === 'Union') {\n            const variants: Record<string, IrisType> = {};\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                ctx.expectSymbol('tag');\n                const tagName = ctx.expectString();\n                const content = parseType(ctx);\n                ctx.expect('RParen');\n                variants[tagName] = content;\n            }\n            ctx.expect('RParen');\n            return { type: 'Union', variants };\n        }\n\n        if (tMap === 'union') {\n            const variants: Record<string, IrisType> = {};\n            while (!ctx.check('RParen')) {\n                // (tag \"Name\" (args...))\n                ctx.expect('LParen');\n                ctx.expectSymbol('tag');\n                const tagName = ctx.expectString();\n\n\n                // Parse content typetional or list?\n                // Spec usually: (tag \"Name\" (T1 T2...))\n                // Let's assume (tag \"Name\" (T)) for matching t129.\n                let args: IrisType[] = [];\n                if (ctx.check('LParen')) {\n                    ctx.expect('LParen');\n                    while (!ctx.check('RParen')) {\n                        args.push(parseType(ctx));\n                    }\n                    ctx.expect('RParen');\n                }\n                ctx.expect('RParen');\n\n                // Store strict as tuple for now, unless single arg\n                if (args.length === 1) {\n                    variants[tagName] = args[0];\n                } else {\n                    variants[tagName] = { type: 'Tuple', items: args };\n                }\n            }\n            ctx.expect('RParen');\n            return { type: 'Union', variants };\n        }\n\n        if (tMap === 'Fn') {\n            // (Fn (Args...) Ret [Eff])\n            const args: IrisType[] = [];\n            ctx.expect('LParen');\n            while (!ctx.check('RParen')) {\n                args.push(parseType(ctx));\n            }\n            ctx.expect('RParen');\n\n            const ret = parseType(ctx);\n\n            let eff: IrisEffect = '!Pure'; // Default\n            const next = ctx.peek();\n            if (next.kind === 'Symbol' && next.value.startsWith('!')) {\n                eff = parseEffect(ctx);\n            }\n\n            ctx.expect('RParen');\n            return { type: 'Fn', args, ret, eff };\n        }\n\n        ctx.expect('RParen'); // Fallback\n        throw new Error(`Unknown type constructor: ${tMap}`);\n    }\n\n    throw new Error(`Unexpected token in type`);\n}\n\nexport function parseEffect(ctx: ParserContext): IrisEffect {\n    const t = ctx.peek();\n    if (t.kind === 'Symbol' && t.value.startsWith('!')) {\n        ctx.consume();\n        if (['!Pure', '!IO', '!Net', '!Any', '!Infer'].includes(t.value)) {\n            return t.value as IrisEffect;\n        }\n        throw new Error(`Unknown effect: ${t.value}`);\n    }\n    throw new Error(\"Expected effect starting with !\");\n}\n", "\nimport { Expr, MatchCase, IntrinsicOp, Value } from '../types';\nimport { ParserContext } from './context';\nimport { parseType, parseEffect } from './parse-type';\n\nexport function parseExpr(ctx: ParserContext): Expr {\n    const token = ctx.peek();\n\n    if (token.kind === 'Int') { ctx.consume(); return { kind: 'Literal', value: { kind: 'I64', value: token.value } }; }\n    if (token.kind === 'Bool') { ctx.consume(); return { kind: 'Literal', value: { kind: 'Bool', value: token.value } }; }\n    if (token.kind === 'Str') { ctx.consume(); return { kind: 'Literal', value: { kind: 'Str', value: token.value } }; }\n    if (token.kind === 'Symbol') {\n        if (token.value === 'None') { ctx.consume(); return { kind: 'Literal', value: { kind: 'Option', value: null } }; }\n        if (token.value === 'nil') { ctx.consume(); return { kind: 'Literal', value: { kind: 'List', items: [] } }; }\n        ctx.consume();\n        return { kind: 'Var', name: token.value };\n    }\n\n    if (token.kind === 'LParen') {\n        ctx.consume();\n        const head = ctx.peek();\n\n        if (head.kind !== 'Symbol') {\n            // (expr ...) -> Group or Tuple\n            const items: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                items.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            if (items.length === 1) return items[0];\n            return { kind: 'Tuple', items };\n        }\n\n        const op = head.value;\n        ctx.consume();\n\n        // Special forms\n        if (op === 'let') {\n            // (let (x EXPR) BODY)\n            ctx.expect('LParen');\n            const name = ctx.expectSymbol();\n            const val = parseExpr(ctx);\n            ctx.expect('RParen');\n            const body = parseExpr(ctx);\n            ctx.expect('RParen');\n            return { kind: 'Let', name, value: val, body };\n        }\n        if (op === 'lambda') {\n            // (lambda (args (x T) ...) (ret T) (eff !E) (body E))\n            ctx.expect('LParen'); ctx.expectSymbol('args');\n            const args: { name: string, type: any }[] = [];\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                const argName = ctx.expectSymbol();\n                const argType = parseType(ctx);\n                ctx.expect('RParen');\n                args.push({ name: argName, type: argType });\n            }\n            ctx.expect('RParen');\n\n            ctx.expect('LParen'); ctx.expectSymbol('ret'); const ret = parseType(ctx); ctx.expect('RParen');\n            ctx.expect('LParen'); ctx.expectSymbol('eff'); const eff = parseEffect(ctx); ctx.expect('RParen');\n            ctx.expect('LParen'); ctx.expectSymbol('body'); const body = parseExpr(ctx); ctx.expect('RParen');\n\n            return { kind: 'Lambda', args, ret, eff, body };\n        }\n        if (op === 'record') {\n            // (record (k v) ...)\n            const fields: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                const key = ctx.expectSymbol();\n                const val = parseExpr(ctx);\n                ctx.expect('RParen');\n\n                const keyExpr: Expr = { kind: 'Literal', value: { kind: 'Str', value: key } };\n                const fieldTuple: Expr = { kind: 'Tuple', items: [keyExpr, val] };\n                fields.push(fieldTuple);\n            }\n            ctx.expect('RParen');\n            return { kind: 'Record', fields };\n        }\n        if (op === 'if') {\n            const cond = parseExpr(ctx);\n            const thenBr = parseExpr(ctx);\n            const elseBr = parseExpr(ctx);\n            ctx.expect('RParen');\n            return { kind: 'If', cond, then: thenBr, else: elseBr };\n        }\n        if (op === 'match') {\n            const target = parseExpr(ctx);\n            const cases: MatchCase[] = [];\n            while (!ctx.check('RParen')) {\n                ctx.expect('LParen');\n                ctx.expectSymbol('case');\n                ctx.expect('LParen');\n                ctx.expectSymbol('tag');\n                const tag = ctx.expectString();\n                const vars: string[] = [];\n                // Optional args (v) or nothing\n                if (ctx.check('LParen')) {\n                    ctx.expect('LParen');\n                    while (!ctx.check('RParen')) {\n                        vars.push(ctx.expectSymbol());\n                    }\n                    ctx.expect('RParen');\n                }\n                ctx.expect('RParen'); // close tag\n                const body = parseExpr(ctx);\n                ctx.expect('RParen'); // close case\n\n                const varsValue: Value = {\n                    kind: 'List',\n                    items: vars.map(v => ({ kind: 'Str', value: v } as Value))\n                };\n                cases.push({ tag, vars: varsValue, body });\n            }\n            ctx.expect('RParen');\n            return { kind: 'Match', target, cases };\n        }\n        if (op === 'call') {\n            const fn = ctx.expectSymbol();\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Call', fn, args };\n        }\n\n        // Constructors / Intrinsics\n        if (['+', '-', '*', '/', '%', '<=', '<', '=', '>=', '>', '&&', '||', '!', 'Some', 'Ok', 'Err', 'cons', 'tuple.get', 'record.get', 'io.print', 'io.read_file', 'io.write_file', 'i64.from_string', 'i64.to_string'].includes(op)) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (io.* ...)\n        if (op.startsWith('io.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (net.* ...)\n        if (op.startsWith('net.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (http.* ...)\n        if (op.startsWith('http.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (str.* ...)\n        if (op.startsWith('str.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (sys.* ...)\n        if (op.startsWith('sys.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (map.* ...)\n        if (op.startsWith('map.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (list.* ...)\n        if (op.startsWith('list.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (tuple.* ...)\n        if (op.startsWith('tuple.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // Check for (record.* ...)\n        if (op.startsWith('record.')) {\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n        }\n\n        // (list e1 ...)\n        if (op === 'list') {\n            const items: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                items.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'List', items };\n        }\n\n        // (list-of Type e1 ...)\n        if (op === 'list-of') {\n            const typeArg = parseType(ctx);\n            const items: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                items.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'List', items, typeArg };\n        }\n\n        // (tuple e1 ...)\n        if (op === 'tuple') {\n            const items: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                items.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Tuple', items };\n        }\n\n        if (op === 'union') {\n            const tagName = ctx.expectString();\n            const args: Expr[] = [];\n            while (!ctx.check('RParen')) {\n                args.push(parseExpr(ctx));\n            }\n            ctx.expect('RParen');\n            return { kind: 'Tuple', items: [{ kind: 'Literal', value: { kind: 'Str', value: tagName } }, ...args] };\n        }\n\n        if (op === 'tag') {\n            const tagName = ctx.expectString();\n            let value: Expr;\n            if (ctx.check('RParen')) {\n                // Empty tag payload -> Unit/Empty Tuple?\n                value = { kind: 'Tuple', items: [] };\n            } else {\n                value = parseExpr(ctx);\n            }\n            ctx.expect('RParen');\n            return { kind: 'Tagged', tag: tagName, value };\n        }\n        const args: Expr[] = [];\n        while (!ctx.check('RParen')) {\n            args.push(parseExpr(ctx));\n        }\n        ctx.expect('RParen');\n        return { kind: 'Call', fn: op, args };\n    }\n\n    throw new Error(`Unexpected token for expression: ${token.kind} at ${token.line}:${token.col}`);\n}\n", "\nimport { Program, Definition, Expr, IrisType, IrisEffect, Import, Capability } from '../types';\nimport { Token } from './types';\nimport { tokenize } from './lexer';\nimport { ParserContext } from './context';\nimport { parseType, parseEffect } from './parse-type';\nimport { parseExpr } from './parse-expr';\n\nexport class Parser implements ParserContext {\n    private tokens: Token[];\n    private pos = 0;\n    public debug = false;\n    private lastClosedSection: { name: string, line: number, col: number } | null = null;\n\n    constructor(input: string, debug: boolean = false) {\n        this.tokens = tokenize(input);\n        this.debug = debug;\n    }\n\n    public log(msg: string) {\n        if (this.debug) {\n            console.log(`[Parser] ${msg}`);\n        }\n    }\n\n    parse(): Program {\n        this.expect('LParen');\n        this.expectSymbol('program');\n\n        let moduleDecl = { name: 'unknown', version: 0 };\n        const imports: Import[] = [];\n        const defs: Definition[] = [];\n\n        while (!this.check('RParen')) {\n            this.log(`Parsing section loop. Peek: ${this.peek().kind} '${(this.peek() as any).value || ''}'`);\n            this.expect('LParen');\n            const section = this.expectSymbol();\n            this.log(`Start section: ${section}`);\n\n            if (section === 'module') {\n                this.expect('LParen');\n                this.expectSymbol('name');\n                const name = this.expectString();\n                this.expect('RParen');\n                this.expect('LParen');\n                this.expectSymbol('version');\n                const version = Number(this.expectInt());\n                this.expect('RParen');\n                this.expect('RParen');\n                moduleDecl = { name, version };\n                this.log(`Parsed module: ${name} v${version}`);\n                this.lastClosedSection = { name: 'module', line: this.tokens[this.pos - 1].line, col: this.tokens[this.pos - 1].col };\n            } else if (section === 'imports') {\n                this.log('Parsing imports...');\n                while (!this.check('RParen')) {\n                    this.expect('LParen');\n                    this.expectSymbol('import');\n                    const path = this.expectString();\n                    let alias = '';\n                    if (this.check('LParen')) {\n                        this.expect('LParen');\n                        this.expectSymbol('as');\n                        alias = this.expectString();\n                        this.expect('RParen');\n                    } else {\n                        throw new Error(\"Import must have alias currently\");\n                    }\n                    this.expect('RParen');\n                    imports.push({ path, alias });\n                }\n                this.expect('RParen');\n                this.log(`Parsed ${imports.length} imports`);\n                this.lastClosedSection = { name: 'imports', line: this.tokens[this.pos - 1].line, col: this.tokens[this.pos - 1].col };\n            } else if (section === 'defs') {\n                this.log('Parsing defs...');\n                while (!this.check('RParen')) {\n                    const t = this.peek();\n                    this.log(`Parsing definition. Peek: ${t.kind} '${(t as any).value || ''}' at ${t.line}:${t.col}`);\n                    if (t.kind === 'RParen') {\n                        this.log(\"Saw RParen explicitly in loop check (should not happen due to while condition)\");\n                    }\n                    defs.push(this.parseDefinition());\n                }\n                const endT = this.peek();\n                this.log(`Finished parsing defs. Peek is: ${endT.kind} at ${endT.line}:${endT.col}`);\n                this.expect('RParen');\n                this.lastClosedSection = { name: 'defs', line: this.tokens[this.pos - 1].line, col: this.tokens[this.pos - 1].col };\n            } else {\n                this.log(`Unknown section: ${section}`);\n                let msg = `Unknown program section: ${section} at line ${this.tokens[this.pos].line}`;\n                if (this.lastClosedSection) {\n                    msg += `. Note: Previous section '${this.lastClosedSection.name}' closed at ${this.lastClosedSection.line}:${this.lastClosedSection.col}`;\n                }\n                throw new Error(msg);\n            }\n        }\n\n        this.expect('RParen');\n        return { module: moduleDecl, imports, defs };\n    }\n\n    private parseMetaSection(\n        meta: { doc?: string; requires?: string; ensures?: string; caps?: Capability[] },\n        allowed: { doc?: boolean; requires?: boolean; ensures?: boolean; caps?: boolean }\n    ) {\n        const save = this.pos;\n        this.expect('LParen');\n        const tagTok = this.peek();\n        if (tagTok.kind !== 'Symbol') {\n            this.pos = save;\n            this.skipSExp();\n            return;\n        }\n        const tag = this.expectSymbol();\n\n        if (tag === 'doc' && allowed.doc) {\n            meta.doc = this.expectString();\n            this.expect('RParen');\n            return;\n        }\n        if (tag === 'requires' && allowed.requires) {\n            meta.requires = this.expectString();\n            this.expect('RParen');\n            return;\n        }\n        if (tag === 'ensures' && allowed.ensures) {\n            meta.ensures = this.expectString();\n            this.expect('RParen');\n            return;\n        }\n        if (tag === 'caps' && allowed.caps) {\n            const caps: Capability[] = [];\n            while (!this.check('RParen')) {\n                this.expect('LParen');\n                const name = this.expectSymbol();\n                const type = parseType(this);\n                this.expect('RParen');\n                caps.push({ name, type });\n            }\n            this.expect('RParen');\n            meta.caps = caps;\n            return;\n        }\n\n        // Unknown or unsupported metadata tag; skip it.\n        this.pos = save;\n        this.skipSExp();\n    }\n\n    private parseDefinition(): Definition {\n        this.expect('LParen');\n        const kind = this.expectSymbol();\n\n        if (kind === 'defconst') {\n            this.expect('LParen'); this.expectSymbol('name'); const name = this.expectSymbol(); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('type'); const type = parseType(this); this.expect('RParen');\n            const meta: { doc?: string } = {};\n            while (this.check('LParen')) {\n                const save = this.pos;\n                this.expect('LParen');\n                const tag = this.peek();\n                if (tag.kind === 'Symbol' && tag.value === 'value') {\n                    this.pos = save;\n                    break;\n                }\n                this.pos = save;\n                this.parseMetaSection(meta, { doc: true });\n            }\n            this.expect('LParen'); this.expectSymbol('value'); const value = parseExpr(this); this.expect('RParen');\n            this.expect('RParen');\n            return { kind: 'DefConst', name, type, value, doc: meta.doc };\n        } else if (kind === 'deffn') {\n            this.expect('LParen'); this.expectSymbol('name'); const name = this.expectSymbol(); this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('args');\n            const args: { name: string, type: IrisType }[] = [];\n            while (!this.check('RParen')) {\n                this.expect('LParen');\n                const argName = this.expectSymbol();\n                const argType = parseType(this);\n                this.expect('RParen');\n                args.push({ name: argName, type: argType });\n            }\n            this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('ret'); const ret = parseType(this); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('eff'); const eff = parseEffect(this); this.expect('RParen');\n\n            const meta: { doc?: string; requires?: string; ensures?: string; caps?: Capability[] } = {};\n            while (this.check('LParen')) {\n                const save = this.pos;\n                this.expect('LParen');\n                const tag = this.peek();\n                if (tag.kind === 'Symbol' && tag.value === 'body') {\n                    this.pos = save;\n                    break;\n                }\n                this.pos = save;\n                this.parseMetaSection(meta, { doc: true, requires: true, ensures: true, caps: true });\n            }\n\n            this.expect('LParen'); this.expectSymbol('body'); const body = parseExpr(this); this.expect('RParen');\n            this.expect('RParen');\n\n            return { kind: 'DefFn', name, args, ret, eff, body, ...meta };\n        } else if (kind === 'deftool') {\n            this.expect('LParen'); this.expectSymbol('name'); const name = this.expectSymbol(); this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('args');\n            const args: { name: string, type: IrisType }[] = [];\n            while (!this.check('RParen')) {\n                this.expect('LParen');\n                const argName = this.expectSymbol();\n                const argType = parseType(this);\n                this.expect('RParen');\n                args.push({ name: argName, type: argType });\n            }\n            this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('ret'); const ret = parseType(this); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('eff'); const eff = parseEffect(this); this.expect('RParen');\n\n            const meta: { doc?: string; requires?: string; ensures?: string; caps?: Capability[] } = {};\n            while (this.check('LParen')) {\n                this.parseMetaSection(meta, { doc: true, requires: true, ensures: true, caps: true });\n            }\n            this.expect('RParen');\n\n            return { kind: 'DefTool', name, args, ret, eff, ...meta };\n        } else if (kind === 'type' || kind === 'deftype') {\n            const name = this.expectSymbol();\n            const type = parseType(this);\n            const meta: { doc?: string } = {};\n            while (this.check('LParen')) {\n                this.parseMetaSection(meta, { doc: true });\n            }\n            this.expect('RParen');\n            return { kind: 'TypeDef', name, type, doc: meta.doc };\n        } else {\n            throw new Error(`Unknown definition kind: ${kind}`);\n        }\n    }\n\n    public parseExpr(): Expr {\n        return parseExpr(this);\n    }\n\n    public peek() {\n        if (this.pos >= this.tokens.length) return { kind: 'EOF', line: 0, col: 0 } as Token;\n        return this.tokens[this.pos];\n    }\n    public consume() {\n        // console.log(`Consume: ${this.tokens[this.pos]?.kind} '${(this.tokens[this.pos] as any)?.value || ''}'`);\n        this.pos++;\n    }\n\n    public check(kind: Token['kind']): boolean {\n        const t = this.peek();\n        // console.log(`Check ${kind} vs ${t.kind}`);\n        return t.kind === kind;\n    }\n\n    public expect(kind: Token['kind']) {\n        const t = this.peek();\n        // console.log(`Expect ${kind} vs ${t.kind} at ${t.line}:${t.col}`);\n        if (t.kind !== kind) {\n            throw new Error(`Expected ${kind} at ${t.line}:${t.col}, got ${t.kind} '${(t as any).value || ''}'`);\n        }\n        this.consume();\n    }\n\n    public expectSymbol(val?: string): string {\n        const t = this.peek();\n        if (t.kind !== 'Symbol') {\n            throw new Error(`Expected Symbol at ${t.line}:${t.col}, got ${t.kind}`);\n        }\n        if (val && t.value !== val) {\n            throw new Error(`Expected symbol '${val}' at ${t.line}:${t.col}, got '${t.value}'`);\n        }\n        this.consume();\n        return t.value;\n    }\n\n    public expectString(): string {\n        const t = this.peek();\n        if (t.kind !== 'Str') {\n            throw new Error(`Expected String at ${t.line}:${t.col}, got ${t.kind}`);\n        }\n        this.consume();\n        return t.value;\n    }\n\n    public expectInt(): bigint {\n        const t = this.peek();\n        if (t.kind !== 'Int') {\n            throw new Error(`Expected Int at ${t.line}:${t.col}, got ${t.kind}`);\n        }\n        this.consume();\n        return t.value;\n    }\n\n    public skipSExp() {\n        let depth = 0;\n        if (this.check('LParen')) {\n            this.consume();\n            depth = 1;\n            while (depth > 0 && this.pos < this.tokens.length) {\n                if (this.check('LParen')) depth++;\n                else if (this.check('RParen')) depth--;\n                this.consume();\n            }\n        } else {\n            this.consume();\n        }\n    }\n}\n", "\nimport { Value } from '../types';\n\nfunction escapeStr(s: string): string {\n    return s.replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g, '\\\\\"')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\r/g, '\\\\r');\n}\n\nexport function printValue(v: Value): string {\n    switch (v.kind) {\n        case 'I64': return v.value.toString();\n        case 'Bool': return v.value.toString();\n        case 'Str': return `\"${escapeStr(v.value)}\"`;\n        case 'Option': return v.value === null ? \"None\" : `(Some ${printValue(v.value)})`;\n        case 'Result': return v.isOk ? `(Ok ${printValue(v.value)})` : `(Err ${printValue(v.value)})`;\n        case 'List': return `(list ${v.items.map(printValue).join(' ')})`;\n        case 'Tuple': return `(tuple ${v.items.map(printValue).join(' ')})`;\n        case 'Record': {\n            const keys = Object.keys(v.fields).sort();\n            const content = keys.map(k => `(${k} ${printValue(v.fields[k])})`).join(' ');\n            return `(record${content ? ' ' + content : ''})`;\n        }\n        case 'Map': return `(map)`; // Simplified for now\n        case 'Tagged': return `(tag \"${v.tag}\" ${printValue(v.value)})`;\n        case 'Lambda': return \"Lambda\";\n    }\n    return `UnknownValue(${(v as any).kind})`;\n\n}\n", "\nimport { IrisType, IrisEffect } from '../types';\nimport { TypeCheckerContext } from './context';\n\nexport function effectOrder(eff: IrisEffect): number {\n    switch (eff) {\n        case '!Pure': return 0;\n        case '!IO': return 1;\n        case '!Net': return 2;\n        case '!Any': return 3;\n        case '!Infer': return -1;\n    }\n    return 0;\n}\n\nexport function joinEffects(e1: IrisEffect, e2: IrisEffect): IrisEffect {\n    if (e1 === '!Infer' || e2 === '!Infer') return '!Pure';\n    if (e1 === '!Any' || e2 === '!Any') return '!Any';\n    if (e1 === '!Net' || e2 === '!Net') return '!Net';\n    if (e1 === '!IO' || e2 === '!IO') return '!IO';\n    return '!Pure';\n}\n\nexport function checkEffectSubtype(ctx: TypeCheckerContext, required: IrisEffect, declared: IrisEffect, message: string) {\n    if (declared === '!Infer') return;\n    if (declared === '!Any') return;\n\n    const ordReq = effectOrder(required);\n    const ordDecl = effectOrder(declared);\n\n    if (ordReq > ordDecl) {\n        throw new Error(`TypeError: EffectMismatch: ${message}: Inferred ${required} but declared ${declared}`);\n    }\n}\n\nexport function resolve(ctx: TypeCheckerContext, t: IrisType): IrisType {\n    if (t.type === 'Named') {\n        if (ctx.types.has(t.name)) {\n            return resolve(ctx, ctx.types.get(t.name)!);\n        }\n        return t;\n    }\n    return t;\n}\n\nexport function fmt(ctx: TypeCheckerContext, t: IrisType): string {\n    if (!t) return 'undefined';\n    if (t.type === 'Named') return t.name;\n\n    const resolved = resolve(ctx, t);\n    if (resolved !== t && resolved.type !== 'Named') return fmt(ctx, resolved);\n\n    switch (t.type) {\n        case 'I64': return 'I64';\n        case 'Bool': return 'Bool';\n        case 'Str': return 'Str';\n        case 'Option': return `(Option ${fmt(ctx, t.inner)})`;\n        case 'Result': return `(Result ${fmt(ctx, t.ok)} ${fmt(ctx, t.err)})`;\n        case 'List': return `(List ${fmt(ctx, t.inner)})`;\n        case 'Tuple': return `(Tuple ${t.items.map(i => fmt(ctx, i)).join(' ')})`;\n        case 'Map': return `(Map ${fmt(ctx, t.key)} ${fmt(ctx, t.value)})`;\n        case 'Record': return `(Record ${Object.keys(t.fields).map(k => `(${k} ${fmt(ctx, t.fields[k])})`).join(' ')})`;\n        case 'Union': return `(Union ${Object.keys(t.variants).map(k => `(tag \"${k}\" ${fmt(ctx, t.variants[k])})`).join(' ')})`;\n        case 'Fn': return `(Fn (${t.args.map(a => fmt(ctx, a)).join(' ')}) ${fmt(ctx, t.ret)})`; // Should we show Effect? Maybe.\n        default: return 'Unknown';\n    }\n}\n\nexport function typesEqual(ctx: TypeCheckerContext, t1: IrisType, t2: IrisType): boolean {\n    const origT1 = t1;\n    const origT2 = t2;\n    t1 = resolve(ctx, t1);\n    t2 = resolve(ctx, t2);\n\n    if (t1 === t2) return true;\n\n    if (t1.type !== t2.type) {\n        if (t1.type === 'Union' && t2.type === 'Tuple') {\n            if (t2.items.length === 1) {\n                const content = t2.items[0];\n                for (const variantType of Object.values(t1.variants)) {\n                    if (typesEqual(ctx, variantType, content)) return true;\n                }\n            }\n            if (t2.items.length === 2 && t2.items[0].type === 'Str') {\n                const content = t2.items[1];\n                for (const variantType of Object.values(t1.variants)) {\n                    if (typesEqual(ctx, variantType, content)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    if (t1.type === 'Named') return t1.name === (t2 as any).name;\n    if (t1.type === 'I64') return true;\n    if (t1.type === 'Bool') return true;\n    if (t1.type === 'Str') return true;\n\n    if (t1.type === 'Union' && t2.type === 'Union') {\n        const t1Vars = (t1 as any).variants;\n        const t2Vars = (t2 as any).variants;\n        for (const [tag, type] of Object.entries(t2Vars)) {\n            if (!t1Vars[tag]) return false;\n            if (!typesEqual(ctx, t1Vars[tag] as IrisType, type as IrisType)) return false;\n        }\n        return true;\n    }\n\n    if (t1.type === 'Record' && t2.type === 'Record') {\n        const k1 = Object.keys((t1 as any).fields).sort();\n        const k2 = Object.keys((t2 as any).fields).sort();\n        if (k1.length !== k2.length) return false;\n        for (let i = 0; i < k1.length; i++) {\n            if (k1[i] !== k2[i]) return false;\n            if (!typesEqual(ctx, (t1 as any).fields[k1[i]], (t2 as any).fields[k2[i]])) return false;\n        }\n        return true;\n    }\n\n    if (t1.type === 'Option') {\n        if (!(t1 as any).inner || !(t2 as any).inner) return false;\n        return typesEqual(ctx, (t1 as any).inner, (t2 as any).inner);\n    }\n    if (t1.type === 'Result') {\n        if (!(t1 as any).ok || !(t1 as any).err || !(t2 as any).ok || !(t2 as any).err) return false;\n        return typesEqual(ctx, (t1 as any).ok, (t2 as any).ok) && typesEqual(ctx, (t1 as any).err, (t2 as any).err);\n    }\n\n    if (t1.type === 'List') {\n        if (!(t1 as any).inner || !(t2 as any).inner) return false;\n        return typesEqual(ctx, (t1 as any).inner, (t2 as any).inner);\n    }\n    if (t1.type === 'Map') {\n        if (!(t1 as any).key || !(t1 as any).value || !(t2 as any).key || !(t2 as any).value) return false;\n        return typesEqual(ctx, (t1 as any).key, (t2 as any).key) && typesEqual(ctx, (t1 as any).value, (t2 as any).value);\n    }\n    if (t1.type === 'Tuple') {\n        const i1 = (t1 as any).items;\n        const i2 = (t2 as any).items;\n        if (!i1 || !i2 || i1.length !== i2.length) return false;\n        for (let i = 0; i < i1.length; i++) {\n            if (!typesEqual(ctx, i1[i], i2[i])) return false;\n        }\n        return true;\n    }\n\n    if (t1.type === 'Fn' && t2.type === 'Fn') {\n        if (t1.args.length !== t2.args.length) return false;\n        for (let i = 0; i < t1.args.length; i++) {\n            if (!typesEqual(ctx, t1.args[i], t2.args[i])) return false;\n        }\n        if (!typesEqual(ctx, t1.ret, t2.ret)) return false;\n        return t1.eff === t2.eff;\n    }\n\n    return false;\n}\n\nexport function expectType(ctx: TypeCheckerContext, expected: IrisType, actual: IrisType, message: string) {\n    if (!typesEqual(ctx, expected, actual)) {\n        throw new Error(`TypeError: ${message}: Expected ${fmt(ctx, expected)}, got ${fmt(ctx, actual)}`);\n    }\n}\n\nexport function qualifyType(ctx: TypeCheckerContext, t: IrisType, alias: string, exported: Set<string>): IrisType {\n    if (t.type === 'Named') {\n        if (exported.has(t.name)) {\n            return { type: 'Named', name: `${alias}.${t.name}` };\n        }\n        return t;\n    }\n    if (t.type === 'Option') return { ...t, inner: qualifyType(ctx, t.inner, alias, exported) };\n    if (t.type === 'Result') return { ...t, ok: qualifyType(ctx, t.ok, alias, exported), err: qualifyType(ctx, t.err, alias, exported) };\n    if (t.type === 'List') return { ...t, inner: qualifyType(ctx, t.inner, alias, exported) };\n    if (t.type === 'Tuple') return { ...t, items: t.items.map(i => qualifyType(ctx, i, alias, exported)) };\n    if (t.type === 'Record') {\n        const newFields: any = {};\n        for (const k in t.fields) newFields[k] = qualifyType(ctx, t.fields[k], alias, exported);\n        return { ...t, fields: newFields };\n    }\n    if (t.type === 'Union') {\n        const newVars: any = {};\n        for (const k in t.variants) newVars[k] = qualifyType(ctx, t.variants[k], alias, exported);\n        return { ...t, variants: newVars };\n    }\n    if (t.type === 'Map') return { ...t, key: qualifyType(ctx, t.key, alias, exported), value: qualifyType(ctx, t.value, alias, exported) };\n    if (t.type === 'Fn') return {\n        ...t,\n        args: t.args.map(a => qualifyType(ctx, a, alias, exported)),\n        ret: qualifyType(ctx, t.ret, alias, exported)\n    };\n    return t;\n}\n", "\nimport { Expr, IrisType, IrisEffect } from '../../types';\nimport { TypeCheckerContext, CheckFn } from '../context';\n\nexport function checkLiteral(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind !== 'Literal') throw new Error(\"Internal: checkLiteral called on non-Literal\");\n    const val = expr.value;\n    if (val.kind === 'I64') return { type: { type: 'I64' }, eff: '!Pure' };\n    if (val.kind === 'Bool') return { type: { type: 'Bool' }, eff: '!Pure' };\n    if (val.kind === 'Str') return { type: { type: 'Str' }, eff: '!Pure' };\n    if (val.kind === 'Option') {\n        if (val.value === null) return { type: { type: 'Option', inner: { type: 'I64' } }, eff: '!Pure' }; // Default None type\n        const inner = check(ctx, { kind: 'Literal', value: val.value } as Expr, env);\n        return { type: { type: 'Option', inner: inner.type }, eff: inner.eff };\n    }\n    if (val.kind === 'Result') {\n        const v = check(ctx, { kind: 'Literal', value: val.value } as Expr, env);\n        // Generous Result type\n        return { type: { type: 'Result', ok: val.isOk ? v.type : { type: 'Str' }, err: val.isOk ? { type: 'Str' } : v.type }, eff: v.eff };\n    }\n    if (val.kind === 'List') {\n        if (expectedType && expectedType.type === 'List') {\n            return { type: expectedType, eff: '!Pure' };\n        }\n        return { type: { type: 'List', inner: { type: 'I64' } }, eff: '!Pure' };\n    }\n    if (val.kind === 'Tuple') return { type: { type: 'Tuple', items: [] }, eff: '!Pure' };\n    if (val.kind === 'Record') return { type: { type: 'Record', fields: {} }, eff: '!Pure' };\n    throw new Error(`Unknown literal kind: ${(val as any).kind}`);\n}\n", "\nimport { Expr, IrisType, IrisEffect, Value } from '../../types';\nimport { TypeCheckerContext, CheckFn } from '../context';\nimport { resolve, joinEffects, expectType, fmt } from '../utils';\n\nexport function checkControl(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind === 'Let') {\n        const letExpr = expr as any;\n        if (!letExpr.value) console.log(\"Let expr missing value:\", JSON.stringify(letExpr));\n        const valRes = check(ctx, letExpr.value, env);\n        const newEnv = new Map(env);\n        newEnv.set(letExpr.name, valRes.type);\n        const bodyRes = check(ctx, letExpr.body, newEnv, expectedType);\n        return { type: bodyRes.type, eff: joinEffects(valRes.eff, bodyRes.eff) };\n    }\n\n    if (expr.kind === 'If') {\n        const cond = check(ctx, expr.cond, env, { type: 'Bool' });\n        expectType(ctx, { type: 'Bool' }, cond.type, \"Type Error in If condition\");\n        const thenBr = check(ctx, expr.then, env, expectedType);\n        const elseBr = check(ctx, expr.else, env, expectedType || thenBr.type);\n        expectType(ctx, thenBr.type, elseBr.type, \"If branches mismatch\");\n        return { type: expectedType || thenBr.type, eff: joinEffects(cond.eff, joinEffects(thenBr.eff, elseBr.eff)) };\n    }\n\n    if (expr.kind === 'Match') {\n        const target = check(ctx, expr.target, env);\n        let retType: IrisType | null = null;\n        let joinedEff: IrisEffect = target.eff;\n\n        let resolvedTarget = resolve(ctx, target.type);\n\n        if (resolvedTarget.type === 'Option') {\n            for (const c of expr.cases) {\n                const newEnv = new Map(env);\n                const vars: string[] = [];\n                if (c.vars.kind === 'List') {\n                    for (const item of c.vars.items) {\n                        if (item.kind === 'Str') vars.push(item.value);\n                    }\n                }\n\n                if (c.tag === 'Some') {\n                    if (vars.length !== 1) throw new Error(\"Some case expects 1 variable\");\n                    if (!resolvedTarget.inner) throw new Error(\"Internal error: Option type missing inner type\");\n                    newEnv.set(vars[0], resolvedTarget.inner);\n                } else if (c.tag === 'None') {\n                    if (vars.length !== 0) throw new Error(\"None case expects 0 variables\");\n                } else throw new Error(`Unknown option match tag: ${c.tag}`);\n\n                const body = check(ctx, c.body, newEnv, retType || expectedType);\n                if (retType) expectType(ctx, retType, body.type, \"Match arms mismatch\");\n                else retType = body.type;\n                joinedEff = joinEffects(joinedEff, body.eff);\n            }\n        } else if (resolvedTarget.type === 'Result') {\n            for (const c of expr.cases) {\n                const newEnv = new Map(env);\n                const vars: string[] = [];\n                if (c.vars.kind === 'List') {\n                    for (const item of c.vars.items) {\n                        if (item.kind === 'Str') vars.push(item.value);\n                    }\n                }\n\n                if (c.tag === 'Ok') {\n                    if (vars.length !== 1) throw new Error(\"Ok case expects 1 variable\");\n                    if (!resolvedTarget.ok) throw new Error(\"Internal error: Result type missing ok type\");\n                    newEnv.set(vars[0], resolvedTarget.ok);\n                } else if (c.tag === 'Err') {\n                    if (vars.length !== 1) throw new Error(\"Err case expects 1 variable\");\n                    if (!resolvedTarget.err) throw new Error(\"Internal error: Result type missing err type\");\n                    newEnv.set(vars[0], resolvedTarget.err);\n                } else throw new Error(`Unknown result match tag: ${c.tag}`);\n\n                const body = check(ctx, c.body, newEnv, retType || expectedType);\n                if (retType) expectType(ctx, retType, body.type, \"Match arms mismatch\");\n                else retType = body.type;\n                joinedEff = joinEffects(joinedEff, body.eff);\n            }\n        } else if (resolvedTarget.type === 'List') {\n            for (const c of expr.cases) {\n                const newEnv = new Map(env);\n                const vars: string[] = [];\n                if (c.vars.kind === 'List') {\n                    for (const item of c.vars.items) {\n                        if (item.kind === 'Str') vars.push(item.value);\n                    }\n                }\n\n                if (c.tag === 'nil') {\n                    if (vars.length !== 0) throw new Error(\"nil case expects 0 variables\");\n                } else if (c.tag === 'cons') {\n                    if (vars.length !== 2) throw new Error(\"cons case expects 2 variables (head tail)\");\n                    if (!resolvedTarget.inner) throw new Error(\"Internal List missing inner\");\n                    newEnv.set(vars[0], resolvedTarget.inner!); // head\n                    newEnv.set(vars[1], resolvedTarget);       // tail\n                } else throw new Error(`Unknown list match tag: ${c.tag}`);\n\n                const body = check(ctx, c.body, newEnv, retType || expectedType);\n                if (retType) expectType(ctx, retType, body.type, \"Match arms mismatch\");\n                else retType = body.type;\n                joinedEff = joinEffects(joinedEff, body.eff);\n            }\n        } else if (resolvedTarget.type === 'Union') {\n            for (const c of expr.cases) {\n                const newEnv = new Map(env);\n                const vars: string[] = [];\n                if (c.vars.kind === 'List') {\n                    for (const item of c.vars.items) {\n                        if (item.kind === 'Str') vars.push(item.value);\n                    }\n                }\n\n                if (c.tag === '_') {\n                    if (vars.length !== 0) throw new Error(\"Wildcard match cannot bind variables\");\n                } else {\n                    const variantType = resolvedTarget.variants[c.tag];\n                    if (!variantType) throw new Error(`TypeError: Union ${fmt(ctx, resolvedTarget)} has no variant ${c.tag}`);\n\n                    // For v0, assume 1 var binds to payload.\n                    if (vars.length === 1) {\n                        newEnv.set(vars[0], variantType);\n                    } else if (vars.length === 0) {\n                        // Unit payload or ignored\n                    } else {\n                        throw new Error(`Match case ${c.tag} expects 1 variable (payload binding)`);\n                    }\n                }\n\n                const body = check(ctx, c.body, newEnv, retType || expectedType);\n                if (retType) expectType(ctx, retType, body.type, \"Match arms mismatch\");\n                else retType = body.type;\n                joinedEff = joinEffects(joinedEff, body.eff);\n            }\n        } else {\n            throw new Error(`Match target must be Option, Result, List, or Union (got ${resolvedTarget.type})`);\n        }\n        return { type: retType!, eff: joinedEff };\n    }\n\n    throw new Error(`Internal: checkControl called on non-control expr ${expr.kind}`);\n}\n\nexport function checkLambda(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind !== 'Lambda') throw new Error(\"Internal: checkLambda called on non-Lambda\");\n\n    const newEnv = new Map(env);\n\n    // Add args to env\n    const argTypes: IrisType[] = [];\n    for (const arg of expr.args) {\n        newEnv.set(arg.name, arg.type);\n        argTypes.push(arg.type);\n    }\n\n    // Check body\n    const bodyRes = check(ctx, expr.body, newEnv, expr.ret);\n    expectType(ctx, expr.ret, bodyRes.type, \"Lambda body type mismatch\");\n\n    // Check effect\n    // If declared eff is !Pure, body must be !Pure\n    // If declared is !IO, body can be !Pure or !IO\n    // Similar for !Net -> !IO -> !Pure\n    // Actually, we should use joinEffects or sub-effect check logic.\n    // For now, strict equality or sub-effect.\n    // Assuming simple sub-effect logic:\n    // !Pure <= !IO <= !Net\n\n    // Check effect compatibility\n    // if body has 'eff', can we define it as 'expr.eff'?\n    // e.g. body !Pure, expr !Pure -> OK\n    // body !IO, expr !Pure -> Error\n\n    // Helper to check if actual fits in declared\n    const canEffectFit = (actual: IrisEffect, declared: IrisEffect): boolean => {\n        if (declared === '!Any') return true;\n        if (declared === '!Net') return ['!Pure', '!IO', '!Net', '!Infer'].includes(actual); // Infer usually means IO?\n        if (declared === '!IO') return ['!Pure', '!IO', '!Infer'].includes(actual);\n        if (declared === '!Pure') return actual === '!Pure';\n        return false;\n    };\n\n    // Note: !Infer from body means it's likely impure or IO if it called something unknown, \n    // but if it's purely inferred as Pure, it's Pure.\n    // However, body checking returns concrete effect usually.\n\n    if (!canEffectFit(bodyRes.eff, expr.eff)) {\n        // Allow !Infer to pass if body is actually pure?\n        // If bodyRes.eff is !Infer, we might assume it fits? No, usually !Infer means \"could differ\".\n        // But here we are strict.\n        throw new Error(`Type Error: Lambda declared ${expr.eff} but body is ${bodyRes.eff}`);\n    }\n\n    return {\n        type: { type: 'Fn', args: argTypes, ret: expr.ret, eff: expr.eff },\n        eff: '!Pure' // Creating a lambda is Pure\n    };\n}\n", "\nimport { Expr, IrisType, IrisEffect } from '../../types';\nimport { TypeCheckerContext, CheckFn } from '../context';\nimport { resolve, joinEffects, expectType, fmt } from '../utils';\n\nexport function checkData(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind === 'Record') {\n        const fields: Record<string, IrisType> = {};\n        let eff: IrisEffect = '!Pure';\n\n        let expectedFields: Record<string, IrisType> | undefined;\n        if (expectedType) {\n            const resolved = resolve(ctx, expectedType);\n            if (resolved.type === 'Record') {\n                expectedFields = resolved.fields;\n            }\n        }\n\n        // expr.fields is Expr[] (List of Tuples: (key, value))\n        if (!Array.isArray(expr.fields)) {\n            throw new Error(\"Compiler Error: Record fields must be an array of Tuples\");\n        }\n\n        for (const fieldExpr of expr.fields) {\n            if (fieldExpr.kind !== 'Tuple' || fieldExpr.items.length !== 2) {\n                throw new Error(\"TypeError: Record field must be a Tuple (key, value)\");\n            }\n            const keyExpr = fieldExpr.items[0];\n            const valExpr = fieldExpr.items[1];\n\n            // Key must be a string literal for static type checking\n            if (keyExpr.kind !== 'Literal' || keyExpr.value.kind !== 'Str') {\n                throw new Error(\"TypeError: Record keys must be string literals provided directly\");\n            }\n            const key = keyExpr.value.value;\n\n            const expectedFieldType = expectedFields ? expectedFields[key] : undefined;\n            const res = check(ctx, valExpr, env, expectedFieldType);\n\n            fields[key] = res.type;\n            eff = joinEffects(eff, res.eff);\n        }\n        return { type: { type: 'Record', fields }, eff };\n    }\n\n    if (expr.kind === 'Tagged') {\n        // (tag \"Name\" (val))\n        let expectHint: IrisType | undefined;\n        let resolvedExpect: IrisType | undefined;\n\n        if (expectedType) {\n            resolvedExpect = resolve(ctx, expectedType);\n            if (resolvedExpect.type === 'Union') {\n                const variantType = resolvedExpect.variants[expr.tag];\n                if (variantType) {\n                    expectHint = variantType;\n                }\n            } else if (resolvedExpect.type === 'Result') {\n                if (expr.tag === 'Ok') expectHint = resolvedExpect.ok;\n                else if (expr.tag === 'Err') expectHint = resolvedExpect.err;\n            } else if (resolvedExpect.type === 'Option') {\n                if (expr.tag === 'Some') expectHint = resolvedExpect.inner;\n            }\n        }\n\n        const valRes = check(ctx, expr.value, env, expectHint);\n\n        if (resolvedExpect) {\n            if (resolvedExpect.type === 'Union') {\n                if (resolvedExpect.variants[expr.tag]) return { type: expectedType!, eff: valRes.eff };\n            } else if (resolvedExpect.type === 'Result') {\n                if (expr.tag === 'Ok') return { type: expectedType!, eff: valRes.eff };\n                if (expr.tag === 'Err') return { type: expectedType!, eff: valRes.eff };\n            } else if (resolvedExpect.type === 'Option') {\n                if (expr.tag === 'Some') return { type: expectedType!, eff: valRes.eff };\n                if (expr.tag === 'None') return { type: expectedType!, eff: valRes.eff };\n            }\n        }\n\n        const retType: IrisType = { type: 'Union', variants: { [expr.tag]: valRes.type } };\n        return { type: retType, eff: valRes.eff };\n    }\n\n    if (expr.kind === 'Tuple') {\n        const items: IrisType[] = [];\n        let eff: IrisEffect = '!Pure';\n\n        let expectedItems: IrisType[] | undefined;\n        if (expectedType) {\n            const resolved = resolve(ctx, expectedType);\n            if (resolved.type === 'Tuple') {\n                expectedItems = resolved.items;\n            }\n        }\n\n        for (let i = 0; i < expr.items.length; i++) {\n            const item = expr.items[i];\n            const expect = expectedItems ? expectedItems[i] : undefined;\n            const res = check(ctx, item, env, expect);\n            items.push(res.type);\n            eff = joinEffects(eff, res.eff);\n        }\n\n        const retType: IrisType = { type: 'Tuple', items };\n        if (expectedType && fmt(ctx, expectedType).includes(\"List Str\")) {\n            // console.log(\"TUPLE returning:\", fmt(ctx, retType));\n        }\n        return { type: retType, eff };\n    }\n\n    if (expr.kind === 'List') {\n        const items: IrisType[] = [];\n        let eff: IrisEffect = '!Pure';\n\n        let expectedInner: IrisType | undefined;\n        if (expectedType) {\n            const resolved = resolve(ctx, expectedType);\n            if (resolved.type === 'List') {\n                expectedInner = resolved.inner;\n            }\n        }\n\n        if (expr.items.length === 0) {\n            if (expectedInner) {\n                return { type: { type: 'List', inner: expectedInner }, eff: '!Pure' };\n            }\n            if (expr.typeArg) {\n                return { type: { type: 'List', inner: expr.typeArg }, eff: '!Pure' };\n            }\n            return { type: { type: 'List', inner: { type: 'I64' } }, eff: '!Pure' };\n        }\n\n        // If items exist, infer from first or expected\n        let innerType = expectedInner;\n\n        for (const item of expr.items) {\n            const res = check(ctx, item, env, innerType);\n            if (!innerType) innerType = res.type;\n            else expectType(ctx, innerType, res.type, \"List item type mismatch\");\n            eff = joinEffects(eff, res.eff);\n        }\n\n        return { type: { type: 'List', inner: innerType! }, eff };\n    }\n\n    throw new Error(`Internal: checkData called on non-data expr ${expr.kind}`);\n}\n", "\nimport { Expr, IrisType, IrisEffect } from '../../types';\nimport { TypeCheckerContext, CheckFn } from '../context';\nimport { resolve, joinEffects, expectType, qualifyType } from '../utils';\n\nexport function checkCall(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind === 'Var') {\n        if (env.has(expr.name)) return { type: env.get(expr.name)!, eff: '!Pure' };\n        if (ctx.constants.has(expr.name)) return { type: ctx.constants.get(expr.name)!, eff: '!Pure' };\n\n        // Dot access for records\n        if (expr.name.includes('.')) {\n            const parts = expr.name.split('.');\n            let currentType = env.get(parts[0]) || ctx.constants.get(parts[0]);\n            if (currentType) {\n                for (let i = 1; i < parts.length; i++) {\n                    currentType = resolve(ctx, currentType!);\n                    if (currentType.type === 'Tuple') {\n                        const index = parseInt(parts[i]);\n                        if (isNaN(index)) throw new Error(`TypeError: Tuple index must be number: ${parts[i]}`);\n                        if (!currentType.items) throw new Error(\"Internal: Tuple missing items\");\n                        if (index < 0 || index >= currentType.items.length) throw new Error(`TypeError: Tuple index out of bounds: ${index}`);\n                        currentType = currentType.items[index];\n                    } else {\n                        if (currentType.type !== 'Record') throw new Error(`TypeError: Cannot access field ${parts[i]} of non-record ${parts.slice(0, i).join('.')}`);\n                        if (!currentType.fields) throw new Error(\"Internal: Record missing fields\");\n                        const fields: Record<string, IrisType> = currentType.fields;\n                        const fieldType: IrisType = fields[parts[i]];\n                        if (!fieldType) throw new Error(`TypeError: Unknown field ${parts[i]} in record`);\n                        currentType = fieldType;\n                    }\n                }\n                return { type: currentType!, eff: '!Pure' };\n            }\n        }\n\n        throw new Error(`TypeError: Unknown variable: ${expr.name}`);\n    }\n\n    if (expr.kind === 'Call') {\n        let func = ctx.functions.get(expr.fn);\n\n        if (!func && expr.fn.includes('.')) {\n            // Try to resolve imported function\n            const [alias, fname] = expr.fn.split('.');\n            const importDecl = ctx.currentProgram?.imports.find(i => i.alias === alias);\n            if (importDecl && ctx.resolver) {\n                const importedProg = ctx.resolver(importDecl.path);\n                if (importedProg) {\n                    const targetDef = importedProg.defs.find(d => (d.kind === 'DefFn' || d.kind === 'DefTool') && d.name === fname) as any;\n                    if (targetDef) {\n                        const exportedTypes = new Set(importedProg.defs.filter((d: any) => d.kind === 'TypeDef').map((d: any) => d.name));\n                        func = {\n                            args: targetDef.args.map((a: any) => qualifyType(ctx, a.type, alias, exportedTypes)),\n                            ret: qualifyType(ctx, targetDef.ret, alias, exportedTypes),\n                            eff: targetDef.eff\n                        };\n                    }\n                }\n            }\n        }\n\n        if (!func) throw new Error(`TypeError: Unknown function call: ${expr.fn}`);\n        if (expr.args.length !== func.args.length) throw new Error(`TypeError: Arity mismatch for ${expr.fn}`);\n        let eff: IrisEffect = '!Pure';\n        for (let i = 0; i < expr.args.length; i++) {\n            const arg = check(ctx, expr.args[i], env, func.args[i]);\n            expectType(ctx, func.args[i], arg.type, `Argument ${i} mismatch`);\n            eff = joinEffects(eff, arg.eff);\n        }\n        // Handle !Infer: if callee is !Infer, treat as !Any (pessimistic) unless we know better.\n        const callEff = func.eff === '!Infer' ? '!Any' : func.eff;\n        return { type: func.ret, eff: joinEffects(eff, callEff) };\n    }\n\n    throw new Error(`Internal: checkCall called on non-callable expr ${expr.kind}`);\n}\n", "\nimport { Expr, IrisType, IrisEffect } from '../../types';\nimport { TypeCheckerContext, CheckFn } from '../context';\nimport { resolve, joinEffects, expectType } from '../utils';\n\nexport function checkIntrinsic(check: CheckFn, ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    if (expr.kind !== 'Intrinsic') throw new Error(\"Internal: checkIntrinsic called on non-Intrinsic\");\n\n    // Pre-check for constructors to pass hints\n    let argHints: (IrisType | undefined)[] = [];\n    if (expectedType) {\n        const resolved = resolve(ctx, expectedType);\n        if (expr.op === 'Ok' && resolved.type === 'Result') argHints = [resolved.ok];\n        else if (expr.op === 'Err' && resolved.type === 'Result') argHints = [resolved.err];\n        else if (expr.op === 'Some' && resolved.type === 'Option') argHints = [resolved.inner];\n        else if (expr.op === 'cons' && resolved.type === 'List') argHints = [resolved.inner, resolved];\n    }\n\n    const argTypes: IrisType[] = [];\n    let joinedEff: IrisEffect = '!Pure';\n    for (let i = 0; i < expr.args.length; i++) {\n        const arg = expr.args[i];\n        const hint = argHints[i];\n        const res = check(ctx, arg, env, hint);\n\n        argTypes.push(res.type);\n        joinedEff = joinEffects(joinedEff, res.eff);\n    }\n\n    // Pure Ops\n    if (['+', '-', '*', '/', '%', '<', '<=', '=', '>=', '>'].includes(expr.op)) {\n        if (['+', '-', '*', '/', '%'].includes(expr.op)) {\n            for (let i = 0; i < argTypes.length; i++) {\n                if (argTypes[i].type !== 'I64') {\n                    throw new Error(`TypeError: Type Error in ${expr.op} operand ${i + 1}: Expected I64, got ${argTypes[i].type}`);\n                }\n            }\n            if (argTypes.length !== 2) throw new Error(`${expr.op} expects 2 operands`);\n            return { type: { type: 'I64' }, eff: joinedEff };\n        }\n        return { type: ['<=', '<', '=', '>=', '>'].includes(expr.op) ? { type: 'Bool' } : { type: 'I64' }, eff: joinedEff };\n    }\n\n    if (['&&', '||'].includes(expr.op)) {\n        for (let i = 0; i < argTypes.length; i++) {\n            if (argTypes[i].type !== 'Bool') throw new Error(`TypeError: Expected Bool for ${expr.op}`);\n        }\n        return { type: { type: 'Bool' }, eff: joinedEff };\n    }\n    if (expr.op === '!') {\n        if (argTypes.length !== 1 || argTypes[0].type !== 'Bool') throw new Error(\"TypeError: ! expects 1 Bool\");\n        return { type: { type: 'Bool' }, eff: joinedEff };\n    }\n\n    if (expr.op === 'Some') return { type: { type: 'Option', inner: argTypes[0] }, eff: joinedEff };\n\n    if (expr.op === 'Ok') {\n        let errType: IrisType = { type: 'Str' };\n        if (expectedType) {\n            const resolved = resolve(ctx, expectedType);\n            if (resolved.type === 'Result') errType = resolved.err;\n        }\n        return { type: { type: 'Result', ok: argTypes[0], err: errType }, eff: joinedEff };\n    }\n    if (expr.op === 'Err') {\n        let okType: IrisType = { type: 'I64' };\n        if (expectedType) {\n            const resolved = resolve(ctx, expectedType);\n            if (resolved.type === 'Result') okType = resolved.ok;\n        }\n        return { type: { type: 'Result', ok: okType, err: argTypes[0] }, eff: joinedEff };\n    }\n    if (expr.op === 'cons') return { type: { type: 'List', inner: argTypes[0] }, eff: joinedEff };\n\n    if (expr.op.startsWith('io.')) {\n        joinedEff = joinEffects(joinedEff, '!IO');\n        if (expr.op === 'io.read_file') return { type: { type: 'Result', ok: { type: 'Str' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'io.write_file') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'io.file_exists') return { type: { type: 'Bool' }, eff: joinedEff };\n        if (expr.op === 'io.read_dir') return { type: { type: 'Result', ok: { type: 'List', inner: { type: 'Str' } }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'io.print') return { type: { type: 'I64' }, eff: joinedEff };\n    }\n\n    if (expr.op.startsWith('sys.')) {\n        joinedEff = joinEffects(joinedEff, '!IO');\n        if (expr.op === 'sys.self') {\n            if (argTypes.length !== 0) throw new Error(\"sys.self expects 0 arguments\");\n            return { type: { type: 'I64' }, eff: joinedEff };\n        }\n        if (expr.op === 'sys.recv') {\n            if (argTypes.length !== 0) throw new Error(\"sys.recv expects 0 arguments\");\n            return { type: { type: 'Str' }, eff: joinedEff };\n        }\n        if (expr.op === 'sys.spawn') {\n            if (argTypes.length !== 1) throw new Error(\"sys.spawn expects 1 argument\");\n            if (argTypes[0].type !== 'Str') throw new Error(\"sys.spawn expects Str function name\");\n            return { type: { type: 'I64' }, eff: joinedEff };\n        }\n        if (expr.op === 'sys.sleep') {\n            if (argTypes.length !== 1) throw new Error(\"sys.sleep expects 1 argument\");\n            if (argTypes[0].type !== 'I64') throw new Error(\"sys.sleep expects I64 ms\");\n            return { type: { type: 'Bool' }, eff: joinedEff };\n        }\n        if (expr.op === 'sys.send') {\n            if (argTypes.length !== 2) throw new Error(\"sys.send expects 2 arguments (pid, msg)\");\n            const [pid, msg] = argTypes;\n            if (pid.type !== 'I64') throw new Error(\"sys.send expects I64 pid\");\n            if (msg.type !== 'Str') throw new Error(\"sys.send expects Str msg\");\n            return { type: { type: 'Bool' }, eff: joinedEff };\n        }\n        if (expr.op === 'sys.args') {\n            if (argTypes.length !== 0) throw new Error(\"sys.args expects 0 arguments\");\n            return { type: { type: 'List', inner: { type: 'Str' } }, eff: joinedEff };\n        }\n    }\n\n    if (expr.op.startsWith('net.')) {\n        joinedEff = joinEffects(joinedEff, '!Net');\n        if (expr.op === 'net.listen') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'net.accept') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'net.read') return { type: { type: 'Result', ok: { type: 'Str' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'net.write') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'net.close') return { type: { type: 'Result', ok: { type: 'Bool' }, err: { type: 'Str' } }, eff: joinedEff };\n        if (expr.op === 'net.connect') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n    }\n\n    if (expr.op.startsWith('str.')) {\n        if (expr.op === 'str.len') {\n            if (argTypes.length !== 1) throw new Error(\"str.len expects 1 arg\");\n            if (argTypes[0].type !== 'Str') throw new Error(\"str.len expects Str\");\n            return { type: { type: 'I64' }, eff: joinedEff };\n        }\n        if (expr.op === 'str.concat') return { type: { type: 'Str' }, eff: joinedEff };\n        if (expr.op === 'str.contains' || expr.op === 'str.ends_with') return { type: { type: 'Bool' }, eff: joinedEff };\n        if (expr.op === 'str.get') {\n            if (argTypes.length !== 2) throw new Error(\"str.get expects 2 args (str, index)\");\n            if (argTypes[0].type !== 'Str') throw new Error(\"str.get expects Str\");\n            if (argTypes[1].type !== 'I64') throw new Error(\"str.get expects I64 index\");\n            return { type: { type: 'Option', inner: { type: 'I64' } }, eff: joinedEff };\n        }\n        if (expr.op === 'str.substring') {\n            if (argTypes.length !== 3) throw new Error(\"str.substring expects 3 args (str, start, end)\");\n            if (argTypes[0].type !== 'Str') throw new Error(\"str.substring expects Str\");\n            if (argTypes[1].type !== 'I64') throw new Error(\"str.substring expects I64 start\");\n            if (argTypes[2].type !== 'I64') throw new Error(\"str.substring expects I64 end\");\n            return { type: { type: 'Str' }, eff: joinedEff };\n        }\n        if (expr.op === 'str.from_code') {\n            if (argTypes.length !== 1) throw new Error(\"str.from_code expects 1 arg (code)\");\n            if (argTypes[0].type !== 'I64') throw new Error(\"str.from_code expects I64\");\n            return { type: { type: 'Str' }, eff: joinedEff };\n        }\n        if (expr.op === 'str.index_of') {\n            if (argTypes.length !== 2) throw new Error(\"str.index_of expects 2 args (str, substr)\");\n            if (argTypes[0].type !== 'Str') throw new Error(\"str.index_of expects Str\");\n            if (argTypes[1].type !== 'Str') throw new Error(\"str.index_of expects Str substring\");\n            return { type: { type: 'Option', inner: { type: 'I64' } }, eff: joinedEff };\n        }\n    }\n\n    if (expr.op.startsWith('map.')) {\n        if (expr.op === 'map.make') {\n            if (argTypes.length !== 2) throw new Error(\"map.make expects 2 arguments (key_witness, value_witness)\");\n\n            if (expectedType) {\n                const resolved = resolve(ctx, expectedType);\n                if (resolved.type === 'Map') return { type: expectedType, eff: joinedEff };\n            }\n\n            return { type: { type: 'Map', key: argTypes[0], value: argTypes[1] }, eff: joinedEff };\n        }\n        if (expr.op === 'map.put') {\n            if (argTypes.length !== 3) throw new Error(\"map.put expects 3 args (map, key, value)\");\n            const [m, k, v] = argTypes;\n            if (m.type !== 'Map') throw new Error(\"map.put expects Map as first arg\");\n            expectType(ctx, m.key, k, \"map.put key mismatch\");\n            expectType(ctx, m.value, v, \"map.put value mismatch\");\n            return { type: m, eff: joinedEff };\n        }\n        if (expr.op === 'map.get') {\n            if (argTypes.length !== 2) throw new Error(\"map.get expects 2 args (map, key)\");\n            const [m, k] = argTypes;\n            if (m.type !== 'Map') throw new Error(\"map.get expects Map as first arg\");\n            expectType(ctx, m.key, k, \"map.get key mismatch\");\n            return { type: { type: 'Option', inner: m.value }, eff: joinedEff };\n        }\n        if (expr.op === 'map.contains') {\n            if (argTypes.length !== 2) throw new Error(\"map.contains expects 2 args (map, key)\");\n            const [m, k] = argTypes;\n            if (m.type !== 'Map') throw new Error(\"map.contains expects Map as first arg\");\n            expectType(ctx, m.key, k, \"map.contains key mismatch\");\n            return { type: { type: 'Bool' }, eff: joinedEff };\n        }\n        if (expr.op === 'map.keys') {\n            if (argTypes.length !== 1) throw new Error(\"map.keys expects 1 arg (map)\");\n            const m = argTypes[0];\n            if (m.type !== 'Map') throw new Error(\"map.keys expects Map\");\n            return { type: { type: 'List', inner: m.key }, eff: joinedEff };\n        }\n    }\n\n    if (expr.op.startsWith('list.')) {\n        if (expr.op === 'list.length') {\n            if (argTypes.length !== 1) throw new Error(\"list.length expects 1 arg (list)\");\n            if (argTypes[0].type !== 'List') throw new Error(\"list.length expects List\");\n            return { type: { type: 'I64' }, eff: joinedEff };\n        }\n        if (expr.op === 'list.get') {\n            if (argTypes.length !== 2) throw new Error(\"list.get expects 2 args (list, index)\");\n            const [l, idx] = argTypes;\n            if (l.type !== 'List') throw new Error(\"list.get expects List\");\n            if (idx.type !== 'I64') throw new Error(\"list.get expects I64 index\");\n            return { type: { type: 'Option', inner: l.inner }, eff: joinedEff };\n        }\n        if (expr.op === 'list.concat') {\n            if (argTypes.length !== 2) throw new Error(\"list.concat expects 2 args (list1, list2)\");\n            const [l1, l2] = argTypes;\n            if (l1.type !== 'List' || l2.type !== 'List') throw new Error(\"list.concat expects two Lists\");\n            return { type: l1, eff: joinedEff };\n        }\n        if (expr.op === 'list.unique') {\n            if (argTypes.length !== 1) throw new Error(\"list.unique expects 1 arg (list)\");\n            return { type: argTypes[0], eff: joinedEff };\n        }\n    }\n\n    if (expr.op === 'i64.from_string') {\n        if (argTypes.length !== 1) throw new Error(\"i64.from_string expects 1 arg (Str)\");\n        if (argTypes[0].type !== 'Str') throw new Error(\"i64.from_string expects Str\");\n        return { type: { type: 'I64' }, eff: joinedEff };\n    }\n\n    if (expr.op === 'i64.to_string') {\n        if (argTypes.length !== 1) throw new Error(\"i64.to_string expects 1 arg (I64)\");\n        if (argTypes[0].type !== 'I64') throw new Error(\"i64.to_string expects I64\");\n        return { type: { type: 'Str' }, eff: joinedEff };\n    }\n\n    if (expr.op === 'tuple.get') {\n        if (argTypes.length !== 2) throw new Error(\"tuple.get expects 2 args (tuple, index)\");\n        const [t, idx] = argTypes;\n        if (t.type !== 'Tuple') throw new Error(\"tuple.get expects Tuple\");\n        if (idx.type !== 'I64') throw new Error(\"tuple.get expects I64 index\");\n        if (expr.args[1].kind === 'Literal' && expr.args[1].value.kind === 'I64') {\n            const i = Number(expr.args[1].value.value);\n            if (i < 0 || i >= t.items.length) throw new Error(\"tuple.get index out of bounds\");\n            return { type: t.items[i], eff: joinedEff };\n        }\n        throw new Error(\"tuple.get requires literal index for type safety\");\n    }\n\n    if (expr.op === 'record.get') {\n        if (argTypes.length !== 2) throw new Error(\"record.get expects 2 args\");\n        const [rec, k] = argTypes;\n        if (rec.type !== 'Record') throw new Error(\"record.get expects Record\");\n        if (k.type !== 'Str') throw new Error(\"record.get expects Str key\");\n\n        if (expr.args[1].kind === 'Literal' && expr.args[1].value.kind === 'Str') {\n            const keyVal = expr.args[1].value.value;\n            const fieldType = rec.fields[keyVal];\n            if (!fieldType) throw new Error(`Record has no field '${keyVal}'`);\n            return { type: fieldType, eff: joinedEff };\n        }\n        throw new Error(\"record.get requires literal string key\");\n    }\n\n    if (expr.op === 'http.parse_request') {\n        joinedEff = joinEffects(joinedEff, '!Pure');\n        const headerType: IrisType = { type: 'Record', fields: { key: { type: 'Str' }, val: { type: 'Str' } } };\n        const httpReqType: IrisType = { type: 'Record', fields: { method: { type: 'Str' }, path: { type: 'Str' }, headers: { type: 'List', inner: headerType }, body: { type: 'Str' } } };\n        return { type: { type: 'Result', ok: httpReqType, err: { type: 'Str' } }, eff: joinedEff };\n    }\n\n    if (expr.op === 'http.parse_response') {\n        joinedEff = joinEffects(joinedEff, '!Pure');\n        const headerType: IrisType = { type: 'Record', fields: { key: { type: 'Str' }, val: { type: 'Str' } } };\n        const httpResType: IrisType = { type: 'Record', fields: { version: { type: 'Str' }, status: { type: 'I64' }, headers: { type: 'List', inner: headerType }, body: { type: 'Str' } } };\n        return { type: { type: 'Result', ok: httpResType, err: { type: 'Str' } }, eff: joinedEff };\n    }\n\n    throw new Error(`Unknown intrinsic: ${expr.op}`);\n}\n", "\nimport { Expr, IrisType, IrisEffect } from '../types';\nimport { TypeCheckerContext } from './context';\nimport { checkLiteral, checkControl, checkLambda, checkData, checkCall, checkIntrinsic } from './checks';\n\nexport function checkExprFull(ctx: TypeCheckerContext, expr: Expr, env: Map<string, IrisType>, expectedType?: IrisType): { type: IrisType, eff: IrisEffect } {\n    switch (expr.kind) {\n        case 'Literal': return checkLiteral(checkExprFull, ctx, expr, env, expectedType);\n\n        case 'Var':\n        case 'Call':\n            return checkCall(checkExprFull, ctx, expr, env, expectedType);\n\n        case 'Let':\n        case 'If':\n        case 'Match':\n            return checkControl(checkExprFull, ctx, expr, env, expectedType);\n\n        case 'Record':\n        case 'Tagged':\n        case 'Tuple':\n        case 'List':\n            return checkData(checkExprFull, ctx, expr, env, expectedType);\n\n        case 'Intrinsic': return checkIntrinsic(checkExprFull, ctx, expr, env, expectedType);\n\n        case 'Lambda': return checkLambda(checkExprFull, ctx, expr, env, expectedType);\n\n        default:\n            throw new Error(`Unimplemented check for ${(expr as any).kind}`);\n    }\n}\n", "\nimport { Program, IrisType, IrisEffect, ModuleResolver } from '../types';\nimport { TypeCheckerContext } from './context';\nimport { checkExprFull } from './check-expr';\nimport { qualifyType, checkEffectSubtype, expectType } from './utils';\n\nexport class TypeChecker implements TypeCheckerContext {\n    public functions = new Map<string, { args: IrisType[], ret: IrisType, eff: IrisEffect }>();\n    public constants = new Map<string, IrisType>();\n    public types = new Map<string, IrisType>();\n    public currentProgram?: Program;\n\n    constructor(public resolver?: ModuleResolver) { }\n\n    check(program: Program) {\n        this.currentProgram = program;\n\n        // Pre-pass: load imported types\n        if (this.resolver) {\n            for (const imp of program.imports) {\n                const mod = this.resolver(imp.path);\n                if (mod) {\n                    const exportedTypes = new Set(mod.defs.filter(d => d.kind === 'TypeDef').map(d => d.name));\n                    for (const def of mod.defs) {\n                        if (def.kind === 'TypeDef') {\n                            const qualified = qualifyType(this, def.type, imp.alias, exportedTypes);\n                            this.types.set(`${imp.alias}.${def.name}`, qualified);\n                        }\n                    }\n                }\n            }\n        }\n\n        // First pass: collect signatures\n        for (const def of program.defs) {\n            if (def.kind === 'DefConst') {\n                this.constants.set(def.name, def.type);\n            } else if (def.kind === 'DefFn' || def.kind === 'DefTool') {\n                const argNames = new Set<string>();\n                for (const a of def.args) {\n                    if (argNames.has(a.name)) throw new Error(`TypeError: Duplicate argument name: ${a.name}`);\n                    argNames.add(a.name);\n                }\n                this.functions.set(def.name, {\n                    args: def.args.map(a => a.type),\n                    ret: def.ret,\n                    eff: def.eff\n                });\n            } else if (def.kind === 'TypeDef') {\n                this.types.set(def.name, def.type);\n            }\n        }\n\n        // Second pass: check bodies\n        for (const def of program.defs) {\n            if (def.kind === 'DefConst') {\n                const { type, eff } = checkExprFull(this, def.value, new Map());\n                expectType(this, def.type, type, `Constant ${def.name} type mismatch`);\n                checkEffectSubtype(this, eff, '!Pure', `Constant ${def.name} must be Pure`);\n            } else if (def.kind === 'DefFn') {\n                const fnType = this.functions.get(def.name)!;\n                const env = new Map<string, IrisType>();\n                for (let i = 0; i < def.args.length; i++) {\n                    env.set(def.args[i].name, def.args[i].type);\n                }\n                if (def.name === 'type_check') console.log(\"Checking type_check. Ret:\", JSON.stringify(def.ret));\n\n                const { type: bodyType, eff: bodyEff } = checkExprFull(this, def.body, env, def.ret);\n\n                expectType(this, def.ret, bodyType, `Function ${def.name} return type mismatch`);\n\n                if (def.eff === '!Infer') {\n                    // Update registry with inferred effect logic if we supported two-pass inference or similar.\n                    // For now, allow it to pass.\n                    // In a real system we'd update this.functions but since we already visited calls,\n                    // we might need a fixpoint. For v0.2 simple scope, we just let it accept.\n                    this.functions.set(def.name, { ...fnType, eff: bodyEff });\n                } else {\n                    checkEffectSubtype(this, bodyEff, def.eff, `Function ${def.name}`);\n                }\n            } else if (def.kind === 'DefTool') {\n                // No body to check; signature is validated in the first pass.\n            } else if (def.kind === 'TypeDef') {\n                // Nothing to check for body\n            }\n        }\n    }\n}\n", "\nimport { IFileSystem, INetwork } from './interfaces';\n\nexport class MockFileSystem implements IFileSystem {\n    constructor(private data: Record<string, string>) { }\n    readFile(path: string) { return this.data[path] ?? null; }\n    writeFile(path: string, content: string) { this.data[path] = content; return true; }\n    exists(path: string) { return path in this.data; }\n    readDir(path: string) {\n        if (path === '.') return Object.keys(this.data);\n        return Object.keys(this.data).filter(k => k.startsWith(path + '/'));\n    }\n}\n\nexport class MockNetwork implements INetwork {\n    async listen(port: number) { return 1; }\n    async accept(h: number) { return 2; } // Return a client handle\n    async read(h: number) { return \"GET / HTTP/1.1\\r\\n\\r\\n\"; }\n    async write(h: number, d: string) { return true; }\n    async close(h: number) { return true; }\n    async connect(host: string, port: number) { return 3; }\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\n\nexport function evalMath(op: IntrinsicOp, args: Value[]): Value {\n    // Comparators\n    if (op === '=') {\n        const v1 = args[0] as any;\n        const v2 = args[1] as any;\n\n        const r1 = typeof v1 === 'bigint' ? { kind: 'I64', value: v1 } : (typeof v1 === 'string' ? { kind: 'Str', value: v1 } : v1);\n        const r2 = typeof v2 === 'bigint' ? { kind: 'I64', value: v2 } : (typeof v2 === 'string' ? { kind: 'Str', value: v2 } : v2);\n\n        if (r1.kind === 'I64' && r2.kind === 'I64') return { kind: 'Bool', value: r1.value === r2.value };\n        if (r1.kind === 'Str' && r2.kind === 'Str') return { kind: 'Bool', value: r1.value === r2.value };\n        if (r1.kind === 'Bool' && r2.kind === 'Bool') return { kind: 'Bool', value: r1.value === r2.value };\n        return { kind: 'Bool', value: false };\n    }\n\n    if (['+', '-', '*', '/', '%', '<=', '<', '>=', '>'].includes(op)) {\n        let v1 = args[0] as any;\n        let v2 = args[1] as any;\n\n        const a = typeof v1 === 'bigint' ? v1 : (v1.kind === 'I64' ? v1.value : null);\n        const b = typeof v2 === 'bigint' ? v2 : (v2.kind === 'I64' ? v2.value : null);\n\n        if (a === null || b === null) throw new Error(`Math expects I64 for ${op}, got ${typeof v1 === 'bigint' ? 'bigint' : v1.kind} and ${typeof v2 === 'bigint' ? 'bigint' : v2.kind} `);\n\n        const na = a as bigint;\n        const nb = b as bigint;\n\n        switch (op) {\n            case '+': return { kind: 'I64', value: na + nb };\n            case '-': return { kind: 'I64', value: na - nb };\n            case '*': return { kind: 'I64', value: na * nb };\n            case '%': {\n                if (nb === 0n) throw new Error(\"Modulo by zero\");\n                return { kind: 'I64', value: na % nb };\n            }\n            case '/': {\n                if (nb === 0n) throw new Error(\"Division by zero\");\n                return { kind: 'I64', value: na / nb };\n            }\n            case '<=': return { kind: 'Bool', value: na <= nb };\n            case '<': return { kind: 'Bool', value: na < nb };\n            case '>=': return { kind: 'Bool', value: na >= nb };\n            case '>': return { kind: 'Bool', value: na > nb };\n        }\n    }\n\n    if (op === '&&') {\n        const v1 = args[0]; const v2 = args[1];\n        if (v1.kind !== 'Bool' || v2.kind !== 'Bool') throw new Error(\"&& expects Bool\");\n        return { kind: 'Bool', value: v1.value && v2.value };\n    }\n    if (op === '||') {\n        const v1 = args[0]; const v2 = args[1];\n        if (v1.kind !== 'Bool' || v2.kind !== 'Bool') throw new Error(\"|| expects Bool\");\n        return { kind: 'Bool', value: v1.value || v2.value };\n    }\n    if (op === '!') {\n        const v1 = args[0];\n        if (v1.kind !== 'Bool') throw new Error(\"! expects Bool\");\n        return { kind: 'Bool', value: !v1.value };\n    }\n\n    if (op === 'i64.from_string') {\n        const val = args[0];\n        if (val.kind !== 'Str') throw new Error(\"i64.from_string expects Str\");\n        if (val.value === \"\") throw new Error(\"i64.from_string: empty string\");\n        return { kind: 'I64', value: BigInt(val.value) };\n    }\n\n    if (op === 'i64.to_string') {\n        const val = args[0] as any;\n        if (typeof val === 'bigint') return { kind: 'Str', value: val.toString() };\n        if (val.kind !== 'I64') throw new Error(\"i64.to_string expects I64\");\n        return { kind: 'Str', value: val.value.toString() };\n    }\n\n    throw new Error(`Unknown math op: ${op}`);\n}\n", "\nexport class ProcessManager {\n    static instance = new ProcessManager();\n\n    private nextPid = 1;\n    private mailboxes = new Map<number, string[]>();\n    private receivers = new Map<number, ((msg: string) => void)[]>();\n\n    reset() {\n        this.nextPid = 1;\n        this.mailboxes.clear();\n        this.receivers.clear();\n    }\n\n    getNextPid(): number {\n        return this.nextPid++;\n    }\n\n    // Spawn a new process context (just registers it)\n    register(pid: number) {\n        this.mailboxes.set(pid, []);\n        this.receivers.set(pid, []);\n    }\n\n    send(toPid: number, msg: string): boolean {\n        if (!this.mailboxes.has(toPid)) return false;\n\n        const waiting = this.receivers.get(toPid);\n        if (waiting && waiting.length > 0) {\n            // Wake up one receiver immediately\n            const resolve = waiting.shift();\n            resolve!(msg);\n        } else {\n            // Queue message\n            this.mailboxes.get(toPid)!.push(msg);\n        }\n        return true;\n    }\n\n    async recv(pid: number): Promise<string> {\n        if (!this.mailboxes.has(pid)) throw new Error(`Process ${pid} not registered`);\n\n        const mailbox = this.mailboxes.get(pid)!;\n        if (mailbox.length > 0) {\n            return mailbox.shift()!;\n        }\n\n        // Suspend\n        return new Promise<string>((resolve) => {\n            const waiting = this.receivers.get(pid)!;\n            waiting.push(resolve);\n        });\n    }\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\nimport { InterpreterContext } from '../context';\nimport { ProcessManager } from '../../runtime/process';\n\nexport async function evalSys(ctx: InterpreterContext, op: IntrinsicOp, args: Value[]): Promise<Value> {\n    if (op === 'sys.self') {\n        return { kind: 'I64', value: BigInt(ctx.pid) };\n    }\n\n    if (op === 'sys.args') {\n        const argsList = ctx.args.map(a => ({ kind: 'Str', value: a } as Value));\n        return { kind: 'List', items: argsList };\n    }\n\n    if (op === 'sys.spawn') {\n        const fnName = args[0];\n        if (fnName.kind !== 'Str') throw new Error(\"sys.spawn expects function name (Str)\");\n\n        const childPid = ctx.spawn(fnName.value);\n        return { kind: 'I64', value: BigInt(childPid) };\n    }\n\n    if (op === 'sys.send') {\n        const pid = args[0];\n        const msg = args[1];\n        if (pid.kind !== 'I64') throw new Error(\"sys.send expects PID (I64)\");\n        if (msg.kind !== 'Str') throw new Error(\"sys.send expects Msg (Str)\");\n\n        const sent = ProcessManager.instance.send(Number(pid.value), msg.value);\n        return { kind: 'Bool', value: sent };\n    }\n\n    if (op === 'sys.recv') {\n        const msg = await ProcessManager.instance.recv(ctx.pid);\n        return { kind: 'Str', value: msg };\n    }\n\n    if (op === 'sys.sleep') {\n        const ms = args[0];\n        if (ms.kind !== 'I64') throw new Error(\"sys.sleep expects I64 ms\");\n        await new Promise(resolve => setTimeout(resolve, Number(ms.value)));\n        return { kind: 'Bool', value: true };\n    }\n\n    throw new Error(`Unknown sys op: ${op}`);\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\nimport { InterpreterContext } from '../context';\n\nexport function evalIo(ctx: InterpreterContext, op: IntrinsicOp, args: Value[]): Value {\n    if (op === 'io.read_file') {\n        const path = args[0];\n        if (path.kind !== 'Str') throw new Error(\"path must be string\");\n        const content = ctx.fs.readFile(path.value);\n        if (content !== null) {\n            return { kind: 'Result', isOk: true, value: { kind: 'Str', value: content } };\n        } else {\n            return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"ENOENT\" } };\n        }\n    }\n\n    if (op === 'io.write_file') {\n        const path = args[0];\n        const content = args[1];\n        if (path.kind !== 'Str') throw new Error(\"path must be string\");\n        if (content.kind !== 'Str') throw new Error(\"content must be string\");\n        ctx.fs.writeFile(path.value, content.value);\n        return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(content.value.length) } };\n    }\n\n    if (op === 'io.file_exists') {\n        const path = args[0];\n        if (path.kind !== 'Str') throw new Error(\"path must be string\");\n        return { kind: 'Bool', value: ctx.fs.exists(path.value) };\n    }\n\n    if (op === 'io.read_dir') {\n        const path = args[0];\n        if (path.kind !== 'Str') throw new Error(\"path must be string\");\n        if (!ctx.fs.readDir) return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Not supported\" } };\n\n        const entries = ctx.fs.readDir(path.value);\n        if (entries === null) return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Directory not found or error\" } };\n\n        const listVal: Value = {\n            kind: 'List',\n            items: entries.map(s => ({ kind: 'Str', value: s }))\n        };\n        return { kind: 'Result', isOk: true, value: listVal };\n    }\n\n    if (op === 'io.print') {\n        const val = args[0];\n        if (val.kind === 'Str') {\n            console.log(val.value);\n        } else if (val.kind === 'I64' || val.kind === 'Bool') {\n            console.log(val.value.toString());\n        } else {\n            console.log(JSON.stringify(val, (k, v) => typeof v === 'bigint' ? v.toString() : v));\n        }\n        return { kind: 'I64', value: 0n };\n    }\n\n    throw new Error(`Unknown io op: ${op}`);\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\nimport { InterpreterContext } from '../context';\n\nexport async function evalNet(ctx: InterpreterContext, op: IntrinsicOp, args: Value[]): Promise<Value> {\n    if (op === 'net.listen') {\n        const port = args[0];\n        if (port.kind !== 'I64') throw new Error(\"net.listen expects I64 port\");\n        const h = await ctx.net.listen(Number(port.value));\n        if (h !== null) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(h) } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Listen failed\" } };\n    }\n    if (op === 'net.accept') {\n        const serverSock = args[0];\n        if (serverSock.kind !== 'I64') throw new Error(\"net.accept expects I64\");\n        const h = await ctx.net.accept(Number(serverSock.value));\n        if (h !== null) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(h) } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Accept failed\" } };\n    }\n    if (op === 'net.read') {\n        const sock = args[0];\n        if (sock.kind !== 'I64') throw new Error(\"net.read expects I64\");\n        const s = await ctx.net.read(Number(sock.value));\n        if (s !== null) return { kind: 'Result', isOk: true, value: { kind: 'Str', value: s } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Read failed\" } };\n    }\n    if (op === 'net.write') {\n        const sock = args[0];\n        const str = args[1];\n        if (sock.kind !== 'I64') throw new Error(\"net.write expects I64\");\n        if (str.kind !== 'Str') throw new Error(\"net.write expects Str\");\n        const s = await ctx.net.write(Number(sock.value), str.value);\n        if (s) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(s ? 1 : 0) } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Write failed\" } };\n    }\n    if (op === 'net.close') {\n        const sock = args[0];\n        if (sock.kind !== 'I64') throw new Error(\"net.close expects I64\");\n        const s = await ctx.net.close(Number(sock.value));\n        if (s) return { kind: 'Result', isOk: true, value: { kind: 'Bool', value: true } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Close failed\" } };\n    }\n    if (op === 'net.connect') {\n        const host = args[0];\n        const port = args[1];\n        if (host.kind !== 'Str') throw new Error(\"net.connect expects Str host\");\n        if (port.kind !== 'I64') throw new Error(\"net.connect expects I64 port\");\n        const h = await ctx.net.connect(host.value, Number(port.value));\n        if (h !== null) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(h) } };\n        return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Connect failed\" } };\n    }\n    throw new Error(`Unknown net op: ${op}`);\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\n\nexport function evalHttp(op: IntrinsicOp, args: Value[]): Value {\n    if (op === 'http.parse_request') {\n        const raw = args[0];\n        if (raw.kind !== 'Str') throw new Error(\"http.parse_request expects Str\");\n        const text = raw.value;\n\n        try {\n            const parts = text.split(/\\r?\\n\\r?\\n/); // Split head and body\n            const head = parts[0];\n            const body = parts.slice(1).join('\\n\\n');\n\n            const lines = head.split(/\\r?\\n/);\n            if (lines.length === 0) throw new Error(\"Empty request\");\n\n            const reqLine = lines[0].split(' ');\n            if (reqLine.length < 3) throw new Error(\"Invalid request line\");\n            const method = reqLine[0];\n            const path = reqLine[1];\n\n            const headers: Value[] = [];\n            for (let i = 1; i < lines.length; i++) {\n                const line = lines[i];\n                if (!line.trim()) continue;\n                const idx = line.indexOf(':');\n                if (idx !== -1) {\n                    const key = line.substring(0, idx).trim();\n                    const val = line.substring(idx + 1).trim();\n                    headers.push({\n                        kind: 'Record',\n                        fields: {\n                            key: { kind: 'Str', value: key },\n                            val: { kind: 'Str', value: val }\n                        }\n                    });\n                }\n            }\n\n            const reqRecord: Value = {\n                kind: 'Record',\n                fields: {\n                    method: { kind: 'Str', value: method },\n                    path: { kind: 'Str', value: path },\n                    headers: { kind: 'List', items: headers },\n                    body: { kind: 'Str', value: body }\n                }\n            };\n\n            return { kind: 'Result', isOk: true, value: reqRecord };\n        } catch (e: any) {\n            return { kind: 'Result', isOk: false, value: { kind: 'Str', value: e.message } };\n        }\n    }\n\n    if (op === 'http.parse_response') {\n        const raw = args[0];\n        if (raw.kind !== 'Str') throw new Error(\"http.parse_response expects Str\");\n        const text = raw.value;\n\n        try {\n            const parts = text.split(/\\r?\\n\\r?\\n/);\n            const head = parts[0];\n            const body = parts.slice(1).join('\\n\\n');\n\n            const lines = head.split(/\\r?\\n/);\n            if (lines.length === 0) throw new Error(\"Empty response\");\n\n            const statusLine = lines[0].split(' ');\n            if (statusLine.length < 2) throw new Error(\"Invalid status line\");\n            const version = statusLine[0];\n            // Handle status code, possibly with text following\n            const statusCode = BigInt(parseInt(statusLine[1]));\n            // The rest is status text (optional)\n\n            const headers: Value[] = [];\n            for (let i = 1; i < lines.length; i++) {\n                const line = lines[i];\n                if (!line.trim()) continue;\n                const idx = line.indexOf(':');\n                if (idx !== -1) {\n                    const key = line.substring(0, idx).trim();\n                    const val = line.substring(idx + 1).trim();\n                    headers.push({\n                        kind: 'Record',\n                        fields: {\n                            key: { kind: 'Str', value: key },\n                            val: { kind: 'Str', value: val }\n                        }\n                    });\n                }\n            }\n\n            const resRecord: Value = {\n                kind: 'Record',\n                fields: {\n                    version: { kind: 'Str', value: version },\n                    status: { kind: 'I64', value: statusCode },\n                    headers: { kind: 'List', items: headers },\n                    body: { kind: 'Str', value: body }\n                }\n            };\n            return { kind: 'Result', isOk: true, value: resRecord };\n        } catch (e: any) {\n            return { kind: 'Result', isOk: false, value: { kind: 'Str', value: e.message } };\n        }\n    }\n\n    throw new Error(`Unknown http op: ${op}`);\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\n\nexport function evalConstructor(op: IntrinsicOp, args: Value[]): Value {\n    if (op === 'Some') {\n        return { kind: 'Option', value: args[0] };\n    }\n    if (op === 'Ok') return { kind: 'Result', isOk: true, value: args[0] };\n    if (op === 'Err') return { kind: 'Result', isOk: false, value: args[0] };\n\n    throw new Error(`Unknown constructor op: ${op}`);\n}\n", "\nimport { Value } from '../types';\n\nexport function valueToKey(v: Value): string {\n    if (v.kind === 'I64') return `I64:${v.value}`;\n    if (v.kind === 'Str') return `Str:${v.value}`;\n    if (v.kind === 'Tagged') {\n        return `Tagged:${v.tag}:${JSON.stringify(v.value, (_, val) => typeof val === 'bigint' ? val.toString() + 'n' : val)}`;\n    }\n    throw new Error(`Runtime: Invalid map key type: ${v.kind}`);\n}\n\nexport function keyToValue(k: string): Value {\n    if (k.startsWith('I64:')) {\n        return { kind: 'I64', value: BigInt(k.substring(4)) };\n    }\n    if (k.startsWith('Str:')) {\n        return { kind: 'Str', value: k.substring(4) };\n    }\n    if (k.startsWith('Tagged:')) {\n        const firstColon = k.indexOf(':');\n        const secondColon = k.indexOf(':', firstColon + 1);\n        if (secondColon === -1) throw new Error(`Runtime: Invalid tagged key format: ${k}`);\n        const tag = k.substring(firstColon + 1, secondColon);\n        const json = k.substring(secondColon + 1);\n        const val = JSON.parse(json, (_, v) => {\n            if (typeof v === 'string' && /^\\d+n$/.test(v)) return BigInt(v.slice(0, -1));\n            return v;\n        });\n        // We need to guess the value kind from JSON\n        // Primitive values (I64, Str, Bool) or Tuple/List/Record?\n        // JSON cannot fully reconstruct specific Iris Types without schema.\n        // For I64 map tests, we simplified.\n        // But (tag \"I64\" 42) -> value is 42 (number/bigint).\n        // If val is BigInt, it's I64.\n        const kind = typeof val === 'bigint' ? 'I64' : typeof val === 'string' ? \"Str\" : \"Tuple\"; // Approximation\n        // Better: reconstruct recursively.\n        // Since we serialization used JSON.stringify(v.value), v.value is a Value object (kind, value).\n        // Oh wait. v.value IS a Value object definition?\n        // No. JSON.stringify(v.value) serializes the Value object!\n        // { kind: 'I64', value: ... }\n        // So JSON.parse returns the Value object structure!\n        return { kind: 'Tagged', tag, value: val };\n    }\n    throw new Error(`Runtime: Invalid map key string: ${k}`);\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\nimport { valueToKey, keyToValue } from '../utils';\n\nexport function evalData(op: IntrinsicOp, args: Value[]): Value | undefined {\n    if (op === 'str.concat') return { kind: 'Str', value: ((args[0] as any)?.value || \"\") + ((args[1] as any)?.value || \"\") };\n    if (op === 'str.len') return { kind: 'I64', value: BigInt(((args[0] as any)?.value || \"\").length) };\n    if (op === 'str.get') {\n        const s = (args[0] as any).value; const i = Number((args[1] as any).value);\n        if (i >= 0 && i < s.length) return { kind: 'Option', value: { kind: 'I64', value: BigInt(s.charCodeAt(i)) } };\n        return { kind: 'Option', value: null };\n    }\n    if (op === 'str.substring') return { kind: 'Str', value: (args[0] as any).value.substring(Number((args[1] as any).value), Number((args[2] as any).value)) };\n    if (op === 'str.from_code') return { kind: 'Str', value: String.fromCharCode(Number((args[0] as any).value)) };\n    if (op === 'str.index_of') {\n        const s = (args[0] as any).value; const sub = (args[1] as any).value;\n        const idx = s.indexOf(sub);\n        if (idx === -1) return { kind: 'Option', value: null };\n        return { kind: 'Option', value: { kind: 'I64', value: BigInt(idx) } };\n    }\n    if (op === 'str.contains') return { kind: 'Bool', value: (args[0] as any).value.includes((args[1] as any).value) };\n    if (op === 'str.ends_with') return { kind: 'Bool', value: (args[0] as any).value.endsWith((args[1] as any).value) };\n\n    if (op === 'cons') {\n        const h = args[0];\n        const t = args[1];\n        if (t.kind === 'Tagged' && t.tag === 'nil') {\n            return { kind: 'List', items: [h] };\n        }\n        if (t.kind !== 'List') throw new Error(\"cons arguments must be (head, tail-list)\");\n        return { kind: 'List', items: [h, ...t.items] };\n    }\n\n    if (op.startsWith('list.')) {\n        if (op === 'list.length') return { kind: 'I64', value: BigInt((args[0] as any).items.length) };\n        if (op === 'list.get') {\n            const l = (args[0] as any).items; const i = Number((args[1] as any).value);\n            if (i >= 0 && i < l.length) return { kind: 'Option', value: l[i] };\n            return { kind: 'Option', value: null };\n        }\n        if (op === 'list.concat') return { kind: 'List', items: [...(args[0] as any).items, ...(args[1] as any).items] };\n        if (op === 'list.unique') {\n            const l = args[0] as any;\n            const seen = new Set<string>();\n            const items: Value[] = [];\n            for (const item of l.items) {\n                const k = valueToKey(item);\n                if (!seen.has(k)) {\n                    seen.add(k);\n                    items.push(item);\n                }\n            }\n            return { kind: 'List', items };\n        }\n    }\n\n    if (op.startsWith('map.')) {\n        if (op === 'map.make') return { kind: 'Map', value: new Map() };\n        if (op === 'map.put') {\n            const m = args[0] as any; const k = args[1]; const v = args[2];\n            const newMap = new Map<string, Value>(m.value);\n            newMap.set(valueToKey(k), v);\n            return { kind: 'Map', value: newMap };\n        }\n        if (op === 'map.get') {\n            const m = args[0] as any; const k = args[1];\n            const v = m.value.get(valueToKey(k));\n            return v ? { kind: 'Option', value: v } : { kind: 'Option', value: null };\n        }\n        if (op === 'map.contains') return { kind: 'Bool', value: (args[0] as any).value.has(valueToKey(args[1])) };\n        if (op === 'map.keys') {\n            const m = args[0] as any;\n            const keys = Array.from((m.value as Map<string, Value>).keys()).map((k: string) => keyToValue(k));\n            return { kind: 'List', items: keys };\n        }\n    }\n\n    if (op === 'record.get') {\n        const r = args[0]; const f = args[1];\n        if (r.kind !== 'Record' || f.kind !== 'Str') throw new Error(\"record.get expects Record and Str\");\n        const val = r.fields[f.value];\n        if (val === undefined) throw new Error(`Field ${f.value} not found`);\n        return val;\n    }\n\n    if (op === 'tuple.get') {\n        const t = args[0]; const i = args[1];\n        if (t.kind !== 'Tuple' || i.kind !== 'I64') throw new Error(\"tuple.get expects Tuple and I64\");\n        const idx = Number(i.value);\n        if (idx < 0 || idx >= t.items.length) throw new Error(\"Tuple index out of bounds\");\n        return t.items[idx];\n    }\n\n    return undefined;\n}\n", "\nimport { Value, IntrinsicOp } from '../../types';\nimport { InterpreterContext } from '../context';\nimport { evalMath } from './math';\nimport { evalSys } from './sys';\nimport { evalIo } from './io';\nimport { evalNet } from './net';\nimport { evalHttp } from './http';\nimport { evalConstructor } from './constructors';\n\nimport { evalData } from './data';\n\nexport async function evalIntrinsic(ctx: InterpreterContext, op: IntrinsicOp, args: Value[]): Promise<Value> {\n    if (op.startsWith('sys.')) return evalSys(ctx, op, args);\n    if (op.startsWith('net.')) return evalNet(ctx, op, args);\n    if (op.startsWith('io.')) return evalIo(ctx, op, args);\n    if (op.startsWith('http.')) return evalHttp(op, args);\n    if (['Some', 'Ok', 'Err'].includes(op)) return evalConstructor(op, args);\n\n    const dataRes = evalData(op, args);\n    if (dataRes) return dataRes;\n\n    // Default to math/pure ops\n    return evalMath(op, args);\n}\n", "\nimport { Expr, Value, LinkedEnv, IntrinsicOp } from '../types';\nimport { IInterpreter } from './interfaces';\nimport { evalIntrinsic } from './ops/index';\n\nexport async function evalExpr(ctx: IInterpreter, expr: Expr, env?: LinkedEnv): Promise<Value> {\n    switch (expr.kind) {\n        case 'Literal':\n            return expr.value;\n\n        case 'Var': {\n            // Resolve Env\n            let current = env;\n            while (current) {\n                if (current.name === expr.name) return current.value;\n                current = current.parent;\n            }\n\n            const c = ctx.constants.get(expr.name);\n            if (c !== undefined) return c;\n\n            if (expr.name.includes('.')) {\n                const parts = expr.name.split('.');\n                let currentVal: Value | undefined = undefined;\n\n                // Try env first\n                let e = env;\n                while (e) {\n                    if (e.name === parts[0]) {\n                        currentVal = e.value;\n                        break;\n                    }\n                    e = e.parent;\n                }\n\n                if (!currentVal) currentVal = ctx.constants.get(parts[0]);\n\n                if (currentVal) {\n                    for (let i = 1; i < parts.length; i++) {\n                        const part = parts[i];\n                        if (currentVal!.kind === 'Record') {\n                            const fieldVal: Value = (currentVal as any).fields[part];\n                            if (!fieldVal) throw new Error(`Runtime: Unknown field ${part} `);\n                            currentVal = fieldVal;\n                        } else if (currentVal!.kind === 'Tuple') {\n                            const index = parseInt(part);\n                            if (isNaN(index)) throw new Error(`Runtime: Tuple index must be number, got ${part} `);\n                            if (index < 0 || index >= (currentVal as any).items.length) throw new Error(`Runtime: Tuple index out of bounds ${index} `);\n                            currentVal = (currentVal as any).items[index];\n                        } else {\n                            throw new Error(`Runtime: Cannot access field ${part} of ${currentVal!.kind} `);\n                        }\n                    }\n                    return currentVal!;\n                }\n            }\n\n            throw new Error(`Runtime Unknown variable: ${expr.name} `);\n        }\n\n        case 'Let': {\n            const val = await evalExpr(ctx, expr.value, env);\n            const newEnv: LinkedEnv = { name: expr.name, value: val, parent: env };\n            return evalExpr(ctx, expr.body, newEnv);\n        }\n\n        case 'If': {\n            const cond = await evalExpr(ctx, expr.cond, env);\n            if (cond.kind !== 'Bool') throw new Error(\"If condition must be Bool\");\n            if (cond.value) {\n                return evalExpr(ctx, expr.then, env);\n            } else {\n                return evalExpr(ctx, expr.else, env);\n            }\n        }\n\n        case 'Call': {\n            let func = ctx.functions.get(expr.fn);\n\n            if (!func && expr.fn.includes('.')) {\n                const [alias, fname] = expr.fn.split('.');\n                const importDecl = ctx.program.imports.find(i => i.alias === alias);\n                if (importDecl && ctx.resolver) {\n                    const importedProg = ctx.resolver(importDecl.path);\n                    if (importedProg) {\n                        const targetDef = importedProg.defs.find(d => (d.kind === 'DefFn' || d.kind === 'DefTool') && d.name === fname) as any;\n                        if (targetDef) {\n                            func = targetDef;\n                        }\n                    }\n                }\n            }\n\n\n            // Evaluate args in current scope\n            const args: Value[] = [];\n            for (const arg of expr.args) {\n                args.push(await evalExpr(ctx, arg, env));\n            }\n\n            if (expr.fn.includes('.')) {\n                // It's a cross-module call.\n                const [alias, fname] = expr.fn.split('.');\n                const importDecl = ctx.program.imports.find(i => i.alias === alias);\n                if (importDecl && ctx.resolver) {\n                    const importedPath = importDecl.path;\n                    let subInterp = ctx.getInterpreter(importedPath);\n                    if (!subInterp) {\n                        const importedProg = ctx.resolver(importedPath);\n                        if (importedProg) {\n                            subInterp = ctx.createInterpreter(importedProg);\n                        }\n                    }\n                    if (subInterp) {\n                        return subInterp.callFunction(fname, args);\n                    }\n                }\n            }\n\n            if (!func) {\n                try {\n                    // Adapt InterpreterContext to logic required by helpers?\n                    // We need to cast or ensure IInterpreter satisfies InterpreterContext from ops/sys.ts?\n                    // ops/sys.ts takes InterpreterContext which has spawn, pid, etc.\n                    // IInterpreter has spawn, pid, etc.\n                    return await evalIntrinsic(ctx as any, expr.fn as IntrinsicOp, args);\n                } catch (e) {\n                    throw new Error(`Unknown function: ${expr.fn}`);\n                }\n            }\n\n            if (func.kind === 'DefTool') {\n                if (!ctx.tools) throw new Error(`Tool not implemented: ${expr.fn}`);\n                return ctx.tools.callTool(expr.fn, args);\n            }\n            if (args.length !== func.args.length) throw new Error(`Arity mismatch for ${expr.fn}`);\n\n            // Create new env for function body\n            let newEnv: LinkedEnv | undefined = undefined;\n            for (let i = 0; i < args.length; i++) {\n                newEnv = { name: func.args[i].name, value: args[i], parent: newEnv };\n            }\n\n            return evalExpr(ctx, func.body, newEnv);\n        }\n\n        case 'Match': {\n            const target = await evalExpr(ctx, expr.target, env);\n\n            // Find matching case\n            for (const c of expr.cases) {\n                // Check tag match\n                let match = false;\n                let newEnv = env;\n\n                if (target.kind === 'Option') {\n                    if (c.tag === 'None' && target.value === null) match = true;\n                    else if (c.tag === 'Some' && target.value !== null) {\n                        match = true;\n                        if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                            const varVal = c.vars.items[0];\n                            if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                        }\n                    }\n                } else if (target.kind === 'Result') {\n                    if (c.tag === 'Ok' && target.isOk) {\n                        match = true;\n                        if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                            const varVal = c.vars.items[0];\n                            if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                        }\n                    } else if (c.tag === 'Err' && !target.isOk) {\n                        match = true;\n                        if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                            const varVal = c.vars.items[0];\n                            if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                        }\n                    }\n                } else if (target.kind === 'List') {\n                    if (c.tag === 'nil' && target.items.length === 0) {\n                        match = true;\n                    } else if (c.tag === 'cons' && target.items.length > 0) {\n                        match = true;\n                        if (c.vars.kind === 'List') {\n                            if (c.vars.items.length >= 1) {\n                                const headName = c.vars.items[0];\n                                if (headName.kind === 'Str') newEnv = { name: headName.value, value: target.items[0], parent: newEnv };\n                            }\n                            if (c.vars.items.length >= 2) {\n                                const tailName = c.vars.items[1];\n                                if (tailName.kind === 'Str') newEnv = { name: tailName.value, value: { kind: 'List', items: target.items.slice(1) }, parent: newEnv };\n                            }\n                        }\n                    }\n                } else if (target.kind === 'Tagged') {\n                    if (c.tag === target.tag) {\n                        match = true;\n                        if (target.value && c.vars.kind === 'List' && c.vars.items.length > 0) {\n                            const varNameVal = c.vars.items[0];\n                            if (varNameVal.kind === 'Str') {\n                                newEnv = { name: varNameVal.value, value: target.value, parent: newEnv };\n                            }\n                        }\n                    }\n                } else if (target.kind === 'Tuple' && target.items.length > 0 && target.items[0].kind === 'Str') {\n                    // Generic Tagged Union (represented as Tuple [\"Tag\", ...args])\n                    const tagName = target.items[0].value;\n                    if (c.tag === tagName) {\n                        match = true;\n                        // Bind variables to remaining tuple items\n                        if (c.vars.kind === 'List') {\n                            for (let i = 0; i < c.vars.items.length; i++) {\n                                if (i + 1 < target.items.length) {\n                                    const varVal = c.vars.items[i];\n                                    if (varVal.kind === 'Str') {\n                                        newEnv = { name: varVal.value, value: target.items[i + 1], parent: newEnv };\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (match || c.tag === '_') {\n                    return evalExpr(ctx, c.body, newEnv);\n                }\n            }\n            const replacer = (_: string, v: any) => typeof v === 'bigint' ? v.toString() + 'n' : v;\n            throw new Error(`No matching case for value ${JSON.stringify(target, replacer)}`);\n        }\n\n        case 'Record': {\n            const fields: Record<string, Value> = {};\n            for (const fieldTuple of expr.fields) {\n                const tupleVal = await evalExpr(ctx, fieldTuple, env);\n                if (tupleVal.kind !== 'Tuple' || tupleVal.items.length !== 2) throw new Error(\"Invalid record field tuple\");\n                const keyVal = tupleVal.items[0];\n                if (keyVal.kind !== 'Str') throw new Error(\"Record key must be Str\");\n                fields[keyVal.value] = tupleVal.items[1];\n            }\n            return { kind: 'Record', fields };\n        }\n\n        case 'Tagged': {\n            const val = await evalExpr(ctx, expr.value, env);\n            return { kind: 'Tagged', tag: expr.tag, value: val };\n        }\n\n        case 'Tuple': {\n            const items: Value[] = [];\n            for (const item of expr.items) {\n                items.push(await evalExpr(ctx, item, env));\n            }\n            return { kind: 'Tuple', items };\n        }\n\n        case 'List': {\n            const items: Value[] = [];\n            for (const item of expr.items) {\n                items.push(await evalExpr(ctx, item, env));\n            }\n            return { kind: 'List', items };\n        }\n\n        case 'Intrinsic': {\n            const args: Value[] = [];\n            for (const arg of expr.args) {\n                args.push(await evalExpr(ctx, arg, env));\n            }\n            return evalIntrinsic(ctx as any, expr.op, args);\n        }\n\n        default:\n            throw new Error(`Unimplemented eval for ${(expr as any).kind}`);\n    }\n}\n", "\nimport { Expr, Value, LinkedEnv, IntrinsicOp } from '../types';\nimport { IInterpreter } from './interfaces';\nimport { valueToKey, keyToValue } from './utils';\nimport { evalMath } from './ops/math';\nimport { evalIo } from './ops/io';\nimport { evalHttp } from './ops/http';\nimport { evalConstructor } from './ops/constructors';\n\nexport function evalExprSync(ctx: IInterpreter, expr: Expr, env?: LinkedEnv): Value {\n    let currentExpr = expr;\n    let currentEnv = env;\n    let depthCounter = 0;\n\n    // We can't easily replicate the exact depth logging from here without polluting IInterpreter with counters.\n    // For now assuming we can skip the verbose logging or delegate it?\n    // The original checks depthCounter per recursive call in the wrapper, but TCO loop is internal.\n    // Let's implement the TCO loop.\n\n    while (true) {\n        switch (currentExpr.kind) {\n            case 'Literal':\n                return currentExpr.value;\n\n            case 'Var': {\n                let current = currentEnv;\n                while (current) {\n                    if (current.name === currentExpr.name) return current.value;\n                    current = current.parent;\n                }\n\n                const c = ctx.constants.get(currentExpr.name);\n                if (c !== undefined) return c;\n\n                if (currentExpr.name.includes('.')) {\n                    const parts = currentExpr.name.split('.');\n                    let currentVal: Value | undefined = undefined;\n\n                    let e = currentEnv;\n                    while (e) {\n                        if (e.name === parts[0]) {\n                            currentVal = e.value;\n                            break;\n                        }\n                        e = e.parent;\n                    }\n                    if (!currentVal) currentVal = ctx.constants.get(parts[0]);\n\n                    if (currentVal) {\n                        for (let i = 1; i < parts.length; i++) {\n                            const part = parts[i];\n                            if (currentVal!.kind === 'Record') {\n                                const fieldVal: Value = (currentVal as any).fields[part];\n                                if (!fieldVal) throw new Error(`Runtime: Unknown field ${part} `);\n                                currentVal = fieldVal;\n                            } else if (currentVal!.kind === 'Tuple') {\n                                const index = parseInt(part);\n                                if (isNaN(index)) throw new Error(`Runtime: Tuple index must be number, got ${part} `);\n                                if (index < 0 || index >= (currentVal as any).items.length) throw new Error(`Runtime: Tuple index out of bounds ${index} `);\n                                currentVal = (currentVal as any).items[index];\n                            } else {\n                                throw new Error(`Runtime: Cannot access field ${part} of ${currentVal!.kind} `);\n                            }\n                        }\n                        return currentVal!;\n                    }\n                }\n\n                throw new Error(`Runtime Unknown variable: ${currentExpr.name} `);\n            }\n\n            case 'Let': {\n                const val = evalExprSync(ctx, currentExpr.value, currentEnv);\n                const newEnv: LinkedEnv = { name: currentExpr.name, value: val, parent: currentEnv };\n                currentExpr = currentExpr.body;\n                currentEnv = newEnv;\n                continue;\n            }\n\n            case 'If': {\n                const cond = evalExprSync(ctx, currentExpr.cond, currentEnv);\n                if (cond.kind !== 'Bool') throw new Error(\"If condition must be Bool\");\n                if (cond.value) {\n                    currentExpr = currentExpr.then;\n                } else {\n                    currentExpr = currentExpr.else;\n                }\n                continue;\n            }\n\n            case 'Call': {\n                let func = ctx.functions.get(currentExpr.fn);\n\n                if (!func && currentExpr.fn.includes('.')) {\n                    const [alias, fname] = currentExpr.fn.split('.');\n                    const importDecl = ctx.program.imports.find(i => i.alias === alias);\n                    if (importDecl && ctx.resolver) {\n                        const importedProg = ctx.resolver(importDecl.path);\n                        if (importedProg) {\n                            const targetDef = importedProg.defs.find(d => (d.kind === 'DefFn' || d.kind === 'DefTool') && d.name === fname) as any;\n                            if (targetDef) {\n                                func = targetDef;\n                            }\n                        }\n                    }\n                }\n\n                const args: Value[] = [];\n                for (const arg of currentExpr.args) {\n                    args.push(evalExprSync(ctx, arg, currentEnv));\n                }\n\n                if (currentExpr.fn.includes('.')) {\n                    const [alias, fname] = currentExpr.fn.split('.');\n                    const importDecl = ctx.program.imports.find(i => i.alias === alias);\n                    if (importDecl && ctx.resolver) {\n                        const importedPath = importDecl.path;\n                        let subInterp = ctx.getInterpreter(importedPath);\n                        if (!subInterp) {\n                            const importedProg = ctx.resolver(importedPath);\n                            if (importedProg) {\n                                subInterp = ctx.createInterpreter(importedProg);\n                            }\n                        }\n                        if (subInterp) {\n                            // Sync call in subInterpreter needs to be exposed on IInterpreter\n                            // But IInterpreter only has callFunction (async).\n                            // Ops... IInterpreter needs callFunctionSync ?\n                            // The original Interpreter has callFunctionSync.\n                            // I should add callFunctionSync to IInterpreter.\n                            return (subInterp as any).callFunctionSync(fname, args);\n                        }\n                    }\n                }\n\n                if (!func) {\n                    return evalIntrinsicSync(ctx, currentExpr.fn as any, args);\n                }\n\n                if (func.kind === 'DefTool') {\n                    if (!(ctx as any).tools?.callToolSync) throw new Error(`Tool not implemented: ${currentExpr.fn}`);\n                    return (ctx as any).tools.callToolSync(currentExpr.fn, args);\n                }\n                if (args.length !== func.args.length) throw new Error(`Arity mismatch error call ${currentExpr.fn} expected ${func.args.length} args, got ${args.length} `);\n\n                let newEnv: LinkedEnv | undefined = undefined;\n                for (let i = 0; i < args.length; i++) {\n                    newEnv = { name: func.args[i].name, value: args[i], parent: newEnv };\n                }\n\n                currentExpr = func.body;\n                currentEnv = newEnv;\n                continue;\n            }\n\n            case 'Match': {\n                const target = evalExprSync(ctx, currentExpr.target, currentEnv);\n                let foundCase = false;\n                for (const c of currentExpr.cases) {\n                    let match = false;\n                    let newEnv = currentEnv;\n\n                    if (target.kind === 'Option') {\n                        if (c.tag === 'None' && target.value === null) match = true;\n                        else if (c.tag === 'Some' && target.value !== null) {\n                            match = true;\n                            if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                                const varVal = c.vars.items[0];\n                                if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                            }\n                        }\n                    } else if (target.kind === 'Result') {\n                        if (c.tag === 'Ok' && target.isOk) {\n                            match = true;\n                            if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                                const varVal = c.vars.items[0];\n                                if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                            }\n                        } else if (c.tag === 'Err' && !target.isOk) {\n                            match = true;\n                            if (c.vars.kind === 'List' && c.vars.items.length > 0) {\n                                const varVal = c.vars.items[0];\n                                if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.value, parent: newEnv };\n                            }\n                        }\n                    } else if (target.kind === 'Tagged') {\n                        if (c.tag === target.tag) {\n                            match = true;\n                            if (target.value && c.vars.kind === 'List' && c.vars.items.length > 0) {\n                                const varNameVal = c.vars.items[0];\n                                if (varNameVal.kind === 'Str') {\n                                    newEnv = { name: varNameVal.value, value: target.value, parent: newEnv };\n                                }\n                            }\n                        }\n                    } else if (target.kind === 'List') {\n                        if (c.tag === 'nil' && target.items.length === 0) {\n                            match = true;\n                        } else if (c.tag === 'cons' && target.items.length > 0) {\n                            match = true;\n                            if (c.vars.kind === 'List') {\n                                if (c.vars.items.length >= 1) {\n                                    const headName = c.vars.items[0];\n                                    if (headName.kind === 'Str') newEnv = { name: headName.value, value: target.items[0], parent: newEnv };\n                                }\n                                if (c.vars.items.length >= 2) {\n                                    const tailName = c.vars.items[1];\n                                    if (tailName.kind === 'Str') newEnv = { name: tailName.value, value: { kind: 'List', items: target.items.slice(1) }, parent: newEnv };\n                                }\n                            }\n                        }\n                    } else if (target.kind === 'Tuple' && target.items.length > 0 && target.items[0].kind === 'Str') {\n                        const tagName = target.items[0].value;\n                        if (c.tag === tagName) {\n                            match = true;\n                            if (c.vars.kind === 'List') {\n                                for (let i = 0; i < c.vars.items.length; i++) {\n                                    if (i + 1 < target.items.length) {\n                                        const varVal = c.vars.items[i];\n                                        if (varVal.kind === 'Str') newEnv = { name: varVal.value, value: target.items[i + 1], parent: newEnv };\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (match || c.tag === '_') {\n                        currentExpr = c.body;\n                        currentEnv = newEnv;\n                        foundCase = true;\n                        break;\n                    }\n                }\n                if (foundCase) continue;\n                const replacer = (_: string, v: any) => typeof v === 'bigint' ? v.toString() + 'n' : v;\n                throw new Error(`Non - exhaustive match for ${JSON.stringify(target, replacer)}`);\n            }\n\n            case 'Record': {\n                const fields: Record<string, Value> = {};\n                for (const fieldTuple of currentExpr.fields) {\n                    const tupleVal = evalExprSync(ctx, fieldTuple, currentEnv);\n                    if (tupleVal.kind !== 'Tuple' || tupleVal.items.length !== 2) throw new Error(\"Invalid record field tuple\");\n                    const keyVal = tupleVal.items[0];\n                    if (keyVal.kind !== 'Str') throw new Error(\"Record key must be Str\");\n                    fields[keyVal.value] = tupleVal.items[1];\n                }\n                return { kind: 'Record', fields };\n            }\n\n            case 'Tuple': {\n                const items: Value[] = [];\n                for (const item of currentExpr.items) {\n                    items.push(evalExprSync(ctx, item, currentEnv));\n                }\n                return { kind: 'Tuple', items };\n            }\n\n            case 'List': {\n                const items: Value[] = [];\n                for (const item of currentExpr.items) {\n                    items.push(evalExprSync(ctx, item, currentEnv));\n                }\n                return { kind: 'List', items };\n            }\n\n            case 'Intrinsic': {\n                const args: Value[] = [];\n                for (const arg of currentExpr.args) {\n                    args.push(evalExprSync(ctx, arg, currentEnv));\n                }\n                return evalIntrinsicSync(ctx, currentExpr.op, args);\n            }\n\n            case 'Tagged': {\n                const val = evalExprSync(ctx, currentExpr.value, currentEnv);\n                return { kind: 'Tagged', tag: currentExpr.tag, value: val };\n            }\n\n            case 'Lambda': {\n                return {\n                    kind: 'Lambda',\n                    args: currentExpr.args,\n                    ret: currentExpr.ret,\n                    eff: currentExpr.eff,\n                    body: currentExpr.body,\n                    env: currentEnv\n                };\n            }\n\n            default:\n                throw new Error(`Unimplemented evalSync for ${(currentExpr as any).kind}`);\n        }\n    }\n}\n\nfunction evalIntrinsicSync(ctx: IInterpreter, op: IntrinsicOp, args: Value[]): Value {\n    if (['Some', 'Ok', 'Err'].includes(op)) return evalConstructor(op, args);\n    if (op.startsWith('http.')) return evalHttp(op, args);\n    if (op.startsWith('io.')) return evalIo(ctx, op, args);\n\n    // Math/Pure\n    try {\n        return evalMath(op, args);\n    } catch (e) {\n        // If evalMath didn't match, maybe map/list ops?\n    }\n\n    if (op.startsWith('map.')) {\n        if (op === 'map.make') return { kind: 'Map', value: new Map() };\n        if (op === 'map.put') {\n            const m = args[0] as any; const k = args[1]; const v = args[2];\n            const newMap = new Map<string, Value>(m.value);\n            newMap.set(valueToKey(k), v);\n            return { kind: 'Map', value: newMap };\n        }\n        if (op === 'map.get') {\n            const m = args[0] as any; const k = args[1];\n            const v = m.value.get(valueToKey(k));\n            return v ? { kind: 'Option', value: v } : { kind: 'Option', value: null };\n        }\n        if (op === 'map.contains') return { kind: 'Bool', value: (args[0] as any).value.has(valueToKey(args[1])) };\n        if (op === 'map.keys') {\n            const m = args[0] as any;\n            const keys = Array.from((m.value as Map<string, Value>).keys()).map((k: string) => keyToValue(k));\n            return { kind: 'List', items: keys };\n        }\n    }\n\n    if (op === 'cons') return { kind: 'List', items: [args[0], ... (args[1] as any).items] };\n    if (op.startsWith('list.')) {\n        if (op === 'list.length') return { kind: 'I64', value: BigInt((args[0] as any).items.length) };\n        if (op === 'list.get') {\n            const l = (args[0] as any).items; const i = Number((args[1] as any).value);\n            if (i >= 0 && i < l.length) return { kind: 'Option', value: l[i] };\n            return { kind: 'Option', value: null };\n        }\n        if (op === 'list.concat') return { kind: 'List', items: [...(args[0] as any).items, ...(args[1] as any).items] };\n        if (op === 'list.unique') {\n            const l = args[0] as any;\n            const seen = new Set<string>();\n            const items: Value[] = [];\n            for (const item of l.items) {\n                const k = valueToKey(item);\n                if (!seen.has(k)) {\n                    seen.add(k);\n                    items.push(item);\n                }\n            }\n            return { kind: 'List', items };\n        }\n    }\n\n    if (op === 'record.get') {\n        const r = args[0]; const f = args[1];\n        if (r.kind !== 'Record' || f.kind !== 'Str') throw new Error(\"record.get expects Record and Str\");\n        const val = r.fields[f.value];\n        if (val === undefined) throw new Error(`Field ${f.value} not found`);\n        return val;\n    }\n\n    if (op === 'tuple.get') {\n        const t = args[0]; const i = args[1];\n        if (t.kind !== 'Tuple' || i.kind !== 'I64') throw new Error(\"tuple.get expects Tuple and I64\");\n        const idx = Number(i.value);\n        if (idx < 0 || idx >= t.items.length) throw new Error(\"Tuple index out of bounds\");\n        return t.items[idx];\n    }\n\n    if (op === 'str.concat') return { kind: 'Str', value: ((args[0] as any)?.value || \"\") + ((args[1] as any)?.value || \"\") };\n    if (op === 'str.len') return { kind: 'I64', value: BigInt(((args[0] as any)?.value || \"\").length) };\n    if (op === 'str.get') {\n        const s = (args[0] as any).value; const i = Number((args[1] as any).value);\n        if (i >= 0 && i < s.length) return { kind: 'Option', value: { kind: 'I64', value: BigInt(s.charCodeAt(i)) } };\n        return { kind: 'Option', value: null };\n    }\n    if (op === 'str.substring') return { kind: 'Str', value: (args[0] as any).value.substring(Number((args[1] as any).value), Number((args[2] as any).value)) };\n    if (op === 'str.from_code') return { kind: 'Str', value: String.fromCharCode(Number((args[0] as any).value)) };\n    if (op === 'str.index_of') {\n        const s = (args[0] as any).value; const sub = (args[1] as any).value;\n        const idx = s.indexOf(sub);\n        if (idx === -1) return { kind: 'Option', value: null };\n        return { kind: 'Option', value: { kind: 'I64', value: BigInt(idx) } };\n    }\n    if (op === 'str.contains') return { kind: 'Bool', value: (args[0] as any).value.includes((args[1] as any).value) };\n    if (op === 'str.ends_with') return { kind: 'Bool', value: (args[0] as any).value.endsWith((args[1] as any).value) };\n\n\n    if (op.startsWith('net.') || op === 'sys.sleep') {\n        throw new Error(`Cannot call async intrinsic ${op} from synchronous evaluation path`);\n    }\n\n    if (op === 'sys.args') {\n        const argsList = ctx.args.map(a => ({ kind: 'Str', value: a } as Value));\n        return { kind: 'List', items: argsList };\n    }\n\n    throw new Error(`Unknown intrinsic or not implemented in Sync path: ${op} `);\n}\n", "\nimport { Program, Definition, FunctionLikeDef, Value, ModuleResolver, LinkedEnv } from '../types';\nimport { IFileSystem, INetwork, IInterpreter, IToolHost } from './interfaces';\nimport { MockFileSystem, MockNetwork } from './mocks';\nimport { evalExpr } from './expr';\nimport { evalExprSync } from './sync';\nimport { ProcessManager } from '../runtime/process';\n\nexport class Interpreter implements IInterpreter {\n    public functions = new Map<string, FunctionLikeDef>();\n    public constants = new Map<string, Value>();\n    public fs: IFileSystem;\n    public net: INetwork;\n    public tools?: IToolHost;\n    public pid: number;\n    public args: string[] = [];\n\n    private interpreterCache: Map<string, Interpreter> = new Map();\n\n    constructor(\n        public program: Program,\n        fs: Record<string, string> | IFileSystem = {},\n        public resolver?: ModuleResolver,\n        net?: INetwork,\n        tools?: IToolHost,\n        cache?: Map<string, Interpreter>,\n        args: string[] = []\n    ) {\n        this.args = args;\n        if (cache) this.interpreterCache = cache;\n        this.interpreterCache.set(this.program.module.name, this);\n\n        // Backwards compatibility\n        if (typeof (fs as any).readFile === 'function') {\n            this.fs = fs as IFileSystem;\n        } else {\n            this.fs = new MockFileSystem(fs as Record<string, string>);\n        }\n        this.net = net || new MockNetwork();\n        this.tools = tools;\n\n        this.pid = ProcessManager.instance.getNextPid();\n        ProcessManager.instance.register(this.pid);\n\n        for (const def of program.defs) {\n            if (def.kind === 'DefFn' || def.kind === 'DefTool') {\n                this.functions.set(def.name, def);\n            }\n        }\n    }\n\n    createInterpreter(program: Program): IInterpreter {\n        return new Interpreter(program, this.fs, this.resolver, this.net, this.tools, this.interpreterCache, this.args);\n    }\n\n    getInterpreter(path: string): IInterpreter | undefined {\n        return this.interpreterCache.get(path);\n    }\n\n    spawn(fnName: string): number {\n        // Create detached interpreter\n        const child = new Interpreter(this.program, this.fs, this.resolver, this.net, this.tools, undefined, this.args);\n        const childPid = child.pid;\n\n        // Fire and forget (detached)\n        Promise.resolve().then(async () => {\n            try {\n                await child.callFunction(fnName, []);\n            } catch (e) {\n                console.error(`Process ${childPid} crashed: `, e);\n            }\n        });\n\n        return childPid;\n    }\n\n    async evalMain(): Promise<Value> {\n        const main = this.functions.get('main');\n        if (!main) throw new Error(\"No main function defined\");\n        if (main.kind !== 'DefFn') throw new Error(\"Main must be a function\");\n\n        if (main.eff === '!Pure' || main.eff === '!IO') {\n            this.initConstantsSync();\n            return evalExprSync(this, main.body, undefined);\n        }\n\n        await this.initConstants();\n        return evalExpr(this, main.body, undefined);\n    }\n\n    public async callFunction(name: string, args: Value[]): Promise<Value> {\n        await this.initConstants();\n        const func = this.functions.get(name);\n        if (!func) throw new Error(`Unknown function: ${name}`);\n        if (func.kind === 'DefTool') {\n            if (!this.tools) throw new Error(`Tool not implemented: ${name}`);\n            return this.tools.callTool(name, args);\n        }\n        if (args.length !== func.args.length) throw new Error(`Arity mismatch call ${name}`);\n\n        let env: LinkedEnv | undefined = undefined;\n        for (let i = 0; i < args.length; i++) {\n            env = { name: func.args[i].name, value: args[i], parent: env };\n        }\n        return evalExpr(this, func.body, env);\n    }\n\n    public callFunctionSync(name: string, args: Value[]): Value {\n        this.initConstantsSync();\n        const func = this.functions.get(name);\n        if (!func) throw new Error(`Unknown function: ${name}`);\n        if (func.kind === 'DefTool') {\n            if (!this.tools?.callToolSync) throw new Error(`Tool not implemented: ${name}`);\n            return this.tools.callToolSync(name, args);\n        }\n        if (args.length !== func.args.length) throw new Error(`Arity mismatch call ${name}`);\n\n        let env: LinkedEnv | undefined = undefined;\n        for (let i = 0; i < args.length; i++) {\n            env = { name: func.args[i].name, value: args[i], parent: env };\n        }\n        return evalExprSync(this, func.body, env);\n    }\n\n    private async initConstants() {\n        if (this.constants.size > 0) return;\n        for (const def of this.program.defs) {\n            if (def.kind === 'DefConst') {\n                this.constants.set(def.name, await evalExpr(this, def.value, undefined));\n            }\n        }\n    }\n\n    private initConstantsSync() {\n        if (this.constants.size > 0) return;\n        for (const def of this.program.defs) {\n            if (def.kind === 'DefConst') {\n                this.constants.set(def.name, evalExprSync(this, def.value, undefined));\n            }\n        }\n    }\n}\n", "import { Parser, printValue } from './sexp';\nimport { TypeChecker } from './typecheck';\nimport { Interpreter, IFileSystem, INetwork, IToolHost } from './eval';\nimport { ModuleResolver, Program } from './types';\nimport { ProcessManager } from './runtime/process';\n\n\n\n\n// Helper to encapsulate program + resolver for interpreter\ntype CheckResult = { success: true, program: Program, resolver: ModuleResolver } | { success: false, error: string };\n\nexport function check(source: string, modules: Record<string, string> = {}, debug: boolean = false): CheckResult {\n    // 1. Parse\n    const parser = new Parser(source, debug);\n    let program;\n    try {\n        program = parser.parse();\n    } catch (e: any) {\n        return { success: false, error: `ParseError: ${e.message}` };\n    }\n\n    // 1b. Check Circular Imports starting from main program\n    try {\n        const visited = new Set<string>();\n        const recursionStack = new Set<string>();\n\n        const dfs = (path: string) => {\n            if (recursionStack.has(path)) {\n                // Construct nice message\n                const stack = Array.from(recursionStack);\n                const idx = stack.indexOf(path);\n                const cycle = stack.slice(idx).concat(path).join(' -> ');\n                throw new Error(`Circular import detected: ${cycle}`);\n            }\n            if (visited.has(path)) return;\n\n            visited.add(path);\n            recursionStack.add(path);\n\n            const src = modules[path];\n            if (src) {\n                try {\n                    // Note: Module parsing also uses debug? Maybe specific flag?\n                    // For now inherit debug flag.\n                    const p = new Parser(src, debug);\n                    const pr = p.parse();\n                    for (const i of pr.imports) {\n                        dfs(i.path);\n                    }\n                } catch (e: any) {\n                    throw new Error(`In module '${path}': ${e.message}`);\n                }\n            }\n            recursionStack.delete(path);\n        };\n\n        for (const i of program.imports) {\n            dfs(i.path);\n        }\n\n    } catch (e: any) {\n        return { success: false, error: `RuntimeError: ${e.message}` };\n    }\n\n    // Create caching resolver\n    const cache = new Map<string, Program>();\n    const resolver: ModuleResolver = (path: string) => {\n        if (cache.has(path)) return cache.get(path);\n\n        const modSource = modules[path];\n        if (!modSource) return undefined;\n        try {\n            const p = new Parser(modSource, debug);\n            const pr = p.parse();\n            cache.set(path, pr);\n            return pr;\n        } catch (e) {\n            console.error(`Failed to parse module ${path}:`, e);\n            return undefined;\n        }\n    };\n\n    // 2. Typecheck\n    const checker = new TypeChecker(resolver);\n    try {\n        checker.check(program);\n    } catch (e: any) {\n        if (e.message.startsWith('TypeError:')) {\n            return { success: false, error: e.message };\n        }\n        return { success: false, error: `TypeError: ${e.message}` };\n    }\n\n    return { success: true, program, resolver };\n}\n\n\n\n// ... other imports\n\nexport async function run(source: string, fsMap: Record<string, string> | IFileSystem = {}, modules: Record<string, string> = {}, net?: INetwork, args: string[] = [], debug: boolean = false, tools?: IToolHost): Promise<string> {\n    ProcessManager.instance.reset(); // Reset concurrency state for fresh run\n    const checked = check(source, modules, debug);\n    if (!checked.success) return checked.error;\n\n    // 3. Interpret\n    const interpreter = new Interpreter(checked.program, fsMap, checked.resolver, net, tools, undefined, args);\n    let result;\n    try {\n        result = await interpreter.evalMain();\n    } catch (e: any) {\n        return `RuntimeError: ${e.message}`;\n    }\n\n    return printValue(result);\n}\n", "import { Value } from '../types';\n\nexport type ToolFn = (...args: any[]) => any | Promise<any>;\n\nexport interface ToolRegistry {\n    [name: string]: ToolFn | undefined;\n}\n\nexport function valueToJs(v: Value): any {\n    switch (v.kind) {\n        case 'I64': return v.value;\n        case 'Bool': return v.value;\n        case 'Str': return v.value;\n        case 'Option': return v.value === null ? null : valueToJs(v.value);\n        case 'Result': return v.isOk ? { ok: valueToJs(v.value) } : { err: valueToJs(v.value) };\n        case 'List': return v.items.map(valueToJs);\n        case 'Tuple': return v.items.map(valueToJs);\n        case 'Record': {\n            const obj: Record<string, any> = {};\n            for (const [k, val] of Object.entries(v.fields)) obj[k] = valueToJs(val);\n            return obj;\n        }\n        case 'Tagged': return { tag: v.tag, value: valueToJs(v.value) };\n        case 'Map': return {};\n        case 'Lambda': return null;\n    }\n    return null;\n}\n\nexport function jsToValue(v: any): Value {\n    if (v && typeof v === 'object' && typeof v.kind === 'string') return v as Value;\n    if (typeof v === 'bigint') return { kind: 'I64', value: v };\n    if (typeof v === 'number') return { kind: 'I64', value: BigInt(v) };\n    if (typeof v === 'string') return { kind: 'Str', value: v };\n    if (typeof v === 'boolean') return { kind: 'Bool', value: v };\n    if (v === null || v === undefined) return { kind: 'Option', value: null };\n    if (Array.isArray(v)) return { kind: 'List', items: v.map(jsToValue) };\n    if (typeof v === 'object') {\n        const fields: Record<string, Value> = {};\n        for (const [k, val] of Object.entries(v)) fields[k] = jsToValue(val);\n        return { kind: 'Record', fields };\n    }\n    return { kind: 'Str', value: String(v) };\n}\n", "\nimport { IFileSystem, INetwork, IToolHost } from '../eval';\nimport { ToolRegistry, jsToValue, valueToJs } from '../runtime/tool-host';\nimport { Value } from '../types';\n\nexport class BrowserFileSystem implements IFileSystem {\n    private files: Map<string, string> = new Map();\n\n    readFile(path: string): string | null {\n        if (!this.files.has(path)) {\n            return null;\n        }\n        return this.files.get(path) || \"\";\n    }\n\n    writeFile(path: string, content: string): boolean {\n        this.files.set(path, content);\n        return true;\n    }\n\n    exists(path: string): boolean {\n        return this.files.has(path);\n    }\n\n    readDir(path: string): string[] | null {\n        // Simple prefix match simulation\n        const results: string[] = [];\n        for (const key of this.files.keys()) {\n            if (key.startsWith(path)) {\n                results.push(key);\n            }\n        }\n        return results;\n    }\n}\n\nexport class BrowserNetwork implements INetwork {\n    async listen(port: number): Promise<number> {\n        console.log(`[BrowserNet] Mock listening on port ${port}`);\n        return 1; // Mock handle\n    }\n\n    async accept(serverHandle: number): Promise<number> {\n        console.log(`[BrowserNet] Waiting for connection... (Mock: Returning immediately)`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return 2; // Mock client handle\n    }\n\n    async read(handle: number): Promise<string> {\n        return \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n    }\n\n    async write(handle: number, data: string): Promise<boolean> {\n        console.log(`[BrowserNet] Writing to ${handle}:`);\n        console.log(data);\n        return true;\n    }\n\n    async connect(host: string, port: number): Promise<number | null> {\n        console.warn(\"net.connect not supported in browser\");\n        return null;\n    }\n\n    async close(handle: number): Promise<boolean> {\n        console.log(`[BrowserNet] Closed handle ${handle}`);\n        return true;\n    }\n}\n\nexport class BrowserToolHost implements IToolHost {\n    constructor(private tools: ToolRegistry = {}) { }\n\n    async callTool(name: string, args: Value[]): Promise<Value> {\n        const fn = this.tools[name];\n        if (!fn) throw new Error(`Tool not found: ${name}`);\n        const result = await fn(...args.map(valueToJs));\n        return jsToValue(result);\n    }\n\n    callToolSync(name: string, args: Value[]): Value {\n        const fn = this.tools[name];\n        if (!fn) throw new Error(`Tool not found: ${name}`);\n        const result = fn(...args.map(valueToJs));\n        return jsToValue(result);\n    }\n}\n"],
  "mappings": "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",
  "names": ["args", "check", "check", "check", "check", "check", "resolve", "resolve", "resolve"]
}
