{
  "version": 3,
  "sources": ["../src/web-entry.ts", "../src/sexp.ts", "../src/typecheck.ts", "../src/eval.ts", "../src/main.ts", "../src/platform/browser.ts"],
  "sourcesContent": ["\nimport { run } from './main';\nimport { BrowserFileSystem, BrowserNetwork } from './platform/browser';\n\nexport async function runIris(source: string): Promise<string> {\n    const outputBuffer: string[] = [];\n    const originalLog = console.log;\n\n    // Capture console.log\n    console.log = (...args: any[]) => {\n        outputBuffer.push(args.map(a => String(a)).join(' '));\n        originalLog(...args);\n    };\n\n    try {\n        const fs = new BrowserFileSystem();\n        const net = new BrowserNetwork();\n\n        // We can pass empty modules for now, or pre-load them if needed\n        const resultVal = await run(source, fs, {}, net);\n\n        // Final output is combination of side-effect prints + return value\n        if (resultVal.startsWith(\"RuntimeError:\") || resultVal.startsWith(\"TypeError:\") || resultVal.startsWith(\"ParseError:\")) {\n            outputBuffer.push(resultVal); // Error is usually the return string\n        } else {\n            outputBuffer.push(`=> ${resultVal}`);\n        }\n\n        return outputBuffer.join('\\n');\n    } catch (e: any) {\n        return `Unexpected Error: ${e.message}`;\n    } finally {\n        console.log = originalLog;\n    }\n}\n\n// Expose to window\n(window as any).runIris = runIris;\n", "import { Program, Definition, Expr, IrisType, IrisEffect, MatchCase, IntrinsicOp, Value, Import, ModuleDecl } from './types';\n\nexport type Token =\n    | { kind: 'LParen'; line: number; col: number }\n    | { kind: 'RParen'; line: number; col: number }\n    | { kind: 'Int'; value: bigint; line: number; col: number }\n    | { kind: 'Bool'; value: boolean; line: number; col: number }\n    | { kind: 'Str'; value: string; line: number; col: number }\n    | { kind: 'Symbol'; value: string; line: number; col: number }\n    | { kind: 'EOF'; line: number; col: number };\n\nexport function tokenize(input: string): Token[] {\n    const tokens: Token[] = [];\n    let pos = 0;\n    let line = 1;\n    let col = 1;\n\n    while (pos < input.length) {\n        const char = input[pos];\n\n        if (/\\s/.test(char)) {\n            if (char === '\\n') {\n                line++;\n                col = 1;\n            } else {\n                col++;\n            }\n            pos++;\n            continue;\n            continue;\n        }\n\n        if (char === ';') {\n            while (pos < input.length && input[pos] !== '\\n') {\n                pos++;\n            }\n            continue;\n        }\n\n        if (char === '(') {\n            tokens.push({ kind: 'LParen', line, col });\n            pos++; col++;\n            continue;\n        }\n\n        if (char === ')') {\n            tokens.push({ kind: 'RParen', line, col });\n            pos++; col++;\n            continue;\n        }\n\n        // String\n        if (char === '\"') {\n            const startLine = line;\n            const startCol = col;\n            pos++; col++;\n            let strVal = '';\n            while (pos < input.length && input[pos] !== '\"') {\n                const c = input[pos];\n                if (c === '\\\\') {\n                    // Handle escapes in source code if needed?\n                    // Spec: \"Tokens: ... strings \"...\".\"\n                    // Usually source strings allow escapes. \n                    // For v0 let's handle basic escapes if we encounter backslash.\n                    // But spec \"Lexical\" doesn't explicitly detail escape sequences for *parsing*, \n                    // only for *printing*.\n                    // Let's assume standard JSON-ish behavior or raw.\n                    // Ideally we should process escapes.\n                    if (pos + 1 < input.length) {\n                        const next = input[pos + 1];\n                        if (next === '\"') strVal += '\"';\n                        else if (next === 'n') strVal += '\\n';\n                        else if (next === 't') strVal += '\\t';\n                        else if (next === 'r') strVal += '\\r';\n                        else if (next === '\\\\') strVal += '\\\\';\n                        else strVal += next;\n                        pos += 2; col += 2;\n                        continue;\n                    }\n                }\n\n                if (c === '\\n') {\n                    line++;\n                    col = 1;\n                } else {\n                    col++;\n                }\n                strVal += c;\n                pos++;\n            }\n            if (pos >= input.length) {\n                throw new Error(`Unterminated string starting at ${startLine}:${startCol}`);\n            }\n            pos++; col++; // Consume closing quote\n            tokens.push({ kind: 'Str', value: strVal, line: startLine, col: startCol });\n            continue;\n        }\n\n        // Integer (start with digit or -digit)\n        if (char === '-' && pos + 1 < input.length && /\\d/.test(input[pos + 1])) {\n            // Negative integer\n            let buf = '-';\n            pos++; col++;\n            while (pos < input.length && /\\d/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n            tokens.push({ kind: 'Int', value: BigInt(buf), line: line, col: col - buf.length });\n            continue;\n        }\n\n        if (/\\d/.test(char)) {\n            let buf = '';\n            const startCol = col;\n            while (pos < input.length && /\\d/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n            tokens.push({ kind: 'Int', value: BigInt(buf), line, col: startCol });\n            continue;\n        }\n\n        // Symbol (or Bool)\n        // Allowed symbol chars: non-whitespace, not ( ) \"\n        if (/[^()\\s\"]/.test(char)) {\n            let buf = '';\n            const startCol = col;\n            while (pos < input.length && /[^()\\s\"]/.test(input[pos])) {\n                buf += input[pos];\n                pos++; col++;\n            }\n\n            if (buf === 'true') {\n                tokens.push({ kind: 'Bool', value: true, line, col: startCol });\n            } else if (buf === 'false') {\n                tokens.push({ kind: 'Bool', value: false, line, col: startCol });\n            } else {\n                tokens.push({ kind: 'Symbol', value: buf, line, col: startCol });\n            }\n            continue;\n        }\n\n        throw new Error(`Unexpected character '${char}' at ${line}:${col}`);\n    }\n\n    tokens.push({ kind: 'EOF', line, col });\n    return tokens;\n}\n\nexport class Parser {\n    private tokens: Token[];\n    private pos = 0;\n\n    constructor(input: string) {\n        this.tokens = tokenize(input);\n    }\n\n    parse(): Program {\n        this.expect('LParen');\n        this.expectSymbol('program');\n\n        let moduleDecl = { name: 'unknown', version: 0 };\n        const imports: Import[] = [];\n        const defs: Definition[] = [];\n\n        while (!this.check('RParen')) {\n            this.expect('LParen');\n            const section = this.expectSymbol();\n            if (section === 'module') {\n                this.expect('LParen');\n                this.expectSymbol('name');\n                const name = this.expectString();\n                this.expect('RParen');\n                this.expect('LParen');\n                this.expectSymbol('version');\n                const version = Number(this.expectInt());\n                this.expect('RParen');\n                this.expect('RParen');\n                moduleDecl = { name, version };\n            } else if (section === 'imports') {\n                while (!this.check('RParen')) {\n                    this.expect('LParen');\n                    this.expectSymbol('import');\n                    const path = this.expectString();\n                    let alias = '';\n                    if (this.check('LParen')) {\n                        this.expect('LParen');\n                        this.expectSymbol('as');\n                        alias = this.expectString();\n                        this.expect('RParen');\n                    } else {\n                        // Default alias = basename of path? or require explicit alias?\n                        // v0.4 spec says: (import \"...\" (as \"...\"))\n                        throw new Error(\"Import must have alias currently\");\n                    }\n                    this.expect('RParen');\n                    imports.push({ path, alias });\n                }\n                this.expect('RParen');\n            } else if (section === 'defs') {\n                while (!this.check('RParen')) {\n                    defs.push(this.parseDefinition());\n                }\n                this.expect('RParen');\n            } else {\n                throw new Error(`Unknown program section: ${section}`);\n            }\n        }\n\n        this.expect('RParen');\n        return { module: moduleDecl, imports, defs };\n    }\n\n    private parseDefinition(): Definition {\n        this.expect('LParen');\n        const kind = this.expectSymbol();\n\n        if (kind === 'defconst') {\n            // (defconst (name ID) (type T) (value EXPR))\n            this.expect('LParen'); this.expectSymbol('name'); const name = this.expectSymbol(); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('type'); const type = this.parseType(); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('value'); const value = this.parseExpr(); this.expect('RParen');\n            this.expect('RParen');\n            return { kind: 'DefConst', name, type, value };\n        } else if (kind === 'deffn') {\n            // (deffn (name ID) (args ...) (ret T) (eff !) (body ...))\n            this.expect('LParen'); this.expectSymbol('name'); const name = this.expectSymbol(); this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('args');\n            const args: { name: string, type: IrisType }[] = [];\n            while (!this.check('RParen')) {\n                this.expect('LParen');\n                const argName = this.expectSymbol();\n                const argType = this.parseType();\n                this.expect('RParen');\n                args.push({ name: argName, type: argType });\n            }\n            this.expect('RParen');\n\n            this.expect('LParen'); this.expectSymbol('ret'); const ret = this.parseType(); this.expect('RParen');\n            this.expect('LParen'); this.expectSymbol('eff'); const eff = this.expectEffect(); this.expect('RParen');\n\n            // Optional requires/ensures? Spec says optional. We'll skip for now or peek.\n            while (this.check('LParen')) {\n                // Peek ahead to see if it is body\n                const save = this.pos;\n                this.expect('LParen');\n                const tag = this.peek();\n                if (tag.kind === 'Symbol' && tag.value === 'body') {\n                    this.pos = save;\n                    break;\n                }\n                // Skip requires/ensures for now\n                this.pos = save;\n                this.skipSExp();\n            }\n\n            this.expect('LParen'); this.expectSymbol('body'); const body = this.parseExpr(); this.expect('RParen');\n            this.expect('RParen');\n\n            return { kind: 'DefFn', name, args, ret, eff, body };\n        } else {\n            throw new Error(`Unknown definition kind: ${kind}`);\n        }\n    }\n\n    private parseExpr(): Expr {\n        const token = this.peek();\n\n        if (token.kind === 'Int') { this.consume(); return { kind: 'Literal', value: { kind: 'I64', value: token.value } }; }\n        if (token.kind === 'Bool') { this.consume(); return { kind: 'Literal', value: { kind: 'Bool', value: token.value } }; }\n        if (token.kind === 'Str') { this.consume(); return { kind: 'Literal', value: { kind: 'Str', value: token.value } }; }\n        if (token.kind === 'Symbol') {\n            if (token.value === 'None') { this.consume(); return { kind: 'Literal', value: { kind: 'Option', value: null } }; }\n            if (token.value === 'nil') { this.consume(); return { kind: 'Literal', value: { kind: 'List', items: [] } }; }\n            this.consume();\n            return { kind: 'Var', name: token.value };\n        }\n\n        if (token.kind === 'LParen') {\n            this.consume();\n            const head = this.peek();\n\n            if (head.kind === 'Symbol') {\n                const op = head.value;\n                this.consume();\n\n                // Special forms\n                if (op === 'let') {\n                    // (let (x EXPR) BODY)\n                    this.expect('LParen');\n                    const name = this.expectSymbol();\n                    const val = this.parseExpr();\n                    this.expect('RParen');\n                    const body = this.parseExpr();\n                    this.expect('RParen');\n                    return { kind: 'Let', name, value: val, body };\n                }\n                if (op === 'record') {\n                    // (record (k v) ...)\n                    const fields: { [k: string]: Expr } = {};\n                    while (!this.check('RParen')) {\n                        this.expect('LParen');\n                        const key = this.expectSymbol();\n                        const val = this.parseExpr();\n                        this.expect('RParen');\n                        fields[key] = val; // checking duplicates?\n                    }\n                    this.expect('RParen');\n                    // We need 'Record' in Expr? types.ts defined Expr with Intrinsic, etc.\n                    // Let's see types.ts... \"kind: 'Record' matches structural?\"\n                    // types.ts Expr definition doesn't have Record value construction yet in the provided view?\n                    // Wait, I need to check types.ts.\n                    // The previous view of types.ts (Step 223) shows:\n                    // export type Expr = ... | { kind: 'List' ... } | { kind: 'Fold' ... } | { kind: 'Lambda' ... } \n                    // It DOES NOT have 'Record' kind in Expr. I need to simple-return a special Intrinsic or add it to Expr.\n                    // Let's add it to Expr in types.ts too.\n                    return { kind: 'Record', fields };\n                }\n                if (op === 'if') {\n                    const cond = this.parseExpr();\n                    const thenBr = this.parseExpr();\n                    const elseBr = this.parseExpr();\n                    this.expect('RParen');\n                    return { kind: 'If', cond, then: thenBr, else: elseBr };\n                }\n                if (op === 'match') {\n                    const target = this.parseExpr();\n                    const cases: MatchCase[] = [];\n                    while (!this.check('RParen')) {\n                        this.expect('LParen');\n                        this.expectSymbol('case');\n                        this.expect('LParen');\n                        this.expectSymbol('tag');\n                        const tag = this.expectString();\n                        const vars: string[] = [];\n                        // Optional args (v) or nothing\n                        if (this.check('LParen')) {\n                            this.expect('LParen');\n                            while (!this.check('RParen')) {\n                                vars.push(this.expectSymbol());\n                            }\n                            this.expect('RParen');\n                        }\n                        this.expect('RParen'); // close tag\n                        const body = this.parseExpr();\n                        this.expect('RParen'); // close case\n                        cases.push({ tag, vars, body });\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Match', target, cases };\n                }\n                if (op === 'call') {\n                    const fn = this.expectSymbol();\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Call', fn, args };\n                }\n\n                // Constructors / Intrinsics\n                if (['+', '-', '*', '/', '<=', '<', '=', 'Some', 'Ok', 'Err', 'cons', 'io.print', 'io.read_file', 'io.write_file'].includes(op)) {\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n                }\n\n                // Check for (io.* ...)\n                if (op.startsWith('io.')) {\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n                }\n\n                // Check for (net.* ...)\n                if (op.startsWith('net.')) {\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n                }\n\n                // Check for (http.* ...)\n                if (op.startsWith('http.')) {\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n                }\n\n                // Check for (str.* ...)\n                if (op.startsWith('str.')) {\n                    const args: Expr[] = [];\n                    while (!this.check('RParen')) {\n                        args.push(this.parseExpr());\n                    }\n                    this.expect('RParen');\n                    return { kind: 'Intrinsic', op: op as IntrinsicOp, args };\n                }\n\n                throw new Error(`Unknown operator or special form: ${op}`);\n            }\n\n            throw new Error(\"Expected symbol after '('\");\n        }\n\n        throw new Error(`Unexpected token for expression: ${token.kind}`);\n    }\n\n    private parseType(): IrisType {\n        const token = this.peek();\n        if (token.kind === 'Symbol') {\n            const w = token.value;\n            this.consume();\n            if (w === 'I64') return { type: 'I64' };\n            if (w === 'Bool') return { type: 'Bool' };\n            if (w === 'Str') return { type: 'Str' };\n        }\n\n        if (token.kind === 'LParen') {\n            this.consume();\n            const head = this.peek();\n            if (head.kind !== 'Symbol') throw new Error(\"Expected type constructor\");\n            const tMap = head.value;\n            this.consume();\n\n            if (tMap === 'Option') {\n                const inner = this.parseType();\n                this.expect('RParen');\n                return { type: 'Option', inner };\n            }\n            if (tMap === 'Result') {\n                const ok = this.parseType();\n                const err = this.parseType();\n                this.expect('RParen');\n                return { type: 'Result', ok, err };\n            }\n            if (tMap === 'List') {\n                const inner = this.parseType();\n                this.expect('RParen');\n                return { type: 'List', inner };\n            }\n            if (tMap === 'Record') {\n                // (Record (f1 T1) (f2 T2))\n                const fields: Record<string, IrisType> = {};\n                while (!this.check('RParen')) {\n                    this.expect('LParen');\n                    const name = this.expectSymbol();\n                    const type = this.parseType();\n                    this.expect('RParen');\n                    fields[name] = type;\n                }\n                this.expect('RParen');\n                return { type: 'Record', fields };\n            }\n\n            this.expect('RParen'); // Fallback\n            throw new Error(`Unknown type constructor: ${tMap}`);\n        }\n\n        throw new Error(`Unexpected token in type`);\n    }\n\n    private expectEffect(): IrisEffect {\n        const t = this.peek();\n        if (t.kind === 'Symbol' && t.value.startsWith('!')) {\n            this.consume();\n            if (['!Pure', '!IO', '!Net', '!Any', '!Infer'].includes(t.value)) {\n                return t.value as IrisEffect;\n            }\n            throw new Error(`Unknown effect: ${t.value}`);\n        }\n        throw new Error(\"Expected effect starting with !\");\n    }\n\n    private skipSExp() {\n        let depth = 0;\n        if (this.check('LParen')) {\n            this.consume();\n            depth = 1;\n            while (depth > 0 && this.pos < this.tokens.length) {\n                if (this.check('LParen')) depth++;\n                else if (this.check('RParen')) depth--;\n                this.consume();\n            }\n        } else {\n            this.consume();\n        }\n    }\n\n    private peek() { if (this.pos >= this.tokens.length) return { kind: 'EOF', line: 0, col: 0 } as Token; return this.tokens[this.pos]; }\n    private consume() { this.pos++; }\n    private check(kind: string) { return this.peek().kind === kind; }\n    private expect(kind: string) { if (!this.check(kind)) throw new Error(`Expected ${kind} at ${this.peek().line}:${this.peek().col}`); this.consume(); }\n    private expectSymbol(val?: string) {\n        const t = this.peek();\n        if (t.kind !== 'Symbol' || (val && t.value !== val)) throw new Error(`Expected Symbol ${val || ''} at ${t.line}:${t.col}`);\n        this.consume();\n        return t.value;\n    }\n    private expectString() { const t = this.peek(); if (t.kind !== 'Str') throw new Error(`Expected String`); this.consume(); return t.value; }\n    private expectInt() { const t = this.peek(); if (t.kind !== 'Int') throw new Error(`Expected Int`); this.consume(); return t.value; }\n}\n\nfunction escapeStr(s: string): string {\n    return s.replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g, '\\\\\"')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\r/g, '\\\\r');\n}\n\nexport function printValue(v: Value): string {\n    switch (v.kind) {\n        case 'I64': return v.value.toString();\n        case 'Bool': return v.value.toString();\n        case 'Str': return `\"${escapeStr(v.value)}\"`;\n        case 'Option': return v.value === null ? \"None\" : `(Some ${printValue(v.value)})`;\n        case 'Result': return v.isOk ? `(Ok ${printValue(v.value)})` : `(Err ${printValue(v.value)})`;\n        case 'List': return `(list ${v.items.map(printValue).join(' ')})`;\n        case 'Tuple': return `(tuple ${v.items.map(printValue).join(' ')})`;\n        case 'Record':\n            // Sorted keys\n            const keys = Object.keys(v.fields).sort();\n            if (keys.length === 0) return '(record)';\n            const fields = keys.map(k => `(${k} ${printValue(v.fields[k])})`).join(' ');\n            return `(record ${fields})`;\n    }\n}\n", "import { Program, Definition, Expr, IrisType, IrisEffect, IntrinsicOp, ModuleResolver } from './types';\n\nexport class TypeChecker {\n    private functions = new Map<string, { args: IrisType[], ret: IrisType, eff: IrisEffect }>();\n    private constants = new Map<string, IrisType>();\n    private currentProgram?: Program;\n\n    constructor(private resolver?: ModuleResolver) { }\n\n    check(program: Program) {\n        this.currentProgram = program;\n        // First pass: collect signatures\n        for (const def of program.defs) {\n            if (def.kind === 'DefConst') {\n                this.constants.set(def.name, def.type);\n            } else if (def.kind === 'DefFn') {\n                const argNames = new Set<string>();\n                for (const a of def.args) {\n                    if (argNames.has(a.name)) throw new Error(`TypeError: Duplicate argument name: ${a.name}`);\n                    argNames.add(a.name);\n                }\n                this.functions.set(def.name, {\n                    args: def.args.map(a => a.type),\n                    ret: def.ret,\n                    eff: def.eff\n                });\n            }\n        }\n\n        // Second pass: check bodies\n        for (const def of program.defs) {\n            if (def.kind === 'DefConst') {\n                const { type, eff } = this.checkExprFull(def.value, new Map());\n                this.expectType(def.type, type, `Constant ${def.name} type mismatch`);\n                this.checkEffectSubtype(eff, '!Pure', `Constant ${def.name} must be Pure`);\n            } else if (def.kind === 'DefFn') {\n                const fnType = this.functions.get(def.name)!;\n                const env = new Map<string, IrisType>();\n                for (let i = 0; i < def.args.length; i++) {\n                    env.set(def.args[i].name, def.args[i].type);\n                }\n\n                const { type: bodyType, eff: bodyEff } = this.checkExprFull(def.body, env);\n\n                this.expectType(def.ret, bodyType, `Function ${def.name} return type mismatch`);\n\n                if (def.eff === '!Infer') {\n                    // Update registry with inferred effect logic if we supported two-pass inference or similar.\n                    // For now, allow it to pass.\n                    // In a real system we'd update this.functions but since we already visited calls,\n                    // we might need a fixpoint. For v0.2 simple scope, we just let it accept.\n                    this.functions.set(def.name, { ...fnType, eff: bodyEff });\n                } else {\n                    this.checkEffectSubtype(bodyEff, def.eff, `Function ${def.name}`);\n                }\n            }\n        }\n    }\n\n    // Returns Type AND Inferred Effect\n    private checkExprFull(expr: Expr, env: Map<string, IrisType>): { type: IrisType, eff: IrisEffect } {\n        switch (expr.kind) {\n            case 'Literal': {\n                const val = expr.value;\n                if (val.kind === 'I64') return { type: { type: 'I64' }, eff: '!Pure' };\n                if (val.kind === 'Bool') return { type: { type: 'Bool' }, eff: '!Pure' };\n                if (val.kind === 'Str') return { type: { type: 'Str' }, eff: '!Pure' };\n                if (val.kind === 'Option') {\n                    if (val.value === null) return { type: { type: 'Option', inner: { type: 'I64' } }, eff: '!Pure' }; // Default None type\n                    const inner = this.checkExprFull({ kind: 'Literal', value: val.value } as Expr, env);\n                    return { type: { type: 'Option', inner: inner.type }, eff: inner.eff };\n                }\n                if (val.kind === 'Result') {\n                    const v = this.checkExprFull({ kind: 'Literal', value: val.value } as Expr, env);\n                    // Generous Result type\n                    return { type: { type: 'Result', ok: val.isOk ? v.type : { type: 'Str' }, err: val.isOk ? { type: 'Str' } : v.type }, eff: v.eff };\n                }\n                if (val.kind === 'List') return { type: { type: 'List', inner: { type: 'I64' } }, eff: '!Pure' };\n                if (val.kind === 'Tuple') return { type: { type: 'Tuple', items: [] }, eff: '!Pure' };\n                if (val.kind === 'Record') return { type: { type: 'Record', fields: {} }, eff: '!Pure' };\n                throw new Error(`Unknown literal kind: ${(val as any).kind}`);\n            }\n\n            case 'Var': {\n                if (env.has(expr.name)) return { type: env.get(expr.name)!, eff: '!Pure' };\n                if (this.constants.has(expr.name)) return { type: this.constants.get(expr.name)!, eff: '!Pure' };\n\n                // Dot access for records\n                if (expr.name.includes('.')) {\n                    const parts = expr.name.split('.');\n                    let currentType = env.get(parts[0]) || this.constants.get(parts[0]);\n                    if (currentType) {\n                        for (let i = 1; i < parts.length; i++) {\n                            if (currentType!.type !== 'Record') throw new Error(`TypeError: Cannot access field ${parts[i]} of non-record ${parts.slice(0, i).join('.')}`);\n                            const fields: Record<string, IrisType> = currentType!.fields!;\n                            const fieldType: IrisType = fields[parts[i]];\n                            if (!fieldType) throw new Error(`TypeError: Unknown field ${parts[i]} in record`);\n                            currentType = fieldType;\n                        }\n                        return { type: currentType!, eff: '!Pure' };\n                    }\n                }\n\n                throw new Error(`TypeError: Unknown variable: ${expr.name}`);\n            }\n\n            case 'Let': {\n                const val = this.checkExprFull(expr.value, env);\n                const newEnv = new Map(env).set(expr.name, val.type);\n                const body = this.checkExprFull(expr.body, newEnv);\n                return { type: body.type, eff: this.joinEffects(val.eff, body.eff) };\n            }\n\n            case 'If': {\n                const cond = this.checkExprFull(expr.cond, env);\n                if (cond.type.type !== 'Bool') throw new Error(`TypeError: Type Error in If condition: Expected Bool, got ${this.fmt(cond.type)}`);\n                const t = this.checkExprFull(expr.then, env);\n                const e = this.checkExprFull(expr.else, env);\n                this.expectType(t.type, e.type, \"If branches mismatch\");\n                return { type: t.type, eff: this.joinEffects(cond.eff, this.joinEffects(t.eff, e.eff)) };\n            }\n\n            case 'Match': {\n                const target = this.checkExprFull(expr.target, env);\n                let retType: IrisType | null = null;\n                let joinedEff: IrisEffect = target.eff;\n\n                const targetType = target.type;\n                if (targetType.type === 'Option') {\n                    for (const c of expr.cases) {\n                        const newEnv = new Map(env);\n                        if (c.tag === 'Some') {\n                            if (c.vars.length !== 1) throw new Error(\"Some case expects 1 variable\");\n                            if (!targetType.inner) throw new Error(\"Internal error: Option type missing inner type\");\n                            newEnv.set(c.vars[0], targetType.inner);\n                        } else if (c.tag === 'None') {\n                            if (c.vars.length !== 0) throw new Error(\"None case expects 0 variables\");\n                        } else throw new Error(`Unknown option match tag: ${c.tag}`);\n\n                        const body = this.checkExprFull(c.body, newEnv);\n                        if (retType) this.expectType(retType, body.type, \"Match arms mismatch\");\n                        else retType = body.type;\n                        joinedEff = this.joinEffects(joinedEff, body.eff);\n                    }\n                } else if (targetType.type === 'Result') {\n                    for (const c of expr.cases) {\n                        const newEnv = new Map(env);\n                        if (c.tag === 'Ok') {\n                            if (c.vars.length !== 1) throw new Error(\"Ok case expects 1 variable\");\n                            if (!targetType.ok) throw new Error(\"Internal error: Result type missing ok type\");\n                            newEnv.set(c.vars[0], targetType.ok);\n                        } else if (c.tag === 'Err') {\n                            if (c.vars.length !== 1) throw new Error(\"Err case expects 1 variable\");\n                            if (!targetType.err) throw new Error(\"Internal error: Result type missing err type\");\n                            newEnv.set(c.vars[0], targetType.err);\n                        } else throw new Error(`Unknown result match tag: ${c.tag}`);\n\n                        const body = this.checkExprFull(c.body, newEnv);\n                        if (retType) this.expectType(retType, body.type, \"Match arms mismatch\");\n                        else retType = body.type;\n                        joinedEff = this.joinEffects(joinedEff, body.eff);\n                    }\n                } else if (targetType.type === 'List') {\n                    for (const c of expr.cases) {\n                        const newEnv = new Map(env);\n                        if (c.tag === 'nil') {\n                            if (c.vars.length !== 0) throw new Error(\"nil case expects 0 variables\");\n                        } else if (c.tag === 'cons') {\n                            if (c.vars.length !== 2) throw new Error(\"cons case expects 2 variables (head tail)\");\n                            if (!targetType.inner) throw new Error(\"Internal List missing inner\");\n                            newEnv.set(c.vars[0], targetType.inner!); // head\n                            newEnv.set(c.vars[1], targetType);       // tail\n                        } else throw new Error(`Unknown list match tag: ${c.tag}`);\n\n                        const body = this.checkExprFull(c.body, newEnv);\n                        if (retType) this.expectType(retType, body.type, \"Match arms mismatch\");\n                        else retType = body.type;\n                        joinedEff = this.joinEffects(joinedEff, body.eff);\n                    }\n                } else {\n                    throw new Error(`Match target must be Option, Result, or List (got ${targetType.type})`);\n                }\n                return { type: retType!, eff: joinedEff };\n            }\n\n            case 'Call': {\n                let func = this.functions.get(expr.fn);\n\n                if (!func && expr.fn.includes('.')) {\n                    // Try to resolve imported function\n                    const [alias, fname] = expr.fn.split('.');\n                    const importDecl = this.currentProgram?.imports.find(i => i.alias === alias);\n                    if (importDecl && this.resolver) {\n                        const importedProg = this.resolver(importDecl.path);\n                        if (importedProg) {\n                            const targetDef = importedProg.defs.find(d => d.kind === 'DefFn' && d.name === fname) as any;\n                            if (targetDef) {\n                                func = {\n                                    args: targetDef.args.map((a: any) => a.type), // re-parse type if needed, but it's AST\n                                    ret: targetDef.ret,\n                                    eff: targetDef.eff\n                                };\n                                // TODO: Recursive check of the imported module? \n                                // For v0.4 we assume imported modules are valid or we'd loop forever if circular.\n                            }\n                        }\n                    }\n                }\n\n                if (!func) throw new Error(`TypeError: Unknown function call: ${expr.fn}`);\n                if (expr.args.length !== func.args.length) throw new Error(`TypeError: Arity mismatch for ${expr.fn}`);\n                let eff: IrisEffect = '!Pure';\n                for (let i = 0; i < expr.args.length; i++) {\n                    const arg = this.checkExprFull(expr.args[i], env);\n                    this.expectType(func.args[i], arg.type, `Argument ${i} mismatch`);\n                    eff = this.joinEffects(eff, arg.eff);\n                }\n                // Handle !Infer: if callee is !Infer, treat as !Any (pessimistic) unless we know better.\n                const callEff = func.eff === '!Infer' ? '!Any' : func.eff;\n                return { type: func.ret, eff: this.joinEffects(eff, callEff) };\n            }\n\n            case 'Record': {\n                const fields: Record<string, IrisType> = {};\n                let eff: IrisEffect = '!Pure';\n                for (const [key, valExpr] of Object.entries(expr.fields)) {\n                    const res = this.checkExprFull(valExpr, env);\n                    fields[key] = res.type;\n                    eff = this.joinEffects(eff, res.eff);\n                }\n                return { type: { type: 'Record', fields }, eff };\n            }\n\n            case 'Intrinsic': {\n                let joinedEff: IrisEffect = '!Pure';\n                const argTypes: IrisType[] = [];\n                for (const arg of expr.args) {\n                    const res = this.checkExprFull(arg, env);\n                    argTypes.push(res.type);\n                    joinedEff = this.joinEffects(joinedEff, res.eff);\n                }\n\n                // Pure Ops\n                if (['+', '-', '*', '/', '<', '<=', '=', '>=', '>'].includes(expr.op)) {\n                    // Check arg types\n                    for (let i = 0; i < argTypes.length; i++) {\n                        if (argTypes[i].type !== 'I64') {\n                            // Equality allows others in theory, but v0 spec strict.\n                            if (['+', '-', '*', '/'].includes(expr.op)) {\n                                throw new Error(`TypeError: Type Error in ${expr.op} operand ${i + 1}: Expected I64, got ${argTypes[i].type}`);\n                            }\n                        }\n                    }\n                    return { type: ['<=', '<', '=', '>=', '>'].includes(expr.op) ? { type: 'Bool' } : { type: 'I64' }, eff: joinedEff };\n                }\n\n                if (expr.op === 'Some') return { type: { type: 'Option', inner: argTypes[0] }, eff: joinedEff };\n\n                if (expr.op === 'Ok') return { type: { type: 'Result', ok: argTypes[0], err: { type: 'Str' } }, eff: joinedEff };\n                if (expr.op === 'Err') return { type: { type: 'Result', ok: { type: 'I64' }, err: argTypes[0] }, eff: joinedEff };\n                if (expr.op === 'cons') return { type: { type: 'List', inner: argTypes[0] }, eff: joinedEff }; // Simplified\n\n                if (expr.op.startsWith('io.')) {\n                    joinedEff = this.joinEffects(joinedEff, '!IO');\n                    if (expr.op === 'io.read_file') return { type: { type: 'Result', ok: { type: 'Str' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'io.write_file') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'io.file_exists') return { type: { type: 'Bool' }, eff: joinedEff };\n                    if (expr.op === 'io.read_dir') return { type: { type: 'Result', ok: { type: 'List', inner: { type: 'Str' } }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'io.print') return { type: { type: 'I64' }, eff: joinedEff };\n                }\n\n                if (expr.op.startsWith('net.')) {\n                    joinedEff = this.joinEffects(joinedEff, '!Net');\n                    // Mock types for now (using I64 as handles)\n                    if (expr.op === 'net.listen') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'net.accept') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'net.read') return { type: { type: 'Result', ok: { type: 'Str' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'net.write') return { type: { type: 'Result', ok: { type: 'I64' }, err: { type: 'Str' } }, eff: joinedEff };\n                    if (expr.op === 'net.close') return { type: { type: 'Result', ok: { type: 'Bool' }, err: { type: 'Str' } }, eff: joinedEff };\n                }\n\n                if (expr.op.startsWith('str.')) {\n                    // String operations are pure\n                    if (expr.op === 'str.concat') return { type: { type: 'Str' }, eff: joinedEff };\n                    if (expr.op === 'str.contains' || expr.op === 'str.ends_with') return { type: { type: 'Bool' }, eff: joinedEff };\n                }\n\n                if (expr.op === 'http.parse_request') {\n                    // Result<HttpRequest, Str>\n                    // HttpRequest = { method: Str, path: Str, headers: List<(Record (key Str) (val Str))>, body: Str }\n                    joinedEff = this.joinEffects(joinedEff, '!Pure'); // Parsing is pure!\n\n                    const headerType: IrisType = {\n                        type: 'Record',\n                        fields: { key: { type: 'Str' }, val: { type: 'Str' } }\n                    };\n\n                    const httpReqType: IrisType = {\n                        type: 'Record',\n                        fields: {\n                            method: { type: 'Str' },\n                            path: { type: 'Str' },\n                            headers: { type: 'List', inner: headerType },\n                            body: { type: 'Str' }\n                        }\n                    };\n\n                    return {\n                        type: { type: 'Result', ok: httpReqType, err: { type: 'Str' } },\n                        eff: joinedEff\n                    };\n                }\n\n                throw new Error(`Unknown intrinsic: ${expr.op}`);\n            }\n\n            default:\n                throw new Error(`Unimplemented check for ${(expr as any).kind}`);\n        }\n    }\n\n    private checkExpr(expr: Expr, env: Map<string, IrisType>): IrisType {\n        // Legacy wrapper removed/inlined\n        return this.checkExprFull(expr, env).type;\n    }\n\n    private expectType(expected: IrisType, actual: IrisType, message: string) {\n        if (!this.typesEqual(expected, actual)) {\n            throw new Error(`TypeError: ${message}: Expected ${this.fmt(expected)}, got ${this.fmt(actual)}`);\n        }\n    }\n\n    private effectOrder(eff: IrisEffect): number {\n        switch (eff) {\n            case '!Pure': return 0;\n            case '!IO': return 1;\n            case '!Net': return 2;\n            case '!Any': return 3;\n            case '!Infer': return -1;\n        }\n        return 0; // fallback\n    }\n\n    private joinEffects(e1: IrisEffect, e2: IrisEffect): IrisEffect {\n        if (e1 === '!Infer' || e2 === '!Infer') return '!Pure';\n\n        if (e1 === '!Any' || e2 === '!Any') return '!Any';\n        if (e1 === '!Net' || e2 === '!Net') return '!Net';\n        if (e1 === '!IO' || e2 === '!IO') return '!IO';\n        return '!Pure';\n    }\n\n    private checkEffectSubtype(required: IrisEffect, declared: IrisEffect, message: string) {\n        if (declared === '!Infer') return;\n        if (declared === '!Any') return;\n\n        const ordReq = this.effectOrder(required);\n        const ordDecl = this.effectOrder(declared);\n\n        if (ordReq > ordDecl) {\n            throw new Error(`TypeError: EffectMismatch: ${message}: Inferred ${required} but declared ${declared}`);\n        }\n    }\n\n    private typesEqual(t1: IrisType, t2: IrisType): boolean {\n        if (t1.type !== t2.type) return false;\n        if (t1.type === 'Option') {\n            if (!t1.inner || !(t2 as any).inner) return false;\n            return this.typesEqual(t1.inner, (t2 as any).inner);\n        }\n        if (t1.type === 'Result') {\n            if (!t1.ok || !t1.err || !(t2 as any).ok || !(t2 as any).err) return false;\n            return this.typesEqual(t1.ok, (t2 as any).ok) && this.typesEqual(t1.err, (t2 as any).err);\n        }\n        if (t1.type === 'Record') {\n            const f1 = t1.fields;\n            const f2 = (t2 as any).fields;\n            const k1 = Object.keys(f1).sort();\n            const k2 = Object.keys(f2).sort();\n            if (k1.length !== k2.length) return false;\n            for (let i = 0; i < k1.length; i++) {\n                if (k1[i] !== k2[i]) return false;\n                if (!this.typesEqual(f1[k1[i]], f2[k1[i]])) return false;\n            }\n            return true;\n        }\n        if (t1.type === 'List') {\n            return this.typesEqual(t1.inner, (t2 as any).inner);\n        }\n        return true;\n    }\n\n    private fmt(t: IrisType): string {\n        switch (t.type) {\n            case 'I64': return 'I64';\n            case 'Bool': return 'Bool';\n            case 'Str': return 'Str';\n            case 'Option': return `(Option ${this.fmt(t.inner)})`;\n            case 'Result': return `(Result ${this.fmt(t.ok)} ${this.fmt(t.err)})`;\n            case 'List': return `(List ${this.fmt(t.inner)})`;\n            case 'Record': return `(Record ${Object.keys(t.fields).map(k => `(${k} ${this.fmt(t.fields[k])})`).join(' ')})`;\n            default: return 'Unknown';\n        }\n    }\n}\n", "import { Program, Definition, Expr, Value, IntrinsicOp, MatchCase, ModuleResolver } from './types';\n\n\nexport interface IFileSystem {\n    readFile(path: string): string | null; // null if not found/error\n    writeFile(path: string, content: string): boolean;\n    exists(path: string): boolean;\n    readDir?(path: string): string[] | null; // Optional\n}\n\nexport interface INetwork {\n    listen(port: number): Promise<number | null>;\n    accept(serverHandle: number): Promise<number | null>;\n    read(handle: number): Promise<string | null>;\n    write(handle: number, data: string): Promise<boolean>;\n    close(handle: number): Promise<boolean>;\n}\n\nclass MockFileSystem implements IFileSystem {\n    constructor(private data: Record<string, string>) { }\n    readFile(path: string) { return this.data[path] ?? null; }\n    writeFile(path: string, content: string) { this.data[path] = content; return true; }\n    exists(path: string) { return path in this.data; }\n    readDir(path: string) {\n        if (path === '.') return Object.keys(this.data);\n        return Object.keys(this.data).filter(k => k.startsWith(path + '/'));\n    }\n}\n\nclass MockNetwork implements INetwork {\n    async listen(port: number) { return 1; }\n    async accept(h: number) { return 2; } // Return a client handle\n    async read(h: number) { return \"GET / HTTP/1.1\\r\\n\\r\\n\"; }\n    async write(h: number, d: string) { return true; }\n    async close(h: number) { return true; }\n}\n\nexport class Interpreter {\n    private program: Program;\n    private functions = new Map<string, Definition & { kind: 'DefFn' }>();\n    private constants = new Map<string, Value>();\n    private fs: IFileSystem;\n    private net: INetwork;\n\n    constructor(program: Program, fs: Record<string, string> | IFileSystem = {}, private resolver?: ModuleResolver, net?: INetwork) {\n        this.program = program;\n        // Backwards compatibility with tests passing Record\n        if (typeof (fs as any).readFile === 'function') {\n            this.fs = fs as IFileSystem;\n        } else {\n            this.fs = new MockFileSystem(fs as Record<string, string>);\n        }\n        this.net = net || new MockNetwork();\n\n        for (const def of program.defs) {\n            if (def.kind === 'DefFn') {\n                this.functions.set(def.name, def);\n            }\n        }\n    }\n\n    async evalMain(): Promise<Value> {\n        // initialize constants\n        await this.initConstants();\n\n        const main = this.functions.get('main');\n        if (!main) throw new Error(\"No main function defined\");\n\n        return this.evalExpr(main.body, new Map());\n    }\n\n    // Public method to call a specific function with values\n    async callFunction(name: string, args: Value[]): Promise<Value> {\n        await this.initConstants();\n\n        const func = this.functions.get(name);\n        if (!func) throw new Error(`Unknown function: ${name}`);\n        if (args.length !== func.args.length) throw new Error(`Arity mismatch call ${name}`);\n\n        const newEnv = new Map<string, Value>();\n        for (let i = 0; i < args.length; i++) {\n            newEnv.set(func.args[i].name, args[i]);\n        }\n        return this.evalExpr(func.body, newEnv);\n    }\n\n    private async initConstants() {\n        if (this.constants.size > 0) return;\n        for (const def of this.program.defs) {\n            if (def.kind === 'DefConst') {\n                this.constants.set(def.name, await this.evalExpr(def.value, new Map()));\n            }\n        }\n    }\n\n    private async evalExpr(expr: Expr, env: Map<string, Value>): Promise<Value> {\n        switch (expr.kind) {\n            case 'Literal':\n                return expr.value;\n\n            case 'Var': {\n                const v = env.get(expr.name);\n                if (v !== undefined) return v;\n                const c = this.constants.get(expr.name);\n                if (c !== undefined) return c;\n\n                if (expr.name.includes('.')) {\n                    const parts = expr.name.split('.');\n                    let currentVal = env.get(parts[0]) || this.constants.get(parts[0]);\n                    if (currentVal) {\n                        for (let i = 1; i < parts.length; i++) {\n                            if (currentVal!.kind !== 'Record') throw new Error(`Runtime: Cannot access field ${parts[i]} of non-record`);\n                            const fieldVal: Value = (currentVal as any).fields[parts[i]];\n                            if (!fieldVal) throw new Error(`Runtime: Unknown field ${parts[i]}`);\n                            currentVal = fieldVal;\n                        }\n                        return currentVal!;\n                    }\n                }\n\n                throw new Error(`Runtime Unknown variable: ${expr.name}`);\n            }\n\n            case 'Let': {\n                const val = await this.evalExpr(expr.value, env);\n                const newEnv = new Map(env);\n                newEnv.set(expr.name, val);\n                return this.evalExpr(expr.body, newEnv);\n            }\n\n            case 'If': {\n                const cond = await this.evalExpr(expr.cond, env);\n                if (cond.kind !== 'Bool') throw new Error(\"If condition must be Bool\");\n                if (cond.value) {\n                    return this.evalExpr(expr.then, env);\n                } else {\n                    return this.evalExpr(expr.else, env);\n                }\n            }\n\n            case 'Call': {\n                let func = this.functions.get(expr.fn);\n\n                if (!func && expr.fn.includes('.')) {\n                    const [alias, fname] = expr.fn.split('.');\n                    const importDecl = this.program.imports.find(i => i.alias === alias);\n                    if (importDecl && this.resolver) {\n                        const importedProg = this.resolver(importDecl.path);\n                        if (importedProg) {\n                            const targetDef = importedProg.defs.find(d => d.kind === 'DefFn' && d.name === fname) as any;\n                            if (targetDef) {\n                                func = targetDef;\n                            }\n                        }\n                    }\n                }\n\n                if (!func) throw new Error(`Unknown function: ${expr.fn}`);\n\n                // Evaluate args in current scope\n                const args: Value[] = [];\n                for (const arg of expr.args) {\n                    args.push(await this.evalExpr(arg, env));\n                }\n\n                if (expr.fn.includes('.')) {\n                    // It's a cross-module call.\n                    const [alias, fname] = expr.fn.split('.');\n                    const importDecl = this.program.imports.find(i => i.alias === alias);\n                    if (importDecl && this.resolver) {\n                        const importedProg = this.resolver(importDecl.path)!;\n                        // New interpreter instance for the other module\n                        const subInterp = new Interpreter(importedProg, this.fs, this.resolver, this.net);\n                        return subInterp.callFunction(fname, args);\n                    }\n                }\n\n                if (args.length !== func.args.length) throw new Error(`Arity mismatch for ${expr.fn}`);\n\n                // Create new env for function body\n                const newEnv = new Map<string, Value>();\n                for (let i = 0; i < args.length; i++) {\n                    newEnv.set(func.args[i].name, args[i]);\n                }\n\n                return this.evalExpr(func.body, newEnv);\n            }\n\n            case 'Match': {\n                const target = await this.evalExpr(expr.target, env);\n\n                // Find matching case\n                for (const c of expr.cases) {\n                    // Check tag match\n                    let match = false;\n                    let newBindings = new Map(env);\n\n                    if (target.kind === 'Option') {\n                        if (c.tag === 'None' && target.value === null) match = true;\n                        else if (c.tag === 'Some' && target.value !== null) {\n                            match = true;\n                            if (c.vars.length > 0) newBindings.set(c.vars[0], target.value);\n                        }\n                    } else if (target.kind === 'Result') {\n                        if (c.tag === 'Ok' && target.isOk) {\n                            match = true;\n                            if (c.vars.length > 0) newBindings.set(c.vars[0], target.value);\n                        } else if (c.tag === 'Err' && !target.isOk) {\n                            match = true;\n                            if (c.vars.length > 0) newBindings.set(c.vars[0], target.value);\n                        }\n                    } else if (target.kind === 'List') {\n                        if (c.tag === 'nil' && target.items.length === 0) {\n                            match = true;\n                        } else if (c.tag === 'cons' && target.items.length > 0) {\n                            match = true;\n                            if (c.vars.length >= 1) newBindings.set(c.vars[0], target.items[0]);\n                            if (c.vars.length >= 2) {\n                                newBindings.set(c.vars[1], { kind: 'List', items: target.items.slice(1) });\n                            }\n                        }\n                    }\n\n                    if (match) {\n                        return this.evalExpr(c.body, newBindings);\n                    }\n                }\n                throw new Error(`No matching case for value ${JSON.stringify(target)}`);\n            }\n\n            case 'Record': {\n                const fields: Record<string, Value> = {};\n                for (const [key, valExpr] of Object.entries(expr.fields)) {\n                    fields[key] = await this.evalExpr(valExpr, env);\n                }\n                return { kind: 'Record', fields };\n            }\n\n            case 'Intrinsic': {\n                const args: Value[] = [];\n                for (const arg of expr.args) {\n                    args.push(await this.evalExpr(arg, env));\n                }\n                return this.evalIntrinsic(expr.op, args);\n            }\n\n            default:\n                throw new Error(`Unimplemented eval for ${(expr as any).kind}`);\n        }\n    }\n\n    private async evalIntrinsic(op: IntrinsicOp, args: Value[]): Promise<Value> {\n        if (['+', '-', '*', '/', '<=', '<', '='].includes(op)) {\n            const v1 = args[0];\n            const v2 = args[1];\n            if (v1.kind !== 'I64' || v2.kind !== 'I64') throw new Error(\"Math expects I64\");\n            const a = v1.value;\n            const b = v2.value;\n\n            switch (op) {\n                case '+': return { kind: 'I64', value: a + b };\n                case '-': return { kind: 'I64', value: a - b };\n                case '*': return { kind: 'I64', value: a * b };\n                case '/': {\n                    if (b === 0n) throw new Error(\"Division by zero\");\n                    return { kind: 'I64', value: a / b };\n                }\n                case '<=': return { kind: 'Bool', value: a <= b };\n                case '<': return { kind: 'Bool', value: a < b };\n                case '=': return { kind: 'Bool', value: a === b };\n            }\n        }\n\n        if (op === 'Some') {\n            return { kind: 'Option', value: args[0] };\n        }\n\n        if (op === 'Ok') return { kind: 'Result', isOk: true, value: args[0] };\n        if (op === 'Err') return { kind: 'Result', isOk: false, value: args[0] };\n\n        if (op === 'io.read_file') {\n            const path = args[0];\n            if (path.kind !== 'Str') throw new Error(\"path must be string\");\n            const content = this.fs.readFile(path.value);\n            if (content !== null) {\n                return { kind: 'Result', isOk: true, value: { kind: 'Str', value: content } };\n            } else {\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"ENOENT\" } };\n            }\n        }\n\n        if (op === 'io.write_file') {\n            const path = args[0];\n            const content = args[1];\n            if (path.kind !== 'Str') throw new Error(\"path must be string\");\n            if (content.kind !== 'Str') throw new Error(\"content must be string\");\n            this.fs.writeFile(path.value, content.value);\n            return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(content.value.length) } };\n        }\n\n        if (op === 'io.file_exists') {\n            const path = args[0];\n            if (path.kind !== 'Str') throw new Error(\"path must be string\");\n            return { kind: 'Bool', value: this.fs.exists(path.value) };\n        }\n\n        if (op === 'io.read_dir') {\n            const path = args[0];\n            if (path.kind !== 'Str') throw new Error(\"path must be string\");\n            if (!this.fs.readDir) return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Not supported\" } };\n\n            const entries = this.fs.readDir(path.value);\n            if (entries === null) return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Directory not found or error\" } };\n\n            const listVal: Value = {\n                kind: 'List',\n                items: entries.map(s => ({ kind: 'Str', value: s }))\n            };\n            return { kind: 'Result', isOk: true, value: listVal };\n        }\n\n        if (op === 'io.print') {\n            const val = args[0];\n            if (val.kind === 'Str') {\n                console.log(val.value);\n            } else if (val.kind === 'I64' || val.kind === 'Bool') {\n                console.log(val.value.toString());\n            } else {\n                console.log(JSON.stringify(val));\n            }\n            return { kind: 'I64', value: 0n };\n        }\n\n        if (op.startsWith('net.')) {\n            if (op === 'net.listen') {\n                const port = args[0];\n                if (port.kind !== 'I64') throw new Error(\"net.listen expects I64 port\");\n                const h = await this.net.listen(Number(port.value));\n                if (h !== null) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(h) } };\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Listen failed\" } };\n            }\n            if (op === 'net.accept') {\n                const serverSock = args[0];\n                if (serverSock.kind !== 'I64') throw new Error(\"net.accept expects I64\");\n                const h = await this.net.accept(Number(serverSock.value));\n                if (h !== null) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(h) } };\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Accept failed\" } };\n            }\n            if (op === 'net.read') {\n                const sock = args[0];\n                if (sock.kind !== 'I64') throw new Error(\"net.read expects I64\");\n                const s = await this.net.read(Number(sock.value));\n                if (s !== null) return { kind: 'Result', isOk: true, value: { kind: 'Str', value: s } };\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Read failed\" } };\n            }\n            if (op === 'net.write') {\n                const sock = args[0];\n                const str = args[1];\n                if (sock.kind !== 'I64') throw new Error(\"net.write expects I64\");\n                if (str.kind !== 'Str') throw new Error(\"net.write expects Str\");\n                const s = await this.net.write(Number(sock.value), str.value);\n                if (s) return { kind: 'Result', isOk: true, value: { kind: 'I64', value: BigInt(s ? 1 : 0) } };\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Write failed\" } };\n            }\n            if (op === 'net.close') {\n                const sock = args[0];\n                if (sock.kind !== 'I64') throw new Error(\"net.close expects I64\");\n                const s = await this.net.close(Number(sock.value));\n                if (s) return { kind: 'Result', isOk: true, value: { kind: 'Bool', value: true } };\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: \"Close failed\" } };\n            }\n        }\n\n        if (op === 'http.parse_request') {\n            const raw = args[0];\n            if (raw.kind !== 'Str') throw new Error(\"http.parse_request expects Str\");\n            const text = raw.value;\n\n            try {\n                const parts = text.split(/\\r?\\n\\r?\\n/); // Split head and body\n                const head = parts[0];\n                const body = parts.slice(1).join('\\n\\n');\n\n                const lines = head.split(/\\r?\\n/);\n                if (lines.length === 0) throw new Error(\"Empty request\");\n\n                const reqLine = lines[0].split(' ');\n                if (reqLine.length < 3) throw new Error(\"Invalid request line\");\n                const method = reqLine[0];\n                const path = reqLine[1];\n\n                const headers: Value[] = [];\n                for (let i = 1; i < lines.length; i++) {\n                    const line = lines[i];\n                    if (!line.trim()) continue;\n                    const idx = line.indexOf(':');\n                    if (idx !== -1) {\n                        const key = line.substring(0, idx).trim();\n                        const val = line.substring(idx + 1).trim();\n                        headers.push({\n                            kind: 'Record',\n                            fields: {\n                                key: { kind: 'Str', value: key },\n                                val: { kind: 'Str', value: val }\n                            }\n                        });\n                    }\n                }\n\n                const reqRecord: Value = {\n                    kind: 'Record',\n                    fields: {\n                        method: { kind: 'Str', value: method },\n                        path: { kind: 'Str', value: path },\n                        headers: { kind: 'List', items: headers },\n                        body: { kind: 'Str', value: body }\n                    }\n                };\n\n                return { kind: 'Result', isOk: true, value: reqRecord };\n            } catch (e: any) {\n                return { kind: 'Result', isOk: false, value: { kind: 'Str', value: e.message } };\n            }\n        }\n\n        if (op === 'str.concat') {\n            const s1 = args[0]; const s2 = args[1];\n            if (s1.kind !== 'Str' || s2.kind !== 'Str') throw new Error(\"str.concat expects two strings\");\n            return { kind: 'Str', value: s1.value + s2.value };\n        }\n\n        if (op === 'str.contains') {\n            const s1 = args[0]; const s2 = args[1];\n            if (s1.kind !== 'Str' || s2.kind !== 'Str') throw new Error(\"str.contains expects two strings\");\n            return { kind: 'Bool', value: s1.value.includes(s2.value) };\n        }\n\n        if (op === 'str.ends_with') {\n            const s1 = args[0]; const s2 = args[1];\n            if (s1.kind !== 'Str' || s2.kind !== 'Str') throw new Error(\"str.ends_with expects two strings\");\n            return { kind: 'Bool', value: s1.value.endsWith(s2.value) };\n        }\n\n        throw new Error(`Unknown intrinsic ${op}`);\n    }\n}\n", "import { Parser, printValue } from './sexp';\nimport { TypeChecker } from './typecheck';\nimport { Interpreter } from './eval';\nimport { ModuleResolver, Program } from './types';\n\n// Helper to find imports without parsing everything?\n// We need to parse to find imports.\nfunction getImports(source: string): string[] {\n    try {\n        const parser = new Parser(source);\n        const prog = parser.parse();\n        return prog.imports.map(i => i.path);\n    } catch {\n        return [];\n    }\n}\n\nfunction checkCircularImports(entryPath: string, modules: Record<string, string>) {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    function dfs(path: string) {\n        if (recursionStack.has(path)) {\n            // Found a cycle!\n            // We need to reconstruct the path for the error message?\n            // \"Cycle detected: modB -> modA ...\" (simplification)\n            // The path is implicit in recursionStack, but Set iteration order matches insertion in JS.\n            // Let's find the cycle start.\n            const stack = Array.from(recursionStack);\n            const cycleStart = stack.indexOf(path);\n            const cycle = stack.slice(cycleStart).concat(path).join(' -> ');\n            throw new Error(`Circular import detected: ${cycle}`);\n        }\n        if (visited.has(path)) return;\n\n        visited.add(path);\n        recursionStack.add(path);\n\n        const source = modules[path];\n        if (source) {\n            const imports = getImports(source);\n            for (const imp of imports) {\n                dfs(imp);\n            }\n        }\n\n        recursionStack.delete(path);\n    }\n\n    // We don't check entryPath itself usually if it's \"source\" argument (not in modules map),\n    // but the Source imports modules which might cycle.\n    // The entry source is passed separately.\n    // Let's assume entry imports X.\n    // But we need to parse entry too.\n    return; // logic moved to run()\n}\n\nimport { IFileSystem, INetwork } from './eval';\n\n// Helper to encapsulate program + resolver for interpreter\ntype CheckResult = { success: true, program: Program, resolver: ModuleResolver } | { success: false, error: string };\n\nexport function check(source: string, modules: Record<string, string> = {}): CheckResult {\n    // 1. Parse\n    const parser = new Parser(source);\n    let program;\n    try {\n        program = parser.parse();\n    } catch (e: any) {\n        return { success: false, error: `ParseError: ${e.message}` };\n    }\n\n    // 1b. Check Circular Imports starting from main program\n    try {\n        const visited = new Set<string>();\n        const recursionStack = new Set<string>();\n\n        const dfs = (path: string) => {\n            if (recursionStack.has(path)) {\n                // Construct nice message\n                const stack = Array.from(recursionStack);\n                const idx = stack.indexOf(path);\n                const cycle = stack.slice(idx).concat(path).join(' -> ');\n                throw new Error(`Circular import detected: ${cycle}`);\n            }\n            if (visited.has(path)) return;\n\n            visited.add(path);\n            recursionStack.add(path);\n\n            const src = modules[path];\n            if (src) {\n                const p = new Parser(src);\n                const pr = p.parse();\n                for (const i of pr.imports) {\n                    dfs(i.path);\n                }\n            }\n            recursionStack.delete(path);\n        };\n\n        for (const i of program.imports) {\n            dfs(i.path);\n        }\n\n    } catch (e: any) {\n        return { success: false, error: `RuntimeError: ${e.message}` };\n    }\n\n    // Create caching resolver\n    const cache = new Map<string, Program>();\n    const resolver: ModuleResolver = (path: string) => {\n        if (cache.has(path)) return cache.get(path);\n\n        const modSource = modules[path];\n        if (!modSource) return undefined;\n        try {\n            const p = new Parser(modSource);\n            const pr = p.parse();\n            cache.set(path, pr);\n            return pr;\n        } catch (e) {\n            console.error(`Failed to parse module ${path}:`, e);\n            return undefined;\n        }\n    };\n\n    // 2. Typecheck\n    const checker = new TypeChecker(resolver);\n    try {\n        checker.check(program);\n    } catch (e: any) {\n        if (e.message.startsWith('TypeError:')) {\n            return { success: false, error: e.message };\n        }\n        return { success: false, error: `TypeError: ${e.message}` };\n    }\n\n    return { success: true, program, resolver };\n}\n\n\n\n// ... other imports\n\nexport async function run(source: string, fsMap: Record<string, string> | IFileSystem = {}, modules: Record<string, string> = {}, net?: INetwork): Promise<string> {\n    const checked = check(source, modules);\n    if (!checked.success) return checked.error;\n\n    // 3. Interpret\n    const interpreter = new Interpreter(checked.program, fsMap, checked.resolver, net);\n    let result;\n    try {\n        result = await interpreter.evalMain();\n    } catch (e: any) {\n        return `RuntimeError: ${e.message}`;\n    }\n\n    return printValue(result);\n}\n", "\nimport { IFileSystem, INetwork } from '../eval';\n\nexport class BrowserFileSystem implements IFileSystem {\n    private files: Map<string, string> = new Map();\n\n    readFileSync(path: string): string {\n        if (!this.files.has(path)) {\n            throw new Error(`File not found: ${path}`);\n        }\n        return this.files.get(path) || \"\";\n    }\n\n    writeFileSync(path: string, content: string): void {\n        this.files.set(path, content);\n    }\n\n    existsSync(path: string): boolean {\n        return this.files.has(path);\n    }\n\n    readDirSync(path: string): string[] {\n        // Simple prefix match simulation\n        const results: string[] = [];\n        for (const key of this.files.keys()) {\n            if (key.startsWith(path)) {\n                results.push(key);\n            }\n        }\n        return results;\n    }\n}\n\nexport class BrowserNetwork implements INetwork {\n    async listen(port: number): Promise<number> {\n        console.log(`[BrowserNet] Mock listening on port ${port}`);\n        return 1; // Mock handle\n    }\n\n    async accept(serverHandle: number): Promise<number> {\n        console.log(`[BrowserNet] Waiting for connection... (Mock: Returning immediately)`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return 2; // Mock client handle\n    }\n\n    async read(handle: number): Promise<string> {\n        return \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n    }\n\n    async write(handle: number, data: string): Promise<void> {\n        console.log(`[BrowserNet] Writing to ${handle}:`);\n        console.log(data);\n    }\n\n    async close(handle: number): Promise<void> {\n        console.log(`[BrowserNet] Closed handle ${handle}`);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
